// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddUsersToInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfAddUsersToInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes AddUsersToInternalSquadResponseDto from json.
func (s *AddUsersToInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToInternalSquadResponseDto) {
					name = jsonFieldsNameOfAddUsersToInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes AddUsersToInternalSquadResponseDtoResponse from json.
func (s *AddUsersToInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerCreateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerCreateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerCreateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerCreateInternalServerError from json.
func (s *ApiTokensControllerCreateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerCreateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerCreateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerCreateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerCreateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerDeleteInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerDeleteInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerDeleteInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerDeleteInternalServerError from json.
func (s *ApiTokensControllerDeleteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerDeleteInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerDeleteInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerDeleteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerDeleteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerFindAllInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerFindAllInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerFindAllInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerFindAllInternalServerError from json.
func (s *ApiTokensControllerFindAllInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerFindAllInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerFindAllInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerFindAllInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerFindAllInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerGetStatusInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerGetStatusInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerGetStatusInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerGetStatusInternalServerError from json.
func (s *AuthControllerGetStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerGetStatusInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerGetStatusInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerGetStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerGetStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerLoginInternalServerError from json.
func (s *AuthControllerLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginUnauthorized) encodeFields(e *jx.Encoder) {
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginUnauthorized = [3]string{
	0: "statusCode",
	1: "message",
	2: "error",
}

// Decode decodes AuthControllerLoginUnauthorized from json.
func (s *AuthControllerLoginUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginUnauthorized to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginUnauthorized")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2AuthorizeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2AuthorizeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerOauth2AuthorizeInternalServerError from json.
func (s *AuthControllerOauth2AuthorizeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2AuthorizeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2AuthorizeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2CallbackInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2CallbackInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerOauth2CallbackInternalServerError from json.
func (s *AuthControllerOauth2CallbackInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2CallbackInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2CallbackInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterForbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterForbidden) encodeFields(e *jx.Encoder) {
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerRegisterForbidden = [3]string{
	0: "statusCode",
	1: "message",
	2: "error",
}

// Decode decodes AuthControllerRegisterForbidden from json.
func (s *AuthControllerRegisterForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterForbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterForbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerRegisterInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerRegisterInternalServerError from json.
func (s *AuthControllerRegisterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerTelegramCallbackInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerTelegramCallbackInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerTelegramCallbackInternalServerError from json.
func (s *AuthControllerTelegramCallbackInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerTelegramCallbackInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerTelegramCallbackInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllResetTrafficUsersResponseDto from json.
func (s *BulkAllResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllResetTrafficUsersResponseDtoResponse from json.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersRequestDto = [8]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
}

// Decode decodes BulkAllUpdateUsersRequestDto from json.
func (s *BulkAllUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (s BulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (s *BulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoStatus(v) {
	case BulkAllUpdateUsersRequestDtoStatusACTIVE:
		*s = BulkAllUpdateUsersRequestDtoStatusACTIVE
	case BulkAllUpdateUsersRequestDtoStatusDISABLED:
		*s = BulkAllUpdateUsersRequestDtoStatusDISABLED
	case BulkAllUpdateUsersRequestDtoStatusLIMITED:
		*s = BulkAllUpdateUsersRequestDtoStatusLIMITED
	case BulkAllUpdateUsersRequestDtoStatusEXPIRED:
		*s = BulkAllUpdateUsersRequestDtoStatusEXPIRED
	default:
		*s = BulkAllUpdateUsersRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v) {
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllUpdateUsersResponseDto from json.
func (s *BulkAllUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllUpdateUsersResponseDtoResponse from json.
func (s *BulkAllUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteHostsRequestDto from json.
func (s *BulkDeleteHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsRequestDto) {
					name = jsonFieldsNameOfBulkDeleteHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteHostsResponseDto from json.
func (s *BulkDeleteHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDeleteHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDeleteHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDto) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItem from json.
func (s *BulkDeleteHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemInbound from json.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusRequestDto = [1]string{
	0: "status",
}

// Decode decodes BulkDeleteUsersByStatusRequestDto from json.
func (s *BulkDeleteUsersByStatusRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (s BulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteUsersByStatusRequestDtoStatus(v) {
	case BulkDeleteUsersByStatusRequestDtoStatusACTIVE:
		*s = BulkDeleteUsersByStatusRequestDtoStatusACTIVE
	case BulkDeleteUsersByStatusRequestDtoStatusDISABLED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusDISABLED
	case BulkDeleteUsersByStatusRequestDtoStatusLIMITED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusLIMITED
	case BulkDeleteUsersByStatusRequestDtoStatusEXPIRED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusEXPIRED
	default:
		*s = BulkDeleteUsersByStatusRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersByStatusResponseDto from json.
func (s *BulkDeleteUsersByStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersByStatusResponseDtoResponse from json.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteUsersRequestDto from json.
func (s *BulkDeleteUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersRequestDto) {
					name = jsonFieldsNameOfBulkDeleteUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersResponseDto from json.
func (s *BulkDeleteUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersResponseDtoResponse from json.
func (s *BulkDeleteUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDisableHostsRequestDto from json.
func (s *BulkDisableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsRequestDto) {
					name = jsonFieldsNameOfBulkDisableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDisableHostsResponseDto from json.
func (s *BulkDisableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDisableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDisableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDto) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes BulkDisableHostsResponseDtoResponseItem from json.
func (s *BulkDisableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemInbound from json.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDisableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkEnableHostsRequestDto from json.
func (s *BulkEnableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsRequestDto) {
					name = jsonFieldsNameOfBulkEnableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkEnableHostsResponseDto from json.
func (s *BulkEnableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkEnableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkEnableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDto) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes BulkEnableHostsResponseDtoResponseItem from json.
func (s *BulkEnableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemInbound from json.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkEnableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkResetTrafficUsersRequestDto from json.
func (s *BulkResetTrafficUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersRequestDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkResetTrafficUsersResponseDto from json.
func (s *BulkResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkResetTrafficUsersResponseDtoResponse from json.
func (s *BulkResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkRevokeUsersSubscriptionRequestDto from json.
func (s *BulkRevokeUsersSubscriptionRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDto from json.
func (s *BulkRevokeUsersSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDtoResponse from json.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("fields")
		s.Fields.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDto = [2]string{
	0: "uuids",
	1: "fields",
}

// Decode decodes BulkUpdateUsersRequestDto from json.
func (s *BulkUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDtoFields) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDtoFields = [8]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
}

// Decode decodes BulkUpdateUsersRequestDtoFields from json.
func (s *BulkUpdateUsersRequestDtoFields) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFields to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDtoFields")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (s BulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsStatus(v) {
	case BulkUpdateUsersRequestDtoFieldsStatusACTIVE:
		*s = BulkUpdateUsersRequestDtoFieldsStatusACTIVE
	case BulkUpdateUsersRequestDtoFieldsStatusDISABLED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusDISABLED
	case BulkUpdateUsersRequestDtoFieldsStatusLIMITED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusLIMITED
	case BulkUpdateUsersRequestDtoFieldsStatusEXPIRED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusEXPIRED
	default:
		*s = BulkUpdateUsersRequestDtoFieldsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v) {
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH
	default:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersResponseDto from json.
func (s *BulkUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersResponseDtoResponse from json.
func (s *BulkUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto = [2]string{
	0: "uuids",
	1: "activeInternalSquads",
}

// Decode decodes BulkUpdateUsersSquadsRequestDto from json.
func (s *BulkUpdateUsersSquadsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "activeInternalSquads":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersSquadsResponseDto from json.
func (s *BulkUpdateUsersSquadsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersSquadsResponseDtoResponse from json.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerCreateConfigProfileInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerCreateConfigProfileInternalServerError from json.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerCreateConfigProfileInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerCreateConfigProfileInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerDeleteConfigProfileByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError from json.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetAllInboundsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetAllInboundsInternalServerError from json.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetAllInboundsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetAllInboundsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfileByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetConfigProfileByUuidInternalServerError from json.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfileByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfileByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfilesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetConfigProfilesInternalServerError from json.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfilesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfilesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetInboundsByProfileUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetInboundsByProfileUuidInternalServerError from json.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetInboundsByProfileUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetInboundsByProfileUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerUpdateConfigProfileInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerUpdateConfigProfileInternalServerError from json.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerUpdateConfigProfileInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerUpdateConfigProfileInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
}

var jsonFieldsNameOfCreateApiTokenRequestDto = [1]string{
	0: "tokenName",
}

// Decode decodes CreateApiTokenRequestDto from json.
func (s *CreateApiTokenRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tokenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenRequestDto) {
					name = jsonFieldsNameOfCreateApiTokenRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateApiTokenResponseDto from json.
func (s *CreateApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDto) {
					name = jsonFieldsNameOfCreateApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDtoResponse = [2]string{
	0: "token",
	1: "uuid",
}

// Decode decodes CreateApiTokenResponseDtoResponse from json.
func (s *CreateApiTokenResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDtoResponse) {
					name = jsonFieldsNameOfCreateApiTokenResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
}

var jsonFieldsNameOfCreateConfigProfileRequestDto = [2]string{
	0: "name",
	1: "config",
}

// Decode decodes CreateConfigProfileRequestDto from json.
func (s *CreateConfigProfileRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileRequestDto) {
					name = jsonFieldsNameOfCreateConfigProfileRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileRequestDtoConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileRequestDtoConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateConfigProfileRequestDtoConfig = [0]string{}

// Decode decodes CreateConfigProfileRequestDtoConfig from json.
func (s *CreateConfigProfileRequestDtoConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileRequestDtoConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileRequestDtoConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileRequestDtoConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileRequestDtoConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateConfigProfileResponseDto from json.
func (s *CreateConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDto) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes CreateConfigProfileResponseDtoResponse from json.
func (s *CreateConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]CreateConfigProfileResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateConfigProfileResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]CreateConfigProfileResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateConfigProfileResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateConfigProfileResponseDtoResponseInboundsItem from json.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateConfigProfileResponseDtoResponseNodesItem from json.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateHostRequestDto = [13]string{
	0:  "inbound",
	1:  "remark",
	2:  "address",
	3:  "port",
	4:  "path",
	5:  "sni",
	6:  "host",
	7:  "alpn",
	8:  "fingerprint",
	9:  "isDisabled",
	10: "securityLayer",
	11: "xHttpExtraParams",
	12: "serverDescription",
}

// Decode decodes CreateHostRequestDto from json.
func (s *CreateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inbound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00001111,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostRequestDto) {
					name = jsonFieldsNameOfCreateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (s CreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (s *CreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoAlpn(v) {
	case CreateHostRequestDtoAlpnH3:
		*s = CreateHostRequestDtoAlpnH3
	case CreateHostRequestDtoAlpnH2:
		*s = CreateHostRequestDtoAlpnH2
	case CreateHostRequestDtoAlpnHTTP11:
		*s = CreateHostRequestDtoAlpnHTTP11
	case CreateHostRequestDtoAlpnH2HTTP11:
		*s = CreateHostRequestDtoAlpnH2HTTP11
	case CreateHostRequestDtoAlpnH3H2HTTP11:
		*s = CreateHostRequestDtoAlpnH3H2HTTP11
	case CreateHostRequestDtoAlpnH3H2:
		*s = CreateHostRequestDtoAlpnH3H2
	default:
		*s = CreateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (s CreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (s *CreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoFingerprint(v) {
	case CreateHostRequestDtoFingerprintChrome:
		*s = CreateHostRequestDtoFingerprintChrome
	case CreateHostRequestDtoFingerprintFirefox:
		*s = CreateHostRequestDtoFingerprintFirefox
	case CreateHostRequestDtoFingerprintSafari:
		*s = CreateHostRequestDtoFingerprintSafari
	case CreateHostRequestDtoFingerprintIos:
		*s = CreateHostRequestDtoFingerprintIos
	case CreateHostRequestDtoFingerprintAndroid:
		*s = CreateHostRequestDtoFingerprintAndroid
	case CreateHostRequestDtoFingerprintEdge:
		*s = CreateHostRequestDtoFingerprintEdge
	case CreateHostRequestDtoFingerprintQq:
		*s = CreateHostRequestDtoFingerprintQq
	case CreateHostRequestDtoFingerprintRandom:
		*s = CreateHostRequestDtoFingerprintRandom
	case CreateHostRequestDtoFingerprintRandomized:
		*s = CreateHostRequestDtoFingerprintRandomized
	default:
		*s = CreateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostRequestDtoInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfCreateHostRequestDtoInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes CreateHostRequestDtoInbound from json.
func (s *CreateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostRequestDtoInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostRequestDtoInbound) {
					name = jsonFieldsNameOfCreateHostRequestDtoInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (s CreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (s *CreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoSecurityLayer(v) {
	case CreateHostRequestDtoSecurityLayerDEFAULT:
		*s = CreateHostRequestDtoSecurityLayerDEFAULT
	case CreateHostRequestDtoSecurityLayerTLS:
		*s = CreateHostRequestDtoSecurityLayerTLS
	case CreateHostRequestDtoSecurityLayerNONE:
		*s = CreateHostRequestDtoSecurityLayerNONE
	default:
		*s = CreateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateHostResponseDto from json.
func (s *CreateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDto) {
					name = jsonFieldsNameOfCreateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes CreateHostResponseDtoResponse from json.
func (s *CreateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDtoResponse) {
					name = jsonFieldsNameOfCreateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes CreateHostResponseDtoResponseInbound from json.
func (s *CreateHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfCreateHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (s CreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (s *CreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostResponseDtoResponseSecurityLayer(v) {
	case CreateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = CreateHostResponseDtoResponseSecurityLayerDEFAULT
	case CreateHostResponseDtoResponseSecurityLayerTLS:
		*s = CreateHostResponseDtoResponseSecurityLayerTLS
	case CreateHostResponseDtoResponseSecurityLayerNONE:
		*s = CreateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = CreateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto = [3]string{
	0: "providerUuid",
	1: "amount",
	2: "billedAt",
}

// Decode decodes CreateInfraBillingHistoryRecordRequestDto from json.
func (s *CreateInfraBillingHistoryRecordRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDto from json.
func (s *CreateInfraBillingHistoryRecordResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponse from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		if s.NextBillingAt.Set {
			e.FieldStart("nextBillingAt")
			s.NextBillingAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeRequestDto = [3]string{
	0: "providerUuid",
	1: "nodeUuid",
	2: "nextBillingAt",
}

// Decode decodes CreateInfraBillingNodeRequestDto from json.
func (s *CreateInfraBillingNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nextBillingAt":
			if err := func() error {
				s.NextBillingAt.Reset()
				if err := s.NextBillingAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeRequestDto) {
					name = jsonFieldsNameOfCreateInfraBillingNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraBillingNodeResponseDto from json.
func (s *CreateInfraBillingNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDto) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponse from json.
func (s *CreateInfraBillingNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]CreateInfraBillingNodeResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingNodeResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem from json.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItem from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseStats from json.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.FaviconLink.Set {
			e.FieldStart("faviconLink")
			s.FaviconLink.Encode(e)
		}
	}
	{
		if s.LoginUrl.Set {
			e.FieldStart("loginUrl")
			s.LoginUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateInfraProviderRequestDto = [3]string{
	0: "name",
	1: "faviconLink",
	2: "loginUrl",
}

// Decode decodes CreateInfraProviderRequestDto from json.
func (s *CreateInfraProviderRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			if err := func() error {
				s.FaviconLink.Reset()
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			if err := func() error {
				s.LoginUrl.Reset()
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderRequestDto) {
					name = jsonFieldsNameOfCreateInfraProviderRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraProviderResponseDto from json.
func (s *CreateInfraProviderResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDto) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes CreateInfraProviderResponseDtoResponse from json.
func (s *CreateInfraProviderResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]CreateInfraProviderResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraProviderResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes CreateInfraProviderResponseDtoResponseBillingHistory from json.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraProviderResponseDtoResponseBillingNodesItem from json.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateInternalSquadRequestDto = [2]string{
	0: "name",
	1: "inbounds",
}

// Decode decodes CreateInternalSquadRequestDto from json.
func (s *CreateInternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadRequestDto) {
					name = jsonFieldsNameOfCreateInternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInternalSquadResponseDto from json.
func (s *CreateInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDto) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes CreateInternalSquadResponseDtoResponse from json.
func (s *CreateInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]CreateInternalSquadResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInternalSquadResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateInternalSquadResponseDtoResponseInboundsItem from json.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes CreateInternalSquadResponseDtoResponseInfo from json.
func (s *CreateInternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		if s.ProviderUuid.Set {
			e.FieldStart("providerUuid")
			s.ProviderUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateNodeRequestDto = [11]string{
	0:  "name",
	1:  "address",
	2:  "port",
	3:  "isTrafficTrackingActive",
	4:  "trafficLimitBytes",
	5:  "notifyPercent",
	6:  "trafficResetDay",
	7:  "countryCode",
	8:  "consumptionMultiplier",
	9:  "configProfile",
	10: "providerUuid",
}

// Decode decodes CreateNodeRequestDto from json.
func (s *CreateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "configProfile":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			if err := func() error {
				s.ProviderUuid.Reset()
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeRequestDto) {
					name = jsonFieldsNameOfCreateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeRequestDtoConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		json.EncodeUUID(e, s.ActiveConfigProfileUuid)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateNodeRequestDtoConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes CreateNodeRequestDtoConfigProfile from json.
func (s *CreateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeRequestDtoConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActiveConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeRequestDtoConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeRequestDtoConfigProfile) {
					name = jsonFieldsNameOfCreateNodeRequestDtoConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateNodeResponseDto from json.
func (s *CreateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDto) {
					name = jsonFieldsNameOfCreateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes CreateNodeResponseDtoResponse from json.
func (s *CreateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes CreateNodeResponseDtoResponseConfigProfile from json.
func (s *CreateNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes CreateNodeResponseDtoResponseProvider from json.
func (s *CreateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.OsVersion.Set {
			e.FieldStart("osVersion")
			s.OsVersion.Encode(e)
		}
	}
	{
		if s.DeviceModel.Set {
			e.FieldStart("deviceModel")
			s.DeviceModel.Encode(e)
		}
	}
	{
		if s.UserAgent.Set {
			e.FieldStart("userAgent")
			s.UserAgent.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceRequestDto = [6]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
}

// Decode decodes CreateUserHwidDeviceRequestDto from json.
func (s *CreateUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			if err := func() error {
				s.OsVersion.Reset()
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			if err := func() error {
				s.DeviceModel.Reset()
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			if err := func() error {
				s.UserAgent.Reset()
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateUserHwidDeviceResponseDto from json.
func (s *CreateUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes CreateUserHwidDeviceResponseDtoResponse from json.
func (s *CreateUserHwidDeviceResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]CreateUserHwidDeviceResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateUserHwidDeviceResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes CreateUserHwidDeviceResponseDtoResponseDevicesItem from json.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ShortUuid.Set {
			e.FieldStart("shortUuid")
			s.ShortUuid.Encode(e)
		}
	}
	{
		if s.TrojanPassword.Set {
			e.FieldStart("trojanPassword")
			s.TrojanPassword.Encode(e)
		}
	}
	{
		if s.VlessUuid.Set {
			e.FieldStart("vlessUuid")
			s.VlessUuid.Encode(e)
		}
	}
	{
		if s.SsPassword.Set {
			e.FieldStart("ssPassword")
			s.SsPassword.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTrafficResetAt.Set {
			e.FieldStart("lastTrafficResetAt")
			s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ActiveInternalSquads != nil {
			e.FieldStart("activeInternalSquads")
			e.ArrStart()
			for _, elem := range s.ActiveInternalSquads {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateUserRequestDto = [17]string{
	0:  "username",
	1:  "status",
	2:  "shortUuid",
	3:  "trojanPassword",
	4:  "vlessUuid",
	5:  "ssPassword",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "expireAt",
	9:  "createdAt",
	10: "lastTrafficResetAt",
	11: "description",
	12: "tag",
	13: "telegramId",
	14: "email",
	15: "hwidDeviceLimit",
	16: "activeInternalSquads",
}

// Decode decodes CreateUserRequestDto from json.
func (s *CreateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDto to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "shortUuid":
			if err := func() error {
				s.ShortUuid.Reset()
				if err := s.ShortUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "trojanPassword":
			if err := func() error {
				s.TrojanPassword.Reset()
				if err := s.TrojanPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			if err := func() error {
				s.VlessUuid.Reset()
				if err := s.VlessUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			if err := func() error {
				s.SsPassword.Reset()
				if err := s.SsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "lastTrafficResetAt":
			if err := func() error {
				s.LastTrafficResetAt.Reset()
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "activeInternalSquads":
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserRequestDto) {
					name = jsonFieldsNameOfCreateUserRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (s CreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (s *CreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoStatus(v) {
	case CreateUserRequestDtoStatusACTIVE:
		*s = CreateUserRequestDtoStatusACTIVE
	case CreateUserRequestDtoStatusDISABLED:
		*s = CreateUserRequestDtoStatusDISABLED
	case CreateUserRequestDtoStatusLIMITED:
		*s = CreateUserRequestDtoStatusLIMITED
	case CreateUserRequestDtoStatusEXPIRED:
		*s = CreateUserRequestDtoStatusEXPIRED
	default:
		*s = CreateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoTrafficLimitStrategy as json.
func (s CreateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoTrafficLimitStrategy from json.
func (s *CreateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoTrafficLimitStrategy(v) {
	case CreateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = CreateUserRequestDtoTrafficLimitStrategyNORESET
	case CreateUserRequestDtoTrafficLimitStrategyDAY:
		*s = CreateUserRequestDtoTrafficLimitStrategyDAY
	case CreateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = CreateUserRequestDtoTrafficLimitStrategyWEEK
	case CreateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = CreateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = CreateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.Bool(s.Response)
	}
}

var jsonFieldsNameOfDeleteApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteApiTokenResponseDto from json.
func (s *DeleteApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Response = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteApiTokenResponseDto) {
					name = jsonFieldsNameOfDeleteApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteConfigProfileResponseDto from json.
func (s *DeleteConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteConfigProfileResponseDto) {
					name = jsonFieldsNameOfDeleteConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteConfigProfileResponseDtoResponse from json.
func (s *DeleteConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteHostResponseDto from json.
func (s *DeleteHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDto) {
					name = jsonFieldsNameOfDeleteHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteHostResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteHostResponseDtoResponse from json.
func (s *DeleteHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDto from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDto from json.
func (s *DeleteInfraBillingNodeByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponse from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseStats from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraProviderByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraProviderByUuidResponseDto from json.
func (s *DeleteInfraProviderByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraProviderByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraProviderByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraProviderByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteInfraProviderByUuidResponseDtoResponse from json.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraProviderByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraProviderByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInternalSquadResponseDto from json.
func (s *DeleteInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInternalSquadResponseDto) {
					name = jsonFieldsNameOfDeleteInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteInternalSquadResponseDtoResponse from json.
func (s *DeleteInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteNodeResponseDto from json.
func (s *DeleteNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDto) {
					name = jsonFieldsNameOfDeleteNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteNodeResponseDtoResponse from json.
func (s *DeleteNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceRequestDto = [2]string{
	0: "userUuid",
	1: "hwid",
}

// Decode decodes DeleteUserHwidDeviceRequestDto from json.
func (s *DeleteUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "hwid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserHwidDeviceResponseDto from json.
func (s *DeleteUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes DeleteUserHwidDeviceResponseDtoResponse from json.
func (s *DeleteUserHwidDeviceResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]DeleteUserHwidDeviceResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteUserHwidDeviceResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteUserHwidDeviceResponseDtoResponseDevicesItem from json.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserResponseDto from json.
func (s *DeleteUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDto) {
					name = jsonFieldsNameOfDeleteUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteUserResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteUserResponseDtoResponse from json.
func (s *DeleteUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableNodeResponseDto from json.
func (s *DisableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDto) {
					name = jsonFieldsNameOfDisableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes DisableNodeResponseDtoResponse from json.
func (s *DisableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes DisableNodeResponseDtoResponseConfigProfile from json.
func (s *DisableNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes DisableNodeResponseDtoResponseProvider from json.
func (s *DisableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableUserResponseDto from json.
func (s *DisableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDto) {
					name = jsonFieldsNameOfDisableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponse = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes DisableUserResponseDtoResponse from json.
func (s *DisableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]DisableUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponse) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes DisableUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes DisableUserResponseDtoResponseHapp from json.
func (s *DisableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (s DisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (s *DisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseStatus(v) {
	case DisableUserResponseDtoResponseStatusACTIVE:
		*s = DisableUserResponseDtoResponseStatusACTIVE
	case DisableUserResponseDtoResponseStatusDISABLED:
		*s = DisableUserResponseDtoResponseStatusDISABLED
	case DisableUserResponseDtoResponseStatusLIMITED:
		*s = DisableUserResponseDtoResponseStatusLIMITED
	case DisableUserResponseDtoResponseStatusEXPIRED:
		*s = DisableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = DisableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case DisableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case DisableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyDAY
	case DisableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case DisableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableNodeResponseDto from json.
func (s *EnableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDto) {
					name = jsonFieldsNameOfEnableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes EnableNodeResponseDtoResponse from json.
func (s *EnableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes EnableNodeResponseDtoResponseConfigProfile from json.
func (s *EnableNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes EnableNodeResponseDtoResponseProvider from json.
func (s *EnableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableUserResponseDto from json.
func (s *EnableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDto) {
					name = jsonFieldsNameOfEnableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponse = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes EnableUserResponseDtoResponse from json.
func (s *EnableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]EnableUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponse) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes EnableUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes EnableUserResponseDtoResponseHapp from json.
func (s *EnableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (s EnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (s *EnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseStatus(v) {
	case EnableUserResponseDtoResponseStatusACTIVE:
		*s = EnableUserResponseDtoResponseStatusACTIVE
	case EnableUserResponseDtoResponseStatusDISABLED:
		*s = EnableUserResponseDtoResponseStatusDISABLED
	case EnableUserResponseDtoResponseStatusLIMITED:
		*s = EnableUserResponseDtoResponseStatusLIMITED
	case EnableUserResponseDtoResponseStatusEXPIRED:
		*s = EnableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = EnableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case EnableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case EnableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyDAY
	case EnableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case EnableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDto = [1]string{
	0: "response",
}

// Decode decodes FindAllApiTokensResponseDto from json.
func (s *FindAllApiTokensResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDto) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKeys")
		e.ArrStart()
		for _, elem := range s.ApiKeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("docs")
		s.Docs.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponse = [2]string{
	0: "apiKeys",
	1: "docs",
}

// Decode decodes FindAllApiTokensResponseDtoResponse from json.
func (s *FindAllApiTokensResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKeys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiKeys = make([]FindAllApiTokensResponseDtoResponseApiKeysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FindAllApiTokensResponseDtoResponseApiKeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ApiKeys = append(s.ApiKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeys\"")
			}
		case "docs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Docs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"docs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponse) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem = [5]string{
	0: "uuid",
	1: "token",
	2: "tokenName",
	3: "createdAt",
	4: "updatedAt",
}

// Decode decodes FindAllApiTokensResponseDtoResponseApiKeysItem from json.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseApiKeysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "tokenName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseApiKeysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseDocs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDocsEnabled")
		e.Bool(s.IsDocsEnabled)
	}
	{
		e.FieldStart("scalarPath")
		s.ScalarPath.Encode(e)
	}
	{
		e.FieldStart("swaggerPath")
		s.SwaggerPath.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs = [3]string{
	0: "isDocsEnabled",
	1: "scalarPath",
	2: "swaggerPath",
}

// Decode decodes FindAllApiTokensResponseDtoResponseDocs from json.
func (s *FindAllApiTokensResponseDtoResponseDocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseDocs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDocsEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDocsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDocsEnabled\"")
			}
		case "scalarPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ScalarPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scalarPath\"")
			}
		case "swaggerPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SwaggerPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swaggerPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseDocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllHostsResponseDto from json.
func (s *GetAllHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDto) {
					name = jsonFieldsNameOfGetAllHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfGetAllHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes GetAllHostsResponseDtoResponseItem from json.
func (s *GetAllHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes GetAllHostsResponseDtoResponseItemInbound from json.
func (s *GetAllHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllHostsResponseDtoResponseItemSecurityLayer(v) {
	case GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case GetAllHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerTLS
	case GetAllHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllInboundsResponseDto from json.
func (s *GetAllInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDto) {
					name = jsonFieldsNameOfGetAllInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDtoResponse = [2]string{
	0: "total",
	1: "inbounds",
}

// Decode decodes GetAllInboundsResponseDtoResponse from json.
func (s *GetAllInboundsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]GetAllInboundsResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllInboundsResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllInboundsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetAllInboundsResponseDtoResponseInboundsItem from json.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllNodesResponseDto from json.
func (s *GetAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllNodesResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDto) {
					name = jsonFieldsNameOfGetAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes GetAllNodesResponseDtoResponseItem from json.
func (s *GetAllNodesResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes GetAllNodesResponseDtoResponseItemConfigProfile from json.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem from json.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetAllNodesResponseDtoResponseItemProvider from json.
func (s *GetAllNodesResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllSubscriptionsResponseDto from json.
func (s *GetAllSubscriptionsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDto) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscriptions")
		e.ArrStart()
		for _, elem := range s.Subscriptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse = [2]string{
	0: "subscriptions",
	1: "total",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponse from json.
func (s *GetAllSubscriptionsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscriptions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Subscriptions = make([]GetAllSubscriptionsResponseDtoResponseSubscriptionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subscriptions = append(s.Subscriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItem from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllTagsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllTagsResponseDto from json.
func (s *GetAllTagsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDto) {
					name = jsonFieldsNameOfGetAllTagsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllTagsResponseDtoResponse = [1]string{
	0: "tags",
}

// Decode decodes GetAllTagsResponseDtoResponse from json.
func (s *GetAllTagsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllTagsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllUsersResponseDto from json.
func (s *GetAllUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDto) {
					name = jsonFieldsNameOfGetAllUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponse = [2]string{
	0: "users",
	1: "total",
}

// Decode decodes GetAllUsersResponseDtoResponse from json.
func (s *GetAllUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]UserDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetBandwidthStatsResponseDto from json.
func (s *GetBandwidthStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDto) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bandwidthLastTwoDays")
		s.BandwidthLastTwoDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLastSevenDays")
		s.BandwidthLastSevenDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLast30Days")
		s.BandwidthLast30Days.Encode(e)
	}
	{
		e.FieldStart("bandwidthCalendarMonth")
		s.BandwidthCalendarMonth.Encode(e)
	}
	{
		e.FieldStart("bandwidthCurrentYear")
		s.BandwidthCurrentYear.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse = [5]string{
	0: "bandwidthLastTwoDays",
	1: "bandwidthLastSevenDays",
	2: "bandwidthLast30Days",
	3: "bandwidthCalendarMonth",
	4: "bandwidthCurrentYear",
}

// Decode decodes GetBandwidthStatsResponseDtoResponse from json.
func (s *GetBandwidthStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bandwidthLastTwoDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BandwidthLastTwoDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastTwoDays\"")
			}
		case "bandwidthLastSevenDays":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BandwidthLastSevenDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastSevenDays\"")
			}
		case "bandwidthLast30Days":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.BandwidthLast30Days.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLast30Days\"")
			}
		case "bandwidthCalendarMonth":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.BandwidthCalendarMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCalendarMonth\"")
			}
		case "bandwidthCurrentYear":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BandwidthCurrentYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCurrentYear\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLast30Days from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetConfigProfileByUuidResponseDto from json.
func (s *GetConfigProfileByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDto) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponse from json.
func (s *GetConfigProfileByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetConfigProfileByUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfileByUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]GetConfigProfileByUuidResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfileByUuidResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponseInboundsItem from json.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponseNodesItem from json.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetConfigProfilesResponseDto from json.
func (s *GetConfigProfilesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDto) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("configProfiles")
		e.ArrStart()
		for _, elem := range s.ConfigProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponse = [2]string{
	0: "total",
	1: "configProfiles",
}

// Decode decodes GetConfigProfilesResponseDtoResponse from json.
func (s *GetConfigProfilesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "configProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ConfigProfiles = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConfigProfiles = append(s.ConfigProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponse) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInboundsByProfileUuidResponseDto from json.
func (s *GetInboundsByProfileUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDto) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse = [2]string{
	0: "total",
	1: "inbounds",
}

// Decode decodes GetInboundsByProfileUuidResponseDtoResponse from json.
func (s *GetInboundsByProfileUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]GetInboundsByProfileUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInboundsByProfileUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetInboundsByProfileUuidResponseDtoResponseInboundsItem from json.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDto from json.
func (s *GetInfraBillingHistoryRecordsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponse from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraBillingNodesResponseDto from json.
func (s *GetInfraBillingNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDto) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponse from json.
func (s *GetInfraBillingNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]GetInfraBillingNodesResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingNodesResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem from json.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItem from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseStats from json.
func (s *GetInfraBillingNodesResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraProviderByUuidResponseDto from json.
func (s *GetInfraProviderByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDto) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponse from json.
func (s *GetInfraProviderByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]GetInfraProviderByUuidResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProviderByUuidResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponseBillingHistory from json.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponseBillingNodesItem from json.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraProvidersResponseDto from json.
func (s *GetInfraProvidersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDto) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("providers")
		e.ArrStart()
		for _, elem := range s.Providers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponse = [2]string{
	0: "total",
	1: "providers",
}

// Decode decodes GetInfraProvidersResponseDtoResponse from json.
func (s *GetInfraProvidersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "providers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Providers = make([]GetInfraProvidersResponseDtoResponseProvidersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProvidersResponseDtoResponseProvidersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Providers = append(s.Providers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItem from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInternalSquadByUuidResponseDto from json.
func (s *GetInternalSquadByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDto) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponse from json.
func (s *GetInternalSquadByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetInternalSquadByUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadByUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponseInboundsItem from json.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponseInfo from json.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInternalSquadsResponseDto from json.
func (s *GetInternalSquadsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDto) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("internalSquads")
		e.ArrStart()
		for _, elem := range s.InternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponse = [2]string{
	0: "total",
	1: "internalSquads",
}

// Decode decodes GetInternalSquadsResponseDtoResponse from json.
func (s *GetInternalSquadsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "internalSquads":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.InternalSquads = make([]GetInternalSquadsResponseDtoResponseInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadsResponseDtoResponseInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InternalSquads = append(s.InternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponse) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItem from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodeUserUsageByRangeResponseDto from json.
func (s *GetNodeUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodeUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodeUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem = [5]string{
	0: "userUuid",
	1: "username",
	2: "nodeUuid",
	3: "total",
	4: "date",
}

// Decode decodes GetNodeUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesMetricsResponseDto from json.
func (s *GetNodesMetricsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDto) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponse = [1]string{
	0: "nodes",
}

// Decode decodes GetNodesMetricsResponseDtoResponse from json.
func (s *GetNodesMetricsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]GetNodesMetricsResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponse) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		e.Str(s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryEmoji")
		e.Str(s.CountryEmoji)
	}
	{
		e.FieldStart("providerName")
		e.Str(s.ProviderName)
	}
	{
		e.FieldStart("usersOnline")
		e.Float64(s.UsersOnline)
	}
	{
		e.FieldStart("inboundsStats")
		e.ArrStart()
		for _, elem := range s.InboundsStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("outboundsStats")
		e.ArrStart()
		for _, elem := range s.OutboundsStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem = [7]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "countryEmoji",
	3: "providerName",
	4: "usersOnline",
	5: "inboundsStats",
	6: "outboundsStats",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryEmoji":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryEmoji = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryEmoji\"")
			}
		case "providerName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProviderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerName\"")
			}
		case "usersOnline":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsersOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "inboundsStats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.InboundsStats = make([]GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InboundsStats = append(s.InboundsStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsStats\"")
			}
		case "outboundsStats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.OutboundsStats = make([]GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OutboundsStats = append(s.OutboundsStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outboundsStats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("upload")
		e.Str(s.Upload)
	}
	{
		e.FieldStart("download")
		e.Str(s.Download)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem = [3]string{
	0: "tag",
	1: "upload",
	2: "download",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "upload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Upload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload\"")
			}
		case "download":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Download = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("upload")
		e.Str(s.Upload)
	}
	{
		e.FieldStart("download")
		e.Str(s.Download)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem = [3]string{
	0: "tag",
	1: "upload",
	2: "download",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "upload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Upload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload\"")
			}
		case "download":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Download = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesRealtimeUsageResponseDto from json.
func (s *GetNodesRealtimeUsageResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesRealtimeUsageResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesRealtimeUsageResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDto) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("downloadBytes")
		e.Float64(s.DownloadBytes)
	}
	{
		e.FieldStart("uploadBytes")
		e.Float64(s.UploadBytes)
	}
	{
		e.FieldStart("totalBytes")
		e.Float64(s.TotalBytes)
	}
	{
		e.FieldStart("downloadSpeedBps")
		e.Float64(s.DownloadSpeedBps)
	}
	{
		e.FieldStart("uploadSpeedBps")
		e.Float64(s.UploadSpeedBps)
	}
	{
		e.FieldStart("totalSpeedBps")
		e.Float64(s.TotalSpeedBps)
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem = [9]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "countryCode",
	3: "downloadBytes",
	4: "uploadBytes",
	5: "totalBytes",
	6: "downloadSpeedBps",
	7: "uploadSpeedBps",
	8: "totalSpeedBps",
}

// Decode decodes GetNodesRealtimeUsageResponseDtoResponseItem from json.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "downloadBytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.DownloadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadBytes\"")
			}
		case "uploadBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UploadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadBytes\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.TotalBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		case "downloadSpeedBps":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.DownloadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadSpeedBps\"")
			}
		case "uploadSpeedBps":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.UploadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpeedBps\"")
			}
		case "totalSpeedBps":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpeedBps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesStatisticsResponseDto from json.
func (s *GetNodesStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDto) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastSevenDays")
		e.ArrStart()
		for _, elem := range s.LastSevenDays {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse = [1]string{
	0: "lastSevenDays",
}

// Decode decodes GetNodesStatisticsResponseDtoResponse from json.
func (s *GetNodesStatisticsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastSevenDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.LastSevenDays = make([]GetNodesStatisticsResponseDtoResponseLastSevenDaysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LastSevenDays = append(s.LastSevenDays, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSevenDays\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		e.FieldStart("totalBytes")
		e.Str(s.TotalBytes)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem = [3]string{
	0: "nodeName",
	1: "date",
	2: "totalBytes",
}

// Decode decodes GetNodesStatisticsResponseDtoResponseLastSevenDaysItem from json.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesUsageByRangeResponseDto from json.
func (s *GetNodesUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("totalDownload")
		e.Float64(s.TotalDownload)
	}
	{
		e.FieldStart("totalUpload")
		e.Float64(s.TotalUpload)
	}
	{
		e.FieldStart("humanReadableTotal")
		e.Str(s.HumanReadableTotal)
	}
	{
		e.FieldStart("humanReadableTotalDownload")
		e.Str(s.HumanReadableTotalDownload)
	}
	{
		e.FieldStart("humanReadableTotalUpload")
		e.Str(s.HumanReadableTotalUpload)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem = [9]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "total",
	3: "totalDownload",
	4: "totalUpload",
	5: "humanReadableTotal",
	6: "humanReadableTotalDownload",
	7: "humanReadableTotalUpload",
	8: "date",
}

// Decode decodes GetNodesUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "totalDownload":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalDownload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDownload\"")
			}
		case "totalUpload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.TotalUpload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpload\"")
			}
		case "humanReadableTotal":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotal\"")
			}
		case "humanReadableTotalDownload":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalDownload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalDownload\"")
			}
		case "humanReadableTotalUpload":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalUpload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalUpload\"")
			}
		case "date":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneHostResponseDto from json.
func (s *GetOneHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDto) {
					name = jsonFieldsNameOfGetOneHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes GetOneHostResponseDtoResponse from json.
func (s *GetOneHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes GetOneHostResponseDtoResponseInbound from json.
func (s *GetOneHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfGetOneHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (s GetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (s *GetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetOneHostResponseDtoResponseSecurityLayer(v) {
	case GetOneHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = GetOneHostResponseDtoResponseSecurityLayerDEFAULT
	case GetOneHostResponseDtoResponseSecurityLayerTLS:
		*s = GetOneHostResponseDtoResponseSecurityLayerTLS
	case GetOneHostResponseDtoResponseSecurityLayerNONE:
		*s = GetOneHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = GetOneHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneNodeResponseDto from json.
func (s *GetOneNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDto) {
					name = jsonFieldsNameOfGetOneNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes GetOneNodeResponseDtoResponse from json.
func (s *GetOneNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes GetOneNodeResponseDtoResponseConfigProfile from json.
func (s *GetOneNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetOneNodeResponseDtoResponseProvider from json.
func (s *GetOneNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetPubKeyResponseDto from json.
func (s *GetPubKeyResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDto) {
					name = jsonFieldsNameOfGetPubKeyResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pubKey")
		e.Str(s.PubKey)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDtoResponse = [1]string{
	0: "pubKey",
}

// Decode decodes GetPubKeyResponseDtoResponse from json.
func (s *GetPubKeyResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pubKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PubKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pubKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDtoResponse) {
					name = jsonFieldsNameOfGetPubKeyResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDto from json.
func (s *GetRawSubscriptionByShortUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("rawHosts")
		e.ArrStart()
		for _, elem := range s.RawHosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("headers")
		s.Headers.Encode(e)
	}
	{
		e.FieldStart("isHwidLimited")
		e.Bool(s.IsHwidLimited)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse = [5]string{
	0: "user",
	1: "subscriptionUrl",
	2: "rawHosts",
	3: "headers",
	4: "isHwidLimited",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponse from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "rawHosts":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.RawHosts = make([]GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RawHosts = append(s.RawHosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawHosts\"")
			}
		case "headers":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "isHwidLimited":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsHwidLimited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHwidLimited\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseHeaders from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			e.FieldStart("publicKey")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.ShortId.Set {
			e.FieldStart("shortId")
			s.ShortId.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.SpiderX.Set {
			e.FieldStart("spiderX")
			s.SpiderX.Encode(e)
		}
	}
	{
		if s.TLS.Set {
			e.FieldStart("tls")
			s.TLS.Encode(e)
		}
	}
	{
		if s.HeaderType.Set {
			e.FieldStart("headerType")
			s.HeaderType.Encode(e)
		}
	}
	{
		if s.AdditionalParams.Set {
			e.FieldStart("additionalParams")
			s.AdditionalParams.Encode(e)
		}
	}
	{
		if s.XHttpExtraParams.Set {
			e.FieldStart("xHttpExtraParams")
			s.XHttpExtraParams.Encode(e)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
	{
		if s.Flow.Set {
			e.FieldStart("flow")
			s.Flow.Encode(e)
		}
	}
	{
		if s.ProtocolOptions.Set {
			e.FieldStart("protocolOptions")
			s.ProtocolOptions.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem = [21]string{
	0:  "address",
	1:  "alpn",
	2:  "fingerprint",
	3:  "host",
	4:  "network",
	5:  "password",
	6:  "path",
	7:  "publicKey",
	8:  "port",
	9:  "protocol",
	10: "remark",
	11: "shortId",
	12: "sni",
	13: "spiderX",
	14: "tls",
	15: "headerType",
	16: "additionalParams",
	17: "xHttpExtraParams",
	18: "serverDescription",
	19: "flow",
	20: "protocolOptions",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "publicKey":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "shortId":
			if err := func() error {
				s.ShortId.Reset()
				if err := s.ShortId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortId\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "spiderX":
			if err := func() error {
				s.SpiderX.Reset()
				if err := s.SpiderX.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spiderX\"")
			}
		case "tls":
			if err := func() error {
				s.TLS.Reset()
				if err := s.TLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls\"")
			}
		case "headerType":
			if err := func() error {
				s.HeaderType.Reset()
				if err := s.HeaderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerType\"")
			}
		case "additionalParams":
			if err := func() error {
				s.AdditionalParams.Reset()
				if err := s.AdditionalParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalParams\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				s.XHttpExtraParams.Reset()
				if err := s.XHttpExtraParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "flow":
			if err := func() error {
				s.Flow.Reset()
				if err := s.Flow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flow\"")
			}
		case "protocolOptions":
			if err := func() error {
				s.ProtocolOptions.Reset()
				if err := s.ProtocolOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocolOptions\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) encodeFields(e *jx.Encoder) {
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.HeartbeatPeriod.Set {
			e.FieldStart("heartbeatPeriod")
			s.HeartbeatPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams = [2]string{
	0: "mode",
	1: "heartbeatPeriod",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "heartbeatPeriod":
			if err := func() error {
				s.HeartbeatPeriod.Reset()
				if err := s.HeartbeatPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heartbeatPeriod\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ss.Set {
			e.FieldStart("ss")
			s.Ss.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions = [1]string{
	0: "ss",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ss":
			if err := func() error {
				s.Ss.Reset()
				if err := s.Ss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) encodeFields(e *jx.Encoder) {
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs = [1]string{
	0: "method",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams = [0]string{}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUser from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus as json.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus(v) {
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusACTIVE:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusACTIVE
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusDISABLED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusDISABLED
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusLIMITED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusLIMITED
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetRemnawaveHealthResponseDto from json.
func (s *GetRemnawaveHealthResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDto) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pm2Stats")
		e.ArrStart()
		for _, elem := range s.Pm2Stats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse = [1]string{
	0: "pm2Stats",
}

// Decode decodes GetRemnawaveHealthResponseDtoResponse from json.
func (s *GetRemnawaveHealthResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pm2Stats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Pm2Stats = make([]GetRemnawaveHealthResponseDtoResponsePm2StatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetRemnawaveHealthResponseDtoResponsePm2StatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pm2Stats = append(s.Pm2Stats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pm2Stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("memory")
		e.Str(s.Memory)
	}
	{
		e.FieldStart("cpu")
		e.Str(s.CPU)
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem = [3]string{
	0: "name",
	1: "memory",
	2: "cpu",
}

// Decode decodes GetRemnawaveHealthResponseDtoResponsePm2StatsItem from json.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDtoResponsePm2StatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "memory":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Memory = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "cpu":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CPU = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDtoResponsePm2StatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetStatsResponseDto from json.
func (s *GetStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDto) {
					name = jsonFieldsNameOfGetStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cpu")
		s.CPU.Encode(e)
	}
	{
		e.FieldStart("memory")
		s.Memory.Encode(e)
	}
	{
		e.FieldStart("uptime")
		e.Float64(s.Uptime)
	}
	{
		e.FieldStart("timestamp")
		e.Float64(s.Timestamp)
	}
	{
		e.FieldStart("users")
		s.Users.Encode(e)
	}
	{
		e.FieldStart("onlineStats")
		s.OnlineStats.Encode(e)
	}
	{
		e.FieldStart("nodes")
		s.Nodes.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponse = [7]string{
	0: "cpu",
	1: "memory",
	2: "uptime",
	3: "timestamp",
	4: "users",
	5: "onlineStats",
	6: "nodes",
}

// Decode decodes GetStatsResponseDtoResponse from json.
func (s *GetStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "uptime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Uptime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Timestamp = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Users.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "onlineStats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.OnlineStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineStats\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Nodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseCPU) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cores")
		e.Float64(s.Cores)
	}
	{
		e.FieldStart("physicalCores")
		e.Float64(s.PhysicalCores)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseCPU = [2]string{
	0: "cores",
	1: "physicalCores",
}

// Decode decodes GetStatsResponseDtoResponseCPU from json.
func (s *GetStatsResponseDtoResponseCPU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseCPU to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cores":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Cores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cores\"")
			}
		case "physicalCores":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.PhysicalCores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalCores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseCPU")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseCPU) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseCPU[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseMemory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("free")
		e.Float64(s.Free)
	}
	{
		e.FieldStart("used")
		e.Float64(s.Used)
	}
	{
		e.FieldStart("active")
		e.Float64(s.Active)
	}
	{
		e.FieldStart("available")
		e.Float64(s.Available)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseMemory = [5]string{
	0: "total",
	1: "free",
	2: "used",
	3: "active",
	4: "available",
}

// Decode decodes GetStatsResponseDtoResponseMemory from json.
func (s *GetStatsResponseDtoResponseMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseMemory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "free":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Free = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free\"")
			}
		case "used":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Used = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Active = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "available":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Available = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseMemory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseMemory) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseMemory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseNodes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalOnline")
		e.Float64(s.TotalOnline)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseNodes = [1]string{
	0: "totalOnline",
}

// Decode decodes GetStatsResponseDtoResponseNodes from json.
func (s *GetStatsResponseDtoResponseNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseNodes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalOnline":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOnline\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseNodes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseNodes) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseNodes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseOnlineStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastDay")
		e.Float64(s.LastDay)
	}
	{
		e.FieldStart("lastWeek")
		e.Float64(s.LastWeek)
	}
	{
		e.FieldStart("neverOnline")
		e.Float64(s.NeverOnline)
	}
	{
		e.FieldStart("onlineNow")
		e.Float64(s.OnlineNow)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats = [4]string{
	0: "lastDay",
	1: "lastWeek",
	2: "neverOnline",
	3: "onlineNow",
}

// Decode decodes GetStatsResponseDtoResponseOnlineStats from json.
func (s *GetStatsResponseDtoResponseOnlineStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseOnlineStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastDay":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.LastDay = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastDay\"")
			}
		case "lastWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.LastWeek = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastWeek\"")
			}
		case "neverOnline":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.NeverOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neverOnline\"")
			}
		case "onlineNow":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.OnlineNow = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineNow\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseOnlineStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseUsers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("statusCounts")
		s.StatusCounts.Encode(e)
	}
	{
		e.FieldStart("totalUsers")
		e.Float64(s.TotalUsers)
	}
	{
		e.FieldStart("totalTrafficBytes")
		e.Str(s.TotalTrafficBytes)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseUsers = [3]string{
	0: "statusCounts",
	1: "totalUsers",
	2: "totalTrafficBytes",
}

// Decode decodes GetStatsResponseDtoResponseUsers from json.
func (s *GetStatsResponseDtoResponseUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.StatusCounts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCounts\"")
			}
		case "totalUsers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalUsers = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUsers\"")
			}
		case "totalTrafficBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalTrafficBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalTrafficBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseUsers) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseUsers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes GetStatsResponseDtoResponseUsersStatusCounts from json.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsersStatusCounts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsersStatusCounts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetStatusResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetStatusResponseDto from json.
func (s *GetStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDto) {
					name = jsonFieldsNameOfGetStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isLoginAllowed")
		e.Bool(s.IsLoginAllowed)
	}
	{
		e.FieldStart("isRegisterAllowed")
		e.Bool(s.IsRegisterAllowed)
	}
	{
		e.FieldStart("tgAuth")
		s.TgAuth.Encode(e)
	}
	{
		e.FieldStart("oauth2")
		s.OAuth2.Encode(e)
	}
}

var jsonFieldsNameOfGetStatusResponseDtoResponse = [4]string{
	0: "isLoginAllowed",
	1: "isRegisterAllowed",
	2: "tgAuth",
	3: "oauth2",
}

// Decode decodes GetStatusResponseDtoResponse from json.
func (s *GetStatusResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isLoginAllowed":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsLoginAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isLoginAllowed\"")
			}
		case "isRegisterAllowed":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsRegisterAllowed = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isRegisterAllowed\"")
			}
		case "tgAuth":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TgAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgAuth\"")
			}
		case "oauth2":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OAuth2.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDtoResponse) {
					name = jsonFieldsNameOfGetStatusResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDtoResponseOAuth2) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDtoResponseOAuth2) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providers")
		s.Providers.Encode(e)
	}
}

var jsonFieldsNameOfGetStatusResponseDtoResponseOAuth2 = [1]string{
	0: "providers",
}

// Decode decodes GetStatusResponseDtoResponseOAuth2 from json.
func (s *GetStatusResponseDtoResponseOAuth2) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponseOAuth2 to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providers":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Providers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponseOAuth2")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDtoResponseOAuth2) {
					name = jsonFieldsNameOfGetStatusResponseDtoResponseOAuth2[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDtoResponseOAuth2) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponseOAuth2) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetStatusResponseDtoResponseOAuth2Providers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetStatusResponseDtoResponseOAuth2Providers) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Bool(elem)
	}
}

// Decode decodes GetStatusResponseDtoResponseOAuth2Providers from json.
func (s *GetStatusResponseDtoResponseOAuth2Providers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponseOAuth2Providers to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem bool
		if err := func() error {
			v, err := d.Bool()
			elem = bool(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponseOAuth2Providers")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetStatusResponseDtoResponseOAuth2Providers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponseOAuth2Providers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatusResponseDtoResponseTgAuth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatusResponseDtoResponseTgAuth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("botId")
		e.Float64(s.BotId)
	}
}

var jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth = [1]string{
	0: "botId",
}

// Decode decodes GetStatusResponseDtoResponseTgAuth from json.
func (s *GetStatusResponseDtoResponseTgAuth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatusResponseDtoResponseTgAuth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "botId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.BotId = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"botId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatusResponseDtoResponseTgAuth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth) {
					name = jsonFieldsNameOfGetStatusResponseDtoResponseTgAuth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatusResponseDtoResponseTgAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatusResponseDtoResponseTgAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionByUsernameResponseDto from json.
func (s *GetSubscriptionByUsernameResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponse from json.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUser from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionInfoResponseDto from json.
func (s *GetSubscriptionInfoResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse = [6]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
	5: "happ",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponse from json.
func (s *GetSubscriptionInfoResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "happ":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseHapp from json.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUser from json.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionSettingsResponseDto from json.
func (s *GetSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("randomizeHosts")
		e.Bool(s.RandomizeHosts)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse = [17]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
	15: "createdAt",
	16: "updatedAt",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponse from json.
func (s *GetSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.RandomizeHosts = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetTemplateResponseDto from json.
func (s *GetTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDto) {
					name = jsonFieldsNameOfGetTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDtoResponse = [4]string{
	0: "uuid",
	1: "templateType",
	2: "templateJson",
	3: "encodedTemplateYaml",
}

// Decode decodes GetTemplateResponseDtoResponse from json.
func (s *GetTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfGetTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTemplateResponseDtoResponseTemplateType as json.
func (s GetTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetTemplateResponseDtoResponseTemplateType from json.
func (s *GetTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetTemplateResponseDtoResponseTemplateType(v) {
	case GetTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeSTASH
	case GetTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = GetTemplateResponseDtoResponseTemplateTypeSINGBOX
	case GetTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY:
		*s = GetTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY
	case GetTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = GetTemplateResponseDtoResponseTemplateTypeMIHOMO
	case GetTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = GetTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case GetTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeCLASH
	default:
		*s = GetTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserAccessibleNodesResponseDto from json.
func (s *GetUserAccessibleNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDto) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("activeNodes")
		e.ArrStart()
		for _, elem := range s.ActiveNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse = [2]string{
	0: "userUuid",
	1: "activeNodes",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponse from json.
func (s *GetUserAccessibleNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "activeNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveNodes = make([]GetUserAccessibleNodesResponseDtoResponseActiveNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveNodes = append(s.ActiveNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileName")
		e.Str(s.ConfigProfileName)
	}
	{
		e.FieldStart("activeSquads")
		e.ArrStart()
		for _, elem := range s.ActiveSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem = [6]string{
	0: "uuid",
	1: "nodeName",
	2: "countryCode",
	3: "configProfileUuid",
	4: "configProfileName",
	5: "activeSquads",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponseActiveNodesItem from json.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ConfigProfileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileName\"")
			}
		case "activeSquads":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.ActiveSquads = make([]GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveSquads = append(s.ActiveSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("squadName")
		e.Str(s.SquadName)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem = [2]string{
	0: "squadName",
	1: "activeInbounds",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem from json.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "squadName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SquadName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"squadName\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByEmailResponseDto from json.
func (s *GetUserByEmailResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByEmailResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByEmailResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDto) {
					name = jsonFieldsNameOfGetUserByEmailResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes GetUserByEmailResponseDtoResponseItem from json.
func (s *GetUserByEmailResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem from json.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemHapp from json.
func (s *GetUserByEmailResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemStatus as json.
func (s GetUserByEmailResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemStatus from json.
func (s *GetUserByEmailResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByEmailResponseDtoResponseItemStatus(v) {
	case GetUserByEmailResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByEmailResponseDtoResponseItemStatusACTIVE
	case GetUserByEmailResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByEmailResponseDtoResponseItemStatusDISABLED
	case GetUserByEmailResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByEmailResponseDtoResponseItemStatusLIMITED
	case GetUserByEmailResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByEmailResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByEmailResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByEmailResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByTagResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByTagResponseDto from json.
func (s *GetUserByTagResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByTagResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDto) {
					name = jsonFieldsNameOfGetUserByTagResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItem = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes GetUserByTagResponseDtoResponseItem from json.
func (s *GetUserByTagResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem from json.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByTagResponseDtoResponseItemHapp from json.
func (s *GetUserByTagResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (s GetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (s *GetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemStatus(v) {
	case GetUserByTagResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByTagResponseDtoResponseItemStatusACTIVE
	case GetUserByTagResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByTagResponseDtoResponseItemStatusDISABLED
	case GetUserByTagResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByTagResponseDtoResponseItemStatusLIMITED
	case GetUserByTagResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByTagResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByTagResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByUsernameResponseDto from json.
func (s *GetUserByUsernameResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDto) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponse = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes GetUserByUsernameResponseDtoResponse from json.
func (s *GetUserByUsernameResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem from json.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByUsernameResponseDtoResponseHapp from json.
func (s *GetUserByUsernameResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes GetUserByUsernameResponseDtoResponseLastConnectedNode from json.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseStatus as json.
func (s GetUserByUsernameResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUsernameResponseDtoResponseStatus from json.
func (s *GetUserByUsernameResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUsernameResponseDtoResponseStatus(v) {
	case GetUserByUsernameResponseDtoResponseStatusACTIVE:
		*s = GetUserByUsernameResponseDtoResponseStatusACTIVE
	case GetUserByUsernameResponseDtoResponseStatusDISABLED:
		*s = GetUserByUsernameResponseDtoResponseStatusDISABLED
	case GetUserByUsernameResponseDtoResponseStatusLIMITED:
		*s = GetUserByUsernameResponseDtoResponseStatusLIMITED
	case GetUserByUsernameResponseDtoResponseStatusEXPIRED:
		*s = GetUserByUsernameResponseDtoResponseStatusEXPIRED
	default:
		*s = GetUserByUsernameResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUsernameResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy as json.
func (s GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy from json.
func (s *GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUsernameResponseDtoResponseTrafficLimitStrategy(v) {
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyNORESET
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyDAY:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyDAY
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyWEEK
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserHwidDevicesResponseDto from json.
func (s *GetUserHwidDevicesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDto) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes GetUserHwidDevicesResponseDtoResponse from json.
func (s *GetUserHwidDevicesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]GetUserHwidDevicesResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserHwidDevicesResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetUserHwidDevicesResponseDtoResponseDevicesItem from json.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserUsageByRangeResponseDto from json.
func (s *GetUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem = [5]string{
	0: "userUuid",
	1: "nodeUuid",
	2: "nodeName",
	3: "total",
	4: "date",
}

// Decode decodes GetUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDeleteHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerDeleteHostsInternalServerError from json.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDeleteHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDeleteHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDisableHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerDisableHostsInternalServerError from json.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDisableHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDisableHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerEnableHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerEnableHostsInternalServerError from json.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerEnableHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerEnableHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetInboundToHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerSetInboundToHostsInternalServerError from json.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetInboundToHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetInboundToHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetPortToHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerSetPortToHostsInternalServerError from json.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetPortToHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetPortToHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerCreateHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerCreateHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerCreateHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerCreateHostInternalServerError from json.
func (s *HostsControllerCreateHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerCreateHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerCreateHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerCreateHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerCreateHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerDeleteHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerDeleteHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerDeleteHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerDeleteHostInternalServerError from json.
func (s *HostsControllerDeleteHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerDeleteHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerDeleteHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerDeleteHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerDeleteHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerGetAllHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerGetAllHostsInternalServerError from json.
func (s *HostsControllerGetAllHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetOneHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetOneHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerGetOneHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerGetOneHostInternalServerError from json.
func (s *HostsControllerGetOneHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetOneHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetOneHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetOneHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetOneHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerReorderHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerReorderHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerReorderHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerReorderHostsInternalServerError from json.
func (s *HostsControllerReorderHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerReorderHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerReorderHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerReorderHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerReorderHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerUpdateHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerUpdateHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerUpdateHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerUpdateHostInternalServerError from json.
func (s *HostsControllerUpdateHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerUpdateHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerUpdateHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerUpdateHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerUpdateHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerCreateUserHwidDeviceInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError from json.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError from json.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetUserHwidDevicesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerGetUserHwidDevicesInternalServerError from json.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetUserHwidDevicesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetUserHwidDevicesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError from json.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraBillingNodeInternalServerError from json.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraProviderInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraProviderInternalServerError from json.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraProviderInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraProviderInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraProviderByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraProviderByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraProviderByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraProviderByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetBillingNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetBillingNodesInternalServerError from json.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetBillingNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetBillingNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError from json.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProviderByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraProviderByUuidInternalServerError from json.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProviderByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProviderByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProvidersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraProvidersInternalServerError from json.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProvidersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProvidersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraBillingNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerUpdateInfraBillingNodeInternalServerError from json.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraBillingNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraBillingNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraProviderInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerUpdateInfraProviderInternalServerError from json.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraProviderInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraProviderInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerAddUsersToInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerAddUsersToInternalSquadInternalServerError from json.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerAddUsersToInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerAddUsersToInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerCreateInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerCreateInternalSquadInternalServerError from json.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerCreateInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerCreateInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerDeleteInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerDeleteInternalSquadInternalServerError from json.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerDeleteInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerDeleteInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerGetInternalSquadByUuidInternalServerError from json.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerGetInternalSquadsInternalServerError from json.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerRemoveUsersFromInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError from json.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerUpdateInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerUpdateInternalSquadInternalServerError from json.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerUpdateInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerUpdateInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeygenControllerGenerateKeyInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeygenControllerGenerateKeyInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes KeygenControllerGenerateKeyInternalServerError from json.
func (s *KeygenControllerGenerateKeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeygenControllerGenerateKeyInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeygenControllerGenerateKeyInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes LoginRequestDto from json.
func (s *LoginRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginRequestDto) {
					name = jsonFieldsNameOfLoginRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfLoginResponseDto = [1]string{
	0: "response",
}

// Decode decodes LoginResponseDto from json.
func (s *LoginResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponseDto) {
					name = jsonFieldsNameOfLoginResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfLoginResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes LoginResponseDtoResponse from json.
func (s *LoginResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginResponseDtoResponse) {
					name = jsonFieldsNameOfLoginResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNodeResponseDtoResponseProvider as json.
func (o NilCreateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateNodeResponseDtoResponseProvider from json.
func (o *NilCreateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DisableNodeResponseDtoResponseProvider as json.
func (o NilDisableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisableNodeResponseDtoResponseProvider from json.
func (o *NilDisableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDisableNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DisableNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDisableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDisableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseLastConnectedNode as json.
func (o NilDisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilDisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DisableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableNodeResponseDtoResponseProvider as json.
func (o NilEnableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnableNodeResponseDtoResponseProvider from json.
func (o *NilEnableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEnableNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnableNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEnableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEnableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseLastConnectedNode as json.
func (o NilEnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilEnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o NilFloat64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *NilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllNodesResponseDtoResponseItemProvider as json.
func (o NilGetAllNodesResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetAllNodesResponseDtoResponseItemProvider from json.
func (o *NilGetAllNodesResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetAllNodesResponseDtoResponseItemProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetAllNodesResponseDtoResponseItemProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetAllNodesResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetAllNodesResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneNodeResponseDtoResponseProvider as json.
func (o NilGetOneNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetOneNodeResponseDtoResponseProvider from json.
func (o *NilGetOneNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetOneNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetOneNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetOneNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetOneNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetStatusResponseDtoResponseTgAuth as json.
func (o NilGetStatusResponseDtoResponseTgAuth) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetStatusResponseDtoResponseTgAuth from json.
func (o *NilGetStatusResponseDtoResponseTgAuth) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetStatusResponseDtoResponseTgAuth to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetStatusResponseDtoResponseTgAuth
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetStatusResponseDtoResponseTgAuth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetStatusResponseDtoResponseTgAuth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByEmailResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByEmailResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByEmailResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByTagResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseLastConnectedNode as json.
func (o NilGetUserByUsernameResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByUsernameResponseDtoResponseLastConnectedNode from json.
func (o *NilGetUserByUsernameResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByUsernameResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByUsernameResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByUsernameResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByUsernameResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReorderNodeResponseDtoResponseItemProvider as json.
func (o NilReorderNodeResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReorderNodeResponseDtoResponseItemProvider from json.
func (o *NilReorderNodeResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReorderNodeResponseDtoResponseItemProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReorderNodeResponseDtoResponseItemProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReorderNodeResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReorderNodeResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseLastConnectedNode as json.
func (o NilResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (o *NilResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ResetUserTrafficResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode as json.
func (o NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (o *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RevokeUserSubscriptionResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o NilURI) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o NilUUID) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *NilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNodeResponseDtoResponseProvider as json.
func (o NilUpdateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNodeResponseDtoResponseProvider from json.
func (o *NilUpdateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoLastConnectedNode as json.
func (o NilUserDtoLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UserDtoLastConnectedNode from json.
func (o *NilUserDtoLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUserDtoLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UserDtoLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUserDtoLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUserDtoLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerCreateNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerCreateNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerCreateNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerCreateNodeInternalServerError from json.
func (s *NodesControllerCreateNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerCreateNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerCreateNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerCreateNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerCreateNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDeleteNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDeleteNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerDeleteNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerDeleteNodeInternalServerError from json.
func (s *NodesControllerDeleteNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDeleteNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDeleteNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDeleteNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDeleteNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDisableNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDisableNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerDisableNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerDisableNodeInternalServerError from json.
func (s *NodesControllerDisableNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDisableNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDisableNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDisableNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDisableNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerEnableNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerEnableNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerEnableNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerEnableNodeInternalServerError from json.
func (s *NodesControllerEnableNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerEnableNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerEnableNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerEnableNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerEnableNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetAllNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetAllNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerGetAllNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerGetAllNodesInternalServerError from json.
func (s *NodesControllerGetAllNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetAllNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetAllNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetAllNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetAllNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetOneNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetOneNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerGetOneNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerGetOneNodeInternalServerError from json.
func (s *NodesControllerGetOneNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetOneNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetOneNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetOneNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetOneNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerReorderNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerReorderNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerReorderNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerReorderNodesInternalServerError from json.
func (s *NodesControllerReorderNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerReorderNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerReorderNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerReorderNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerReorderNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartAllNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartAllNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerRestartAllNodesInternalServerError from json.
func (s *NodesControllerRestartAllNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartAllNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartAllNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerRestartNodeInternalServerError from json.
func (s *NodesControllerRestartNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerUpdateNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerUpdateNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerUpdateNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerUpdateNodeInternalServerError from json.
func (s *NodesControllerUpdateNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerUpdateNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerUpdateNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerUpdateNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerUpdateNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError from json.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError from json.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError from json.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2AuthorizeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2AuthorizeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfOAuth2AuthorizeRequestDto = [1]string{
	0: "provider",
}

// Decode decodes OAuth2AuthorizeRequestDto from json.
func (s *OAuth2AuthorizeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2AuthorizeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2AuthorizeRequestDto) {
					name = jsonFieldsNameOfOAuth2AuthorizeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2AuthorizeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2AuthorizeRequestDtoProvider as json.
func (s OAuth2AuthorizeRequestDtoProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2AuthorizeRequestDtoProvider from json.
func (s *OAuth2AuthorizeRequestDtoProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeRequestDtoProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2AuthorizeRequestDtoProvider(v) {
	case OAuth2AuthorizeRequestDtoProviderGithub:
		*s = OAuth2AuthorizeRequestDtoProviderGithub
	case OAuth2AuthorizeRequestDtoProviderPocketid:
		*s = OAuth2AuthorizeRequestDtoProviderPocketid
	case OAuth2AuthorizeRequestDtoProviderYandex:
		*s = OAuth2AuthorizeRequestDtoProviderYandex
	default:
		*s = OAuth2AuthorizeRequestDtoProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2AuthorizeRequestDtoProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeRequestDtoProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2AuthorizeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2AuthorizeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfOAuth2AuthorizeResponseDto = [1]string{
	0: "response",
}

// Decode decodes OAuth2AuthorizeResponseDto from json.
func (s *OAuth2AuthorizeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2AuthorizeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2AuthorizeResponseDto) {
					name = jsonFieldsNameOfOAuth2AuthorizeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2AuthorizeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2AuthorizeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2AuthorizeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("authorizationUrl")
		s.AuthorizationUrl.Encode(e)
	}
}

var jsonFieldsNameOfOAuth2AuthorizeResponseDtoResponse = [1]string{
	0: "authorizationUrl",
}

// Decode decodes OAuth2AuthorizeResponseDtoResponse from json.
func (s *OAuth2AuthorizeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorizationUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AuthorizationUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2AuthorizeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2AuthorizeResponseDtoResponse) {
					name = jsonFieldsNameOfOAuth2AuthorizeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2AuthorizeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2CallbackRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2CallbackRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
}

var jsonFieldsNameOfOAuth2CallbackRequestDto = [3]string{
	0: "provider",
	1: "code",
	2: "state",
}

// Decode decodes OAuth2CallbackRequestDto from json.
func (s *OAuth2CallbackRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2CallbackRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2CallbackRequestDto) {
					name = jsonFieldsNameOfOAuth2CallbackRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2CallbackRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2CallbackRequestDtoProvider as json.
func (s OAuth2CallbackRequestDtoProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2CallbackRequestDtoProvider from json.
func (s *OAuth2CallbackRequestDtoProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackRequestDtoProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2CallbackRequestDtoProvider(v) {
	case OAuth2CallbackRequestDtoProviderGithub:
		*s = OAuth2CallbackRequestDtoProviderGithub
	case OAuth2CallbackRequestDtoProviderPocketid:
		*s = OAuth2CallbackRequestDtoProviderPocketid
	case OAuth2CallbackRequestDtoProviderYandex:
		*s = OAuth2CallbackRequestDtoProviderYandex
	default:
		*s = OAuth2CallbackRequestDtoProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2CallbackRequestDtoProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackRequestDtoProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2CallbackResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2CallbackResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfOAuth2CallbackResponseDto = [1]string{
	0: "response",
}

// Decode decodes OAuth2CallbackResponseDto from json.
func (s *OAuth2CallbackResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2CallbackResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2CallbackResponseDto) {
					name = jsonFieldsNameOfOAuth2CallbackResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2CallbackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2CallbackResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2CallbackResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfOAuth2CallbackResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes OAuth2CallbackResponseDtoResponse from json.
func (s *OAuth2CallbackResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2CallbackResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2CallbackResponseDtoResponse) {
					name = jsonFieldsNameOfOAuth2CallbackResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2CallbackResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (o OptBulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (o *OptBulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (o OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (o *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (o OptBulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (o *OptBulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (o OptBulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (o OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (o OptCreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (o *OptCreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (o OptCreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (o *OptCreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (o OptCreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (o *OptCreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoTrafficLimitStrategy as json.
func (o OptCreateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserRequestDtoTrafficLimitStrategy from json.
func (o *OptCreateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (o OptDisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (o *OptDisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptDisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptDisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (o OptEnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (o *OptEnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptEnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptEnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptGetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptGetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (o OptGetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (o *OptGetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams to nil")
	}
	o.Set = true
	o.Value = new(GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemStatus as json.
func (o OptGetUserByEmailResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemStatus from json.
func (o *OptGetUserByEmailResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByEmailResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByEmailResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByEmailResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (o OptGetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (o *OptGetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseStatus as json.
func (o OptGetUserByUsernameResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUsernameResponseDtoResponseStatus from json.
func (o *OptGetUserByUsernameResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUsernameResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUsernameResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUsernameResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy as json.
func (o OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (o OptNilCreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (o *OptNilCreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (o OptNilCreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (o *OptNilCreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (o OptNilUpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (o *OptNilUpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (o OptNilUpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (o *OptNilUpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (o OptResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (o *OptResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (o OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoInbound as json.
func (o OptUpdateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateHostRequestDtoInbound from json.
func (o *OptUpdateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostRequestDtoInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (o OptUpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (o *OptUpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (o OptUpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (o *OptUpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNodeRequestDtoConfigProfile as json.
func (o OptUpdateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNodeRequestDtoConfigProfile from json.
func (o *OptUpdateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNodeRequestDtoConfigProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders as json.
func (o OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (o *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	o.Set = true
	o.Value = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (o OptUpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (o *OptUpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (o OptUpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (o *OptUpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoStatus as json.
func (o OptUserDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserDtoStatus from json.
func (o *OptUserDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoTrafficLimitStrategy as json.
func (o OptUserDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UserDtoTrafficLimitStrategy from json.
func (o *OptUserDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUserDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUserDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUserDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfRegisterRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes RegisterRequestDto from json.
func (s *RegisterRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterRequestDto) {
					name = jsonFieldsNameOfRegisterRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRegisterResponseDto = [1]string{
	0: "response",
}

// Decode decodes RegisterResponseDto from json.
func (s *RegisterResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterResponseDto) {
					name = jsonFieldsNameOfRegisterResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfRegisterResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes RegisterResponseDtoResponse from json.
func (s *RegisterResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterResponseDtoResponse) {
					name = jsonFieldsNameOfRegisterResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes RemoveUsersFromInternalSquadResponseDto from json.
func (s *RemoveUsersFromInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto) {
					name = jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RemoveUsersFromInternalSquadResponseDtoResponse from json.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hosts")
		e.ArrStart()
		for _, elem := range s.Hosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderHostRequestDto = [1]string{
	0: "hosts",
}

// Decode decodes ReorderHostRequestDto from json.
func (s *ReorderHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hosts = make([]ReorderHostRequestDtoHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderHostRequestDtoHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDto) {
					name = jsonFieldsNameOfReorderHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDtoHostsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderHostRequestDtoHostsItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderHostRequestDtoHostsItem from json.
func (s *ReorderHostRequestDtoHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDtoHostsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDtoHostsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDtoHostsItem) {
					name = jsonFieldsNameOfReorderHostRequestDtoHostsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDtoHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfReorderHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderHostResponseDto from json.
func (s *ReorderHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDto) {
					name = jsonFieldsNameOfReorderHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isUpdated")
		e.Bool(s.IsUpdated)
	}
}

var jsonFieldsNameOfReorderHostResponseDtoResponse = [1]string{
	0: "isUpdated",
}

// Decode decodes ReorderHostResponseDtoResponse from json.
func (s *ReorderHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isUpdated":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsUpdated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUpdated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDtoResponse) {
					name = jsonFieldsNameOfReorderHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeRequestDto = [1]string{
	0: "nodes",
}

// Decode decodes ReorderNodeRequestDto from json.
func (s *ReorderNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]ReorderNodeRequestDtoNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeRequestDtoNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDto) {
					name = jsonFieldsNameOfReorderNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDtoNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderNodeRequestDtoNodesItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderNodeRequestDtoNodesItem from json.
func (s *ReorderNodeRequestDtoNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDtoNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDtoNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDtoNodesItem) {
					name = jsonFieldsNameOfReorderNodeRequestDtoNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDtoNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderNodeResponseDto from json.
func (s *ReorderNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]ReorderNodeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDto) {
					name = jsonFieldsNameOfReorderNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes ReorderNodeResponseDtoResponseItem from json.
func (s *ReorderNodeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes ReorderNodeResponseDtoResponseItemConfigProfile from json.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem from json.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes ReorderNodeResponseDtoResponseItemProvider from json.
func (s *ReorderNodeResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDto = [1]string{
	0: "response",
}

// Decode decodes ResetUserTrafficResponseDto from json.
func (s *ResetUserTrafficResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDto) {
					name = jsonFieldsNameOfResetUserTrafficResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponse = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes ResetUserTrafficResponseDtoResponse from json.
func (s *ResetUserTrafficResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponse) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem from json.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes ResetUserTrafficResponseDtoResponseHapp from json.
func (s *ResetUserTrafficResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (s ResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (s *ResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseStatus(v) {
	case ResetUserTrafficResponseDtoResponseStatusACTIVE:
		*s = ResetUserTrafficResponseDtoResponseStatusACTIVE
	case ResetUserTrafficResponseDtoResponseStatusDISABLED:
		*s = ResetUserTrafficResponseDtoResponseStatusDISABLED
	case ResetUserTrafficResponseDtoResponseStatusLIMITED:
		*s = ResetUserTrafficResponseDtoResponseStatusLIMITED
	case ResetUserTrafficResponseDtoResponseStatusEXPIRED:
		*s = ResetUserTrafficResponseDtoResponseStatusEXPIRED
	default:
		*s = ResetUserTrafficResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v) {
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartAllNodesResponseDto from json.
func (s *RestartAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDto) {
					name = jsonFieldsNameOfRestartAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartAllNodesResponseDtoResponse from json.
func (s *RestartAllNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDtoResponse) {
					name = jsonFieldsNameOfRestartAllNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartNodeResponseDto from json.
func (s *RestartNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDto) {
					name = jsonFieldsNameOfRestartNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartNodeResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartNodeResponseDtoResponse from json.
func (s *RestartNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDtoResponse) {
					name = jsonFieldsNameOfRestartNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionBodyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionBodyDto) encodeFields(e *jx.Encoder) {
	{
		if s.ShortUuid.Set {
			e.FieldStart("shortUuid")
			s.ShortUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionBodyDto = [1]string{
	0: "shortUuid",
}

// Decode decodes RevokeUserSubscriptionBodyDto from json.
func (s *RevokeUserSubscriptionBodyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionBodyDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			if err := func() error {
				s.ShortUuid.Reset()
				if err := s.ShortUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionBodyDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionBodyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionBodyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes RevokeUserSubscriptionResponseDto from json.
func (s *RevokeUserSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDto) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse = [30]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "subscriptionUrl",
	28: "lastConnectedNode",
	29: "happ",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponse from json.
func (s *RevokeUserSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem from json.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseHapp from json.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseStatus(v) {
	case RevokeUserSubscriptionResponseDtoResponseStatusACTIVE:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusACTIVE
	case RevokeUserSubscriptionResponseDtoResponseStatusDISABLED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusDISABLED
	case RevokeUserSubscriptionResponseDtoResponseStatusLIMITED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusLIMITED
	case RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v) {
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsRequestDto = [3]string{
	0: "uuids",
	1: "configProfileUuid",
	2: "configProfileInboundUuid",
}

// Decode decodes SetInboundToManyHostsRequestDto from json.
func (s *SetInboundToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetInboundToManyHostsResponseDto from json.
func (s *SetInboundToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetInboundToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetInboundToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItem from json.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemInbound from json.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
}

var jsonFieldsNameOfSetPortToManyHostsRequestDto = [2]string{
	0: "uuids",
	1: "port",
}

// Decode decodes SetPortToManyHostsRequestDto from json.
func (s *SetPortToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetPortToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetPortToManyHostsResponseDto from json.
func (s *SetPortToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetPortToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetPortToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItem from json.
func (s *SetPortToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemInbound from json.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError from json.
func (s *SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionControllerGetRawSubscriptionByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError from json.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerGetSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionSettingsControllerGetSettingsInternalServerError from json.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerGetSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerGetSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerUpdateSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionSettingsControllerUpdateSettingsInternalServerError from json.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerUpdateSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerUpdateSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetTemplateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetTemplateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerGetTemplateInternalServerError from json.
func (s *SubscriptionTemplateControllerGetTemplateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetTemplateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetTemplateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetTemplateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerUpdateTemplateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerUpdateTemplateInternalServerError from json.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerUpdateTemplateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerUpdateTemplateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetAllSubscriptionsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetAllSubscriptionsInternalServerError from json.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetAllSubscriptionsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetAllSubscriptionsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameInternalServerError from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameNotFound = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameNotFound from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetBandwidthStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetBandwidthStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetBandwidthStatsInternalServerError from json.
func (s *SystemControllerGetBandwidthStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetBandwidthStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetBandwidthStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesMetricsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesMetricsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetNodesMetricsInternalServerError from json.
func (s *SystemControllerGetNodesMetricsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesMetricsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesMetricsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesStatisticsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesStatisticsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetNodesStatisticsInternalServerError from json.
func (s *SystemControllerGetNodesStatisticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesStatisticsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesStatisticsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetRemnawaveHealthInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetRemnawaveHealthInternalServerError from json.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetRemnawaveHealthInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetRemnawaveHealthInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetStatsInternalServerError from json.
func (s *SystemControllerGetStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		e.FieldStart("auth_date")
		e.Float64(s.AuthDate)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
}

var jsonFieldsNameOfTelegramCallbackRequestDto = [7]string{
	0: "id",
	1: "first_name",
	2: "last_name",
	3: "username",
	4: "photo_url",
	5: "auth_date",
	6: "hash",
}

// Decode decodes TelegramCallbackRequestDto from json.
func (s *TelegramCallbackRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "auth_date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.AuthDate = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_date\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackRequestDto) {
					name = jsonFieldsNameOfTelegramCallbackRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfTelegramCallbackResponseDto = [1]string{
	0: "response",
}

// Decode decodes TelegramCallbackResponseDto from json.
func (s *TelegramCallbackResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackResponseDto) {
					name = jsonFieldsNameOfTelegramCallbackResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("accessToken")
		e.Str(s.AccessToken)
	}
}

var jsonFieldsNameOfTelegramCallbackResponseDtoResponse = [1]string{
	0: "accessToken",
}

// Decode decodes TelegramCallbackResponseDtoResponse from json.
func (s *TelegramCallbackResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "accessToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.AccessToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackResponseDtoResponse) {
					name = jsonFieldsNameOfTelegramCallbackResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConfigProfileRequestDto = [2]string{
	0: "uuid",
	1: "config",
}

// Decode decodes UpdateConfigProfileRequestDto from json.
func (s *UpdateConfigProfileRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileRequestDto) {
					name = jsonFieldsNameOfUpdateConfigProfileRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileRequestDtoConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileRequestDtoConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateConfigProfileRequestDtoConfig = [0]string{}

// Decode decodes UpdateConfigProfileRequestDtoConfig from json.
func (s *UpdateConfigProfileRequestDtoConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileRequestDtoConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileRequestDtoConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileRequestDtoConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileRequestDtoConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateConfigProfileResponseDto from json.
func (s *UpdateConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDto) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes UpdateConfigProfileResponseDtoResponse from json.
func (s *UpdateConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]UpdateConfigProfileResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateConfigProfileResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]UpdateConfigProfileResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateConfigProfileResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateConfigProfileResponseDtoResponseInboundsItem from json.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateConfigProfileResponseDtoResponseNodesItem from json.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateHostRequestDto = [14]string{
	0:  "uuid",
	1:  "inbound",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "serverDescription",
}

// Decode decodes UpdateHostRequestDto from json.
func (s *UpdateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostRequestDto) {
					name = jsonFieldsNameOfUpdateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (s UpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (s *UpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoAlpn(v) {
	case UpdateHostRequestDtoAlpnH3:
		*s = UpdateHostRequestDtoAlpnH3
	case UpdateHostRequestDtoAlpnH2:
		*s = UpdateHostRequestDtoAlpnH2
	case UpdateHostRequestDtoAlpnHTTP11:
		*s = UpdateHostRequestDtoAlpnHTTP11
	case UpdateHostRequestDtoAlpnH2HTTP11:
		*s = UpdateHostRequestDtoAlpnH2HTTP11
	case UpdateHostRequestDtoAlpnH3H2HTTP11:
		*s = UpdateHostRequestDtoAlpnH3H2HTTP11
	case UpdateHostRequestDtoAlpnH3H2:
		*s = UpdateHostRequestDtoAlpnH3H2
	default:
		*s = UpdateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (s UpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (s *UpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoFingerprint(v) {
	case UpdateHostRequestDtoFingerprintChrome:
		*s = UpdateHostRequestDtoFingerprintChrome
	case UpdateHostRequestDtoFingerprintFirefox:
		*s = UpdateHostRequestDtoFingerprintFirefox
	case UpdateHostRequestDtoFingerprintSafari:
		*s = UpdateHostRequestDtoFingerprintSafari
	case UpdateHostRequestDtoFingerprintIos:
		*s = UpdateHostRequestDtoFingerprintIos
	case UpdateHostRequestDtoFingerprintAndroid:
		*s = UpdateHostRequestDtoFingerprintAndroid
	case UpdateHostRequestDtoFingerprintEdge:
		*s = UpdateHostRequestDtoFingerprintEdge
	case UpdateHostRequestDtoFingerprintQq:
		*s = UpdateHostRequestDtoFingerprintQq
	case UpdateHostRequestDtoFingerprintRandom:
		*s = UpdateHostRequestDtoFingerprintRandom
	case UpdateHostRequestDtoFingerprintRandomized:
		*s = UpdateHostRequestDtoFingerprintRandomized
	default:
		*s = UpdateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostRequestDtoInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfUpdateHostRequestDtoInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes UpdateHostRequestDtoInbound from json.
func (s *UpdateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostRequestDtoInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostRequestDtoInbound) {
					name = jsonFieldsNameOfUpdateHostRequestDtoInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (s UpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (s *UpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoSecurityLayer(v) {
	case UpdateHostRequestDtoSecurityLayerDEFAULT:
		*s = UpdateHostRequestDtoSecurityLayerDEFAULT
	case UpdateHostRequestDtoSecurityLayerTLS:
		*s = UpdateHostRequestDtoSecurityLayerTLS
	case UpdateHostRequestDtoSecurityLayerNONE:
		*s = UpdateHostRequestDtoSecurityLayerNONE
	default:
		*s = UpdateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateHostResponseDto from json.
func (s *UpdateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDto) {
					name = jsonFieldsNameOfUpdateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDtoResponse = [15]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "inbound",
	14: "serverDescription",
}

// Decode decodes UpdateHostResponseDtoResponse from json.
func (s *UpdateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b01110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes UpdateHostResponseDtoResponseInbound from json.
func (s *UpdateHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfUpdateHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (s UpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (s *UpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostResponseDtoResponseSecurityLayer(v) {
	case UpdateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = UpdateHostResponseDtoResponseSecurityLayerDEFAULT
	case UpdateHostResponseDtoResponseSecurityLayerTLS:
		*s = UpdateHostResponseDtoResponseSecurityLayerTLS
	case UpdateHostResponseDtoResponseSecurityLayerNONE:
		*s = UpdateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = UpdateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeRequestDto = [2]string{
	0: "uuid",
	1: "nextBillingAt",
}

// Decode decodes UpdateInfraBillingNodeRequestDto from json.
func (s *UpdateInfraBillingNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeRequestDto) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInfraBillingNodeResponseDto from json.
func (s *UpdateInfraBillingNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDto) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponse from json.
func (s *UpdateInfraBillingNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseStats from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.FaviconLink.Set {
			e.FieldStart("faviconLink")
			s.FaviconLink.Encode(e)
		}
	}
	{
		if s.LoginUrl.Set {
			e.FieldStart("loginUrl")
			s.LoginUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateInfraProviderRequestDto = [4]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
}

// Decode decodes UpdateInfraProviderRequestDto from json.
func (s *UpdateInfraProviderRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			if err := func() error {
				s.FaviconLink.Reset()
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			if err := func() error {
				s.LoginUrl.Reset()
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderRequestDto) {
					name = jsonFieldsNameOfUpdateInfraProviderRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInfraProviderResponseDto from json.
func (s *UpdateInfraProviderResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDto) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes UpdateInfraProviderResponseDtoResponse from json.
func (s *UpdateInfraProviderResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]UpdateInfraProviderResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraProviderResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes UpdateInfraProviderResponseDtoResponseBillingHistory from json.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraProviderResponseDtoResponseBillingNodesItem from json.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateInternalSquadRequestDto = [2]string{
	0: "uuid",
	1: "inbounds",
}

// Decode decodes UpdateInternalSquadRequestDto from json.
func (s *UpdateInternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadRequestDto) {
					name = jsonFieldsNameOfUpdateInternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInternalSquadResponseDto from json.
func (s *UpdateInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDto) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes UpdateInternalSquadResponseDtoResponse from json.
func (s *UpdateInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]UpdateInternalSquadResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInternalSquadResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateInternalSquadResponseDtoResponseInboundsItem from json.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes UpdateInternalSquadResponseDtoResponseInfo from json.
func (s *UpdateInternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
	{
		if s.ConfigProfile.Set {
			e.FieldStart("configProfile")
			s.ConfigProfile.Encode(e)
		}
	}
	{
		if s.ProviderUuid.Set {
			e.FieldStart("providerUuid")
			s.ProviderUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNodeRequestDto = [12]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isTrafficTrackingActive",
	5:  "trafficLimitBytes",
	6:  "notifyPercent",
	7:  "trafficResetDay",
	8:  "countryCode",
	9:  "consumptionMultiplier",
	10: "configProfile",
	11: "providerUuid",
}

// Decode decodes UpdateNodeRequestDto from json.
func (s *UpdateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "configProfile":
			if err := func() error {
				s.ConfigProfile.Reset()
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			if err := func() error {
				s.ProviderUuid.Reset()
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeRequestDto) {
					name = jsonFieldsNameOfUpdateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeRequestDtoConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		json.EncodeUUID(e, s.ActiveConfigProfileUuid)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes UpdateNodeRequestDtoConfigProfile from json.
func (s *UpdateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeRequestDtoConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActiveConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeRequestDtoConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile) {
					name = jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateNodeResponseDto from json.
func (s *UpdateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDto) {
					name = jsonFieldsNameOfUpdateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes UpdateNodeResponseDtoResponse from json.
func (s *UpdateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes UpdateNodeResponseDtoResponseConfigProfile from json.
func (s *UpdateNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes UpdateNodeResponseDtoResponseProvider from json.
func (s *UpdateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.ExpiredUsersRemarks != nil {
			e.FieldStart("expiredUsersRemarks")
			e.ArrStart()
			for _, elem := range s.ExpiredUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LimitedUsersRemarks != nil {
			e.FieldStart("limitedUsersRemarks")
			e.ArrStart()
			for _, elem := range s.LimitedUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisabledUsersRemarks != nil {
			e.FieldStart("disabledUsersRemarks")
			e.ArrStart()
			for _, elem := range s.DisabledUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CustomResponseHeaders.Set {
			e.FieldStart("customResponseHeaders")
			s.CustomResponseHeaders.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto = [15]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
}

// Decode decodes UpdateSubscriptionSettingsRequestDto from json.
func (s *UpdateSubscriptionSettingsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			if err := func() error {
				s.CustomResponseHeaders.Reset()
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateSubscriptionSettingsResponseDto from json.
func (s *UpdateSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("randomizeHosts")
		e.Bool(s.RandomizeHosts)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse = [17]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
	15: "createdAt",
	16: "updatedAt",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponse from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.RandomizeHosts = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		case "createdAt":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if s.TemplateJson != nil {
			e.FieldStart("templateJson")
			s.TemplateJson.Encode(e)
		}
	}
	{
		if s.EncodedTemplateYaml.Set {
			e.FieldStart("encodedTemplateYaml")
			s.EncodedTemplateYaml.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTemplateRequestDto = [3]string{
	0: "templateType",
	1: "templateJson",
	2: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateRequestDto from json.
func (s *UpdateTemplateRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			if err := func() error {
				s.TemplateJson = nil
				var elem UpdateTemplateRequestDtoTemplateJson
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TemplateJson = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			if err := func() error {
				s.EncodedTemplateYaml.Reset()
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateRequestDto) {
					name = jsonFieldsNameOfUpdateTemplateRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDtoTemplateJson) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateTemplateRequestDtoTemplateJson = [0]string{}

// Decode decodes UpdateTemplateRequestDtoTemplateJson from json.
func (s *UpdateTemplateRequestDtoTemplateJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDtoTemplateJson to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDtoTemplateJson")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateRequestDtoTemplateType as json.
func (s UpdateTemplateRequestDtoTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateRequestDtoTemplateType from json.
func (s *UpdateTemplateRequestDtoTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDtoTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateRequestDtoTemplateType(v) {
	case UpdateTemplateRequestDtoTemplateTypeSTASH:
		*s = UpdateTemplateRequestDtoTemplateTypeSTASH
	case UpdateTemplateRequestDtoTemplateTypeSINGBOX:
		*s = UpdateTemplateRequestDtoTemplateTypeSINGBOX
	case UpdateTemplateRequestDtoTemplateTypeSINGBOXLEGACY:
		*s = UpdateTemplateRequestDtoTemplateTypeSINGBOXLEGACY
	case UpdateTemplateRequestDtoTemplateTypeMIHOMO:
		*s = UpdateTemplateRequestDtoTemplateTypeMIHOMO
	case UpdateTemplateRequestDtoTemplateTypeXRAYJSON:
		*s = UpdateTemplateRequestDtoTemplateTypeXRAYJSON
	case UpdateTemplateRequestDtoTemplateTypeCLASH:
		*s = UpdateTemplateRequestDtoTemplateTypeCLASH
	default:
		*s = UpdateTemplateRequestDtoTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateRequestDtoTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDtoTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateTemplateResponseDto from json.
func (s *UpdateTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDto) {
					name = jsonFieldsNameOfUpdateTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDtoResponse = [4]string{
	0: "uuid",
	1: "templateType",
	2: "templateJson",
	3: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateResponseDtoResponse from json.
func (s *UpdateTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateResponseDtoResponseTemplateType as json.
func (s UpdateTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateResponseDtoResponseTemplateType from json.
func (s *UpdateTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateResponseDtoResponseTemplateType(v) {
	case UpdateTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSTASH
	case UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX
	case UpdateTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSINGBOXLEGACY
	case UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO
	case UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case UpdateTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeCLASH
	default:
		*s = UpdateTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ActiveInternalSquads != nil {
			e.FieldStart("activeInternalSquads")
			e.ArrStart()
			for _, elem := range s.ActiveInternalSquads {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateUserRequestDto = [11]string{
	0:  "uuid",
	1:  "status",
	2:  "trafficLimitBytes",
	3:  "trafficLimitStrategy",
	4:  "expireAt",
	5:  "description",
	6:  "tag",
	7:  "telegramId",
	8:  "email",
	9:  "hwidDeviceLimit",
	10: "activeInternalSquads",
}

// Decode decodes UpdateUserRequestDto from json.
func (s *UpdateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "activeInternalSquads":
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserRequestDto) {
					name = jsonFieldsNameOfUpdateUserRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (s UpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (s *UpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoStatus(v) {
	case UpdateUserRequestDtoStatusACTIVE:
		*s = UpdateUserRequestDtoStatusACTIVE
	case UpdateUserRequestDtoStatusDISABLED:
		*s = UpdateUserRequestDtoStatusDISABLED
	case UpdateUserRequestDtoStatusLIMITED:
		*s = UpdateUserRequestDtoStatusLIMITED
	case UpdateUserRequestDtoStatusEXPIRED:
		*s = UpdateUserRequestDtoStatusEXPIRED
	default:
		*s = UpdateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (s UpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoTrafficLimitStrategy(v) {
	case UpdateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = UpdateUserRequestDtoTrafficLimitStrategyNORESET
	case UpdateUserRequestDtoTrafficLimitStrategyDAY:
		*s = UpdateUserRequestDtoTrafficLimitStrategyDAY
	case UpdateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = UpdateUserRequestDtoTrafficLimitStrategyWEEK
	case UpdateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = UpdateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = UpdateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("subscriptionUuid")
		json.EncodeUUID(e, s.SubscriptionUuid)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfUserDto = [29]string{
	0:  "uuid",
	1:  "subscriptionUuid",
	2:  "shortUuid",
	3:  "username",
	4:  "status",
	5:  "usedTrafficBytes",
	6:  "lifetimeUsedTrafficBytes",
	7:  "trafficLimitBytes",
	8:  "trafficLimitStrategy",
	9:  "subLastUserAgent",
	10: "subLastOpenedAt",
	11: "expireAt",
	12: "onlineAt",
	13: "subRevokedAt",
	14: "lastTrafficResetAt",
	15: "trojanPassword",
	16: "vlessUuid",
	17: "ssPassword",
	18: "description",
	19: "tag",
	20: "telegramId",
	21: "email",
	22: "hwidDeviceLimit",
	23: "createdAt",
	24: "updatedAt",
	25: "activeInternalSquads",
	26: "subscriptionUrl",
	27: "lastConnectedNode",
	28: "happ",
}

// Decode decodes UserDto from json.
func (s *UserDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDto to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "subscriptionUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SubscriptionUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				s.ActiveInternalSquads = make([]UserDtoActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDtoActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b01101111,
		0b11111110,
		0b11110111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDto) {
					name = jsonFieldsNameOfUserDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfUserDtoActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes UserDtoActiveInternalSquadsItem from json.
func (s *UserDtoActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoActiveInternalSquadsItem) {
					name = jsonFieldsNameOfUserDtoActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfUserDtoHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes UserDtoHapp from json.
func (s *UserDtoHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoHapp) {
					name = jsonFieldsNameOfUserDtoHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserDtoLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserDtoLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
}

var jsonFieldsNameOfUserDtoLastConnectedNode = [2]string{
	0: "connectedAt",
	1: "nodeName",
}

// Decode decodes UserDtoLastConnectedNode from json.
func (s *UserDtoLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserDtoLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserDtoLastConnectedNode) {
					name = jsonFieldsNameOfUserDtoLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserDtoLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoStatus as json.
func (s UserDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserDtoStatus from json.
func (s *UserDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserDtoStatus(v) {
	case UserDtoStatusACTIVE:
		*s = UserDtoStatusACTIVE
	case UserDtoStatusDISABLED:
		*s = UserDtoStatusDISABLED
	case UserDtoStatusLIMITED:
		*s = UserDtoStatusLIMITED
	case UserDtoStatusEXPIRED:
		*s = UserDtoStatusEXPIRED
	default:
		*s = UserDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UserDtoTrafficLimitStrategy as json.
func (s UserDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UserDtoTrafficLimitStrategy from json.
func (s *UserDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UserDtoTrafficLimitStrategy(v) {
	case UserDtoTrafficLimitStrategyNORESET:
		*s = UserDtoTrafficLimitStrategyNORESET
	case UserDtoTrafficLimitStrategyDAY:
		*s = UserDtoTrafficLimitStrategyDAY
	case UserDtoTrafficLimitStrategyWEEK:
		*s = UserDtoTrafficLimitStrategyWEEK
	case UserDtoTrafficLimitStrategyMONTH:
		*s = UserDtoTrafficLimitStrategyMONTH
	default:
		*s = UserDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UserDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes UserResponseDto from json.
func (s *UserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUserResponseDto) {
					name = jsonFieldsNameOfUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError from json.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkResetUserTrafficInternalServerError from json.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError from json.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateAllUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerCreateUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerCreateUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerCreateUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerCreateUserInternalServerError from json.
func (s *UsersControllerCreateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerCreateUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerCreateUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerCreateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerCreateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDeleteUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDeleteUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerDeleteUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerDeleteUserInternalServerError from json.
func (s *UsersControllerDeleteUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDeleteUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDeleteUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDeleteUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDeleteUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDisableUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDisableUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerDisableUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerDisableUserInternalServerError from json.
func (s *UsersControllerDisableUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDisableUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDisableUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDisableUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDisableUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerEnableUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerEnableUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerEnableUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerEnableUserInternalServerError from json.
func (s *UsersControllerEnableUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerEnableUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerEnableUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerEnableUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerEnableUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllTagsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllTagsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllTagsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetAllTagsInternalServerError from json.
func (s *UsersControllerGetAllTagsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllTagsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllTagsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllTagsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllTagsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetAllUsersInternalServerError from json.
func (s *UsersControllerGetAllUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserAccessibleNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserAccessibleNodesInternalServerError from json.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserAccessibleNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserAccessibleNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByShortUuidInternalServerError from json.
func (s *UsersControllerGetUserByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByTelegramIdInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByTelegramIdInternalServerError from json.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByTelegramIdInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByTelegramIdInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUsernameInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUsernameInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByUsernameInternalServerError from json.
func (s *UsersControllerGetUserByUsernameInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUsernameInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUsernameInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByUuidInternalServerError from json.
func (s *UsersControllerGetUserByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByEmailInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByEmailInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUsersByEmailInternalServerError from json.
func (s *UsersControllerGetUsersByEmailInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByEmailInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByEmailInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByTagInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByTagInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUsersByTagInternalServerError from json.
func (s *UsersControllerGetUsersByTagInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByTagInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByTagInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerResetUserTrafficInternalServerError from json.
func (s *UsersControllerResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerRevokeUserSubscriptionInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerRevokeUserSubscriptionInternalServerError from json.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerRevokeUserSubscriptionInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerRevokeUserSubscriptionInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerUpdateUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerUpdateUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerUpdateUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerUpdateUserInternalServerError from json.
func (s *UsersControllerUpdateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerUpdateUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerUpdateUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerUpdateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerUpdateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUsersDto = [1]string{
	0: "response",
}

// Decode decodes UsersDto from json.
func (s *UsersDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]UserDto, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserDto
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUsersDto) {
					name = jsonFieldsNameOfUsersDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersStatsControllerGetUserUsageByRangeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersStatsControllerGetUserUsageByRangeInternalServerError from json.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersStatsControllerGetUserUsageByRangeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersStatsControllerGetUserUsageByRangeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
