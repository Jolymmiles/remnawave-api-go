// Code generated by ogen, DO NOT EDIT.

package api

import (
	"math/bits"
	"net/url"
	"strconv"
	"time"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/google/uuid"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AddUsersToExternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToExternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfAddUsersToExternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes AddUsersToExternalSquadResponseDto from json.
func (s *AddUsersToExternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToExternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToExternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToExternalSquadResponseDto) {
					name = jsonFieldsNameOfAddUsersToExternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToExternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToExternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUsersToExternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToExternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfAddUsersToExternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes AddUsersToExternalSquadResponseDtoResponse from json.
func (s *AddUsersToExternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToExternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToExternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToExternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfAddUsersToExternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToExternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToExternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUsersToInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfAddUsersToInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes AddUsersToInternalSquadResponseDto from json.
func (s *AddUsersToInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToInternalSquadResponseDto) {
					name = jsonFieldsNameOfAddUsersToInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddUsersToInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes AddUsersToInternalSquadResponseDtoResponse from json.
func (s *AddUsersToInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddUsersToInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddUsersToInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfAddUsersToInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddUsersToInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerCreateBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerCreateBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfApiTokensControllerCreateBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ApiTokensControllerCreateBadRequest from json.
func (s *ApiTokensControllerCreateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerCreateBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ApiTokensControllerCreateBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApiTokensControllerCreateBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerCreateBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerCreateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerCreateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerCreateBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerCreateBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfApiTokensControllerCreateBadRequestErrorsItem = [0]string{}

// Decode decodes ApiTokensControllerCreateBadRequestErrorsItem from json.
func (s *ApiTokensControllerCreateBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerCreateBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerCreateBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerCreateBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerCreateBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerCreateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerCreateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerCreateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerCreateInternalServerError from json.
func (s *ApiTokensControllerCreateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerCreateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerCreateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerCreateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerCreateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerDeleteBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerDeleteBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfApiTokensControllerDeleteBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ApiTokensControllerDeleteBadRequest from json.
func (s *ApiTokensControllerDeleteBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerDeleteBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ApiTokensControllerDeleteBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApiTokensControllerDeleteBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerDeleteBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerDeleteBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerDeleteBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerDeleteBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerDeleteBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfApiTokensControllerDeleteBadRequestErrorsItem = [0]string{}

// Decode decodes ApiTokensControllerDeleteBadRequestErrorsItem from json.
func (s *ApiTokensControllerDeleteBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerDeleteBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerDeleteBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerDeleteBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerDeleteBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerDeleteInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerDeleteInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerDeleteInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerDeleteInternalServerError from json.
func (s *ApiTokensControllerDeleteInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerDeleteInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerDeleteInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerDeleteInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerDeleteInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerFindAllBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerFindAllBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfApiTokensControllerFindAllBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ApiTokensControllerFindAllBadRequest from json.
func (s *ApiTokensControllerFindAllBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerFindAllBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ApiTokensControllerFindAllBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ApiTokensControllerFindAllBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerFindAllBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerFindAllBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerFindAllBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerFindAllBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerFindAllBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfApiTokensControllerFindAllBadRequestErrorsItem = [0]string{}

// Decode decodes ApiTokensControllerFindAllBadRequestErrorsItem from json.
func (s *ApiTokensControllerFindAllBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerFindAllBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerFindAllBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerFindAllBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerFindAllBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ApiTokensControllerFindAllInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ApiTokensControllerFindAllInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfApiTokensControllerFindAllInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ApiTokensControllerFindAllInternalServerError from json.
func (s *ApiTokensControllerFindAllInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ApiTokensControllerFindAllInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ApiTokensControllerFindAllInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ApiTokensControllerFindAllInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ApiTokensControllerFindAllInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerGetStatusBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerGetStatusBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerGetStatusBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerGetStatusBadRequest from json.
func (s *AuthControllerGetStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerGetStatusBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerGetStatusBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerGetStatusBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerGetStatusBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerGetStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerGetStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerGetStatusBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerGetStatusBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerGetStatusBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerGetStatusBadRequestErrorsItem from json.
func (s *AuthControllerGetStatusBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerGetStatusBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerGetStatusBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerGetStatusBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerGetStatusBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerGetStatusInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerGetStatusInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerGetStatusInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerGetStatusInternalServerError from json.
func (s *AuthControllerGetStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerGetStatusInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerGetStatusInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerGetStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerGetStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerLoginBadRequest from json.
func (s *AuthControllerLoginBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerLoginBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerLoginBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerLoginBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerLoginBadRequestErrorsItem from json.
func (s *AuthControllerLoginBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerLoginInternalServerError from json.
func (s *AuthControllerLoginInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerLoginUnauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerLoginUnauthorized) encodeFields(e *jx.Encoder) {
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerLoginUnauthorized = [3]string{
	0: "statusCode",
	1: "message",
	2: "error",
}

// Decode decodes AuthControllerLoginUnauthorized from json.
func (s *AuthControllerLoginUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerLoginUnauthorized to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerLoginUnauthorized")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerLoginUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerLoginUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2AuthorizeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2AuthorizeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2AuthorizeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerOauth2AuthorizeBadRequest from json.
func (s *AuthControllerOauth2AuthorizeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2AuthorizeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerOauth2AuthorizeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerOauth2AuthorizeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2AuthorizeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2AuthorizeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2AuthorizeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2AuthorizeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2AuthorizeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerOauth2AuthorizeBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerOauth2AuthorizeBadRequestErrorsItem from json.
func (s *AuthControllerOauth2AuthorizeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2AuthorizeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2AuthorizeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2AuthorizeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2AuthorizeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2AuthorizeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2AuthorizeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerOauth2AuthorizeInternalServerError from json.
func (s *AuthControllerOauth2AuthorizeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2AuthorizeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2AuthorizeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2AuthorizeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2CallbackBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2CallbackBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2CallbackBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerOauth2CallbackBadRequest from json.
func (s *AuthControllerOauth2CallbackBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2CallbackBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerOauth2CallbackBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerOauth2CallbackBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2CallbackBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2CallbackBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2CallbackBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2CallbackBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2CallbackBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerOauth2CallbackBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerOauth2CallbackBadRequestErrorsItem from json.
func (s *AuthControllerOauth2CallbackBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2CallbackBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2CallbackBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2CallbackBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2CallbackBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerOauth2CallbackInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerOauth2CallbackInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerOauth2CallbackInternalServerError from json.
func (s *AuthControllerOauth2CallbackInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerOauth2CallbackInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerOauth2CallbackInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerOauth2CallbackInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationOptionsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerPasskeyAuthenticationOptionsBadRequest from json.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationOptionsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationOptionsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem from json.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationOptionsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationOptionsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerPasskeyAuthenticationOptionsInternalServerError from json.
func (s *AuthControllerPasskeyAuthenticationOptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationOptionsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationOptionsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationOptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationVerifyBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerPasskeyAuthenticationVerifyBadRequest from json.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationVerifyBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationVerifyBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem from json.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerPasskeyAuthenticationVerifyInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerPasskeyAuthenticationVerifyInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerPasskeyAuthenticationVerifyInternalServerError from json.
func (s *AuthControllerPasskeyAuthenticationVerifyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerPasskeyAuthenticationVerifyInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerPasskeyAuthenticationVerifyInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerPasskeyAuthenticationVerifyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerRegisterBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerRegisterBadRequest from json.
func (s *AuthControllerRegisterBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerRegisterBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerRegisterBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerRegisterBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerRegisterBadRequestErrorsItem from json.
func (s *AuthControllerRegisterBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerRegisterInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerRegisterInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerRegisterInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerRegisterInternalServerError from json.
func (s *AuthControllerRegisterInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerRegisterInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerRegisterInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerRegisterInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerRegisterInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerTelegramCallbackBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerTelegramCallbackBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfAuthControllerTelegramCallbackBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes AuthControllerTelegramCallbackBadRequest from json.
func (s *AuthControllerTelegramCallbackBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerTelegramCallbackBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]AuthControllerTelegramCallbackBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AuthControllerTelegramCallbackBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerTelegramCallbackBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerTelegramCallbackBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerTelegramCallbackBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerTelegramCallbackBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerTelegramCallbackBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfAuthControllerTelegramCallbackBadRequestErrorsItem = [0]string{}

// Decode decodes AuthControllerTelegramCallbackBadRequestErrorsItem from json.
func (s *AuthControllerTelegramCallbackBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerTelegramCallbackBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerTelegramCallbackBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerTelegramCallbackBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerTelegramCallbackBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AuthControllerTelegramCallbackInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfAuthControllerTelegramCallbackInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes AuthControllerTelegramCallbackInternalServerError from json.
func (s *AuthControllerTelegramCallbackInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AuthControllerTelegramCallbackInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AuthControllerTelegramCallbackInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AuthControllerTelegramCallbackInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllResetTrafficUsersResponseDto from json.
func (s *BulkAllResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllResetTrafficUsersResponseDtoResponse from json.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersRequestDto = [9]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
	8: "hwidDeviceLimit",
}

// Decode decodes BulkAllUpdateUsersRequestDto from json.
func (s *BulkAllUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (s BulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (s *BulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoStatus(v) {
	case BulkAllUpdateUsersRequestDtoStatusACTIVE:
		*s = BulkAllUpdateUsersRequestDtoStatusACTIVE
	case BulkAllUpdateUsersRequestDtoStatusDISABLED:
		*s = BulkAllUpdateUsersRequestDtoStatusDISABLED
	case BulkAllUpdateUsersRequestDtoStatusLIMITED:
		*s = BulkAllUpdateUsersRequestDtoStatusLIMITED
	case BulkAllUpdateUsersRequestDtoStatusEXPIRED:
		*s = BulkAllUpdateUsersRequestDtoStatusEXPIRED
	default:
		*s = BulkAllUpdateUsersRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v) {
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyNORESET
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyDAY
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyWEEK
	case BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = BulkAllUpdateUsersRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkAllUpdateUsersResponseDto from json.
func (s *BulkAllUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkAllUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes BulkAllUpdateUsersResponseDtoResponse from json.
func (s *BulkAllUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkAllUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkAllUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkAllUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkAllUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteHostsRequestDto from json.
func (s *BulkDeleteHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsRequestDto) {
					name = jsonFieldsNameOfBulkDeleteHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteHostsResponseDto from json.
func (s *BulkDeleteHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDeleteHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDeleteHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDto) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItem from json.
func (s *BulkDeleteHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemInbound from json.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkDeleteHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDeleteHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusRequestDto = [1]string{
	0: "status",
}

// Decode decodes BulkDeleteUsersByStatusRequestDto from json.
func (s *BulkDeleteUsersByStatusRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (s BulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDeleteUsersByStatusRequestDtoStatus(v) {
	case BulkDeleteUsersByStatusRequestDtoStatusACTIVE:
		*s = BulkDeleteUsersByStatusRequestDtoStatusACTIVE
	case BulkDeleteUsersByStatusRequestDtoStatusDISABLED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusDISABLED
	case BulkDeleteUsersByStatusRequestDtoStatusLIMITED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusLIMITED
	case BulkDeleteUsersByStatusRequestDtoStatusEXPIRED:
		*s = BulkDeleteUsersByStatusRequestDtoStatusEXPIRED
	default:
		*s = BulkDeleteUsersByStatusRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersByStatusResponseDto from json.
func (s *BulkDeleteUsersByStatusResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersByStatusResponseDtoResponse from json.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersByStatusResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersByStatusResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersByStatusResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersByStatusResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDeleteUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDeleteUsersRequestDto from json.
func (s *BulkDeleteUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersRequestDto) {
					name = jsonFieldsNameOfBulkDeleteUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDeleteUsersResponseDto from json.
func (s *BulkDeleteUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDto) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDeleteUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkDeleteUsersResponseDtoResponse from json.
func (s *BulkDeleteUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDeleteUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDeleteUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkDeleteUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDeleteUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDeleteUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkDisableHostsRequestDto from json.
func (s *BulkDisableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsRequestDto) {
					name = jsonFieldsNameOfBulkDisableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkDisableHostsResponseDto from json.
func (s *BulkDisableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkDisableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkDisableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDto) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes BulkDisableHostsResponseDtoResponseItem from json.
func (s *BulkDisableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemInbound from json.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkDisableHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkDisableHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkDisableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkDisableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkEnableHostsRequestDto from json.
func (s *BulkEnableHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsRequestDto) {
					name = jsonFieldsNameOfBulkEnableHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkEnableHostsResponseDto from json.
func (s *BulkEnableHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]BulkEnableHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem BulkEnableHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDto) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes BulkEnableHostsResponseDtoResponseItem from json.
func (s *BulkEnableHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemInbound from json.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkEnableHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfBulkEnableHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkEnableHostsResponseDtoResponseItemSecurityLayer(v) {
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerTLS
	case BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = BulkEnableHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkResetTrafficUsersRequestDto from json.
func (s *BulkResetTrafficUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersRequestDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkResetTrafficUsersResponseDto from json.
func (s *BulkResetTrafficUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDto) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkResetTrafficUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkResetTrafficUsersResponseDtoResponse from json.
func (s *BulkResetTrafficUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkResetTrafficUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkResetTrafficUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkResetTrafficUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkResetTrafficUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto = [1]string{
	0: "uuids",
}

// Decode decodes BulkRevokeUsersSubscriptionRequestDto from json.
func (s *BulkRevokeUsersSubscriptionRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDto from json.
func (s *BulkRevokeUsersSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkRevokeUsersSubscriptionResponseDtoResponse from json.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkRevokeUsersSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkRevokeUsersSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfBulkRevokeUsersSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkRevokeUsersSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("fields")
		s.Fields.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDto = [2]string{
	0: "uuids",
	1: "fields",
}

// Decode decodes BulkUpdateUsersRequestDto from json.
func (s *BulkUpdateUsersRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "fields":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Fields.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fields\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersRequestDtoFields) encodeFields(e *jx.Encoder) {
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ExternalSquadUuid.Set {
			e.FieldStart("externalSquadUuid")
			s.ExternalSquadUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfBulkUpdateUsersRequestDtoFields = [10]string{
	0: "status",
	1: "trafficLimitBytes",
	2: "trafficLimitStrategy",
	3: "expireAt",
	4: "description",
	5: "telegramId",
	6: "email",
	7: "tag",
	8: "hwidDeviceLimit",
	9: "externalSquadUuid",
}

// Decode decodes BulkUpdateUsersRequestDtoFields from json.
func (s *BulkUpdateUsersRequestDtoFields) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFields to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "externalSquadUuid":
			if err := func() error {
				s.ExternalSquadUuid.Reset()
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersRequestDtoFields")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersRequestDtoFields) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFields) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (s BulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsStatus(v) {
	case BulkUpdateUsersRequestDtoFieldsStatusACTIVE:
		*s = BulkUpdateUsersRequestDtoFieldsStatusACTIVE
	case BulkUpdateUsersRequestDtoFieldsStatusDISABLED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusDISABLED
	case BulkUpdateUsersRequestDtoFieldsStatusLIMITED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusLIMITED
	case BulkUpdateUsersRequestDtoFieldsStatusEXPIRED:
		*s = BulkUpdateUsersRequestDtoFieldsStatusEXPIRED
	default:
		*s = BulkUpdateUsersRequestDtoFieldsStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v) {
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyNORESET
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyDAY
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyWEEK
	case BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategyMONTH
	default:
		*s = BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersResponseDto from json.
func (s *BulkUpdateUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersResponseDtoResponse from json.
func (s *BulkUpdateUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto = [2]string{
	0: "uuids",
	1: "activeInternalSquads",
}

// Decode decodes BulkUpdateUsersSquadsRequestDto from json.
func (s *BulkUpdateUsersSquadsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "activeInternalSquads":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto = [1]string{
	0: "response",
}

// Decode decodes BulkUpdateUsersSquadsResponseDto from json.
func (s *BulkUpdateUsersSquadsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("affectedRows")
		e.Float64(s.AffectedRows)
	}
}

var jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse = [1]string{
	0: "affectedRows",
}

// Decode decodes BulkUpdateUsersSquadsResponseDtoResponse from json.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BulkUpdateUsersSquadsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "affectedRows":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.AffectedRows = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"affectedRows\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BulkUpdateUsersSquadsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse) {
					name = jsonFieldsNameOfBulkUpdateUsersSquadsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BulkUpdateUsersSquadsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerCreateConfigProfileBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerCreateConfigProfileBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerCreateConfigProfileBadRequest from json.
func (s *ConfigProfileControllerCreateConfigProfileBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerCreateConfigProfileBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerCreateConfigProfileBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerCreateConfigProfileBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem from json.
func (s *ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerCreateConfigProfileBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerCreateConfigProfileInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerCreateConfigProfileInternalServerError from json.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerCreateConfigProfileInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerCreateConfigProfileInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerCreateConfigProfileInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerDeleteConfigProfileByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerDeleteConfigProfileByUuidBadRequest from json.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerDeleteConfigProfileByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerDeleteConfigProfileByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem from json.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerDeleteConfigProfileByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError from json.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerDeleteConfigProfileByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetAllInboundsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetAllInboundsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerGetAllInboundsBadRequest from json.
func (s *ConfigProfileControllerGetAllInboundsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetAllInboundsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerGetAllInboundsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerGetAllInboundsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetAllInboundsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetAllInboundsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerGetAllInboundsBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerGetAllInboundsBadRequestErrorsItem from json.
func (s *ConfigProfileControllerGetAllInboundsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetAllInboundsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetAllInboundsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetAllInboundsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetAllInboundsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetAllInboundsInternalServerError from json.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetAllInboundsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetAllInboundsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetAllInboundsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfileByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerGetConfigProfileByUuidBadRequest from json.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfileByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfileByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem from json.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfileByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetConfigProfileByUuidInternalServerError from json.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfileByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfileByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfileByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfilesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfilesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerGetConfigProfilesBadRequest from json.
func (s *ConfigProfileControllerGetConfigProfilesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfilesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfilesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfilesBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem from json.
func (s *ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfilesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetConfigProfilesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetConfigProfilesInternalServerError from json.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetConfigProfilesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetConfigProfilesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetConfigProfilesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetInboundsByProfileUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerGetInboundsByProfileUuidBadRequest from json.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetInboundsByProfileUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetInboundsByProfileUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem from json.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerGetInboundsByProfileUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerGetInboundsByProfileUuidInternalServerError from json.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerGetInboundsByProfileUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerGetInboundsByProfileUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerGetInboundsByProfileUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerUpdateConfigProfileBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ConfigProfileControllerUpdateConfigProfileBadRequest from json.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerUpdateConfigProfileBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerUpdateConfigProfileBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem = [0]string{}

// Decode decodes ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem from json.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerUpdateConfigProfileBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigProfileControllerUpdateConfigProfileInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ConfigProfileControllerUpdateConfigProfileInternalServerError from json.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigProfileControllerUpdateConfigProfileInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigProfileControllerUpdateConfigProfileInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigProfileControllerUpdateConfigProfileInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
}

var jsonFieldsNameOfCreateApiTokenRequestDto = [1]string{
	0: "tokenName",
}

// Decode decodes CreateApiTokenRequestDto from json.
func (s *CreateApiTokenRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tokenName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenRequestDto) {
					name = jsonFieldsNameOfCreateApiTokenRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateApiTokenResponseDto from json.
func (s *CreateApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDto) {
					name = jsonFieldsNameOfCreateApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateApiTokenResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
}

var jsonFieldsNameOfCreateApiTokenResponseDtoResponse = [2]string{
	0: "token",
	1: "uuid",
}

// Decode decodes CreateApiTokenResponseDtoResponse from json.
func (s *CreateApiTokenResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateApiTokenResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "token":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateApiTokenResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateApiTokenResponseDtoResponse) {
					name = jsonFieldsNameOfCreateApiTokenResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateApiTokenResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateApiTokenResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
}

var jsonFieldsNameOfCreateConfigProfileRequestDto = [2]string{
	0: "name",
	1: "config",
}

// Decode decodes CreateConfigProfileRequestDto from json.
func (s *CreateConfigProfileRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileRequestDto) {
					name = jsonFieldsNameOfCreateConfigProfileRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileRequestDtoConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileRequestDtoConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateConfigProfileRequestDtoConfig = [0]string{}

// Decode decodes CreateConfigProfileRequestDtoConfig from json.
func (s *CreateConfigProfileRequestDtoConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileRequestDtoConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileRequestDtoConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileRequestDtoConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileRequestDtoConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateConfigProfileResponseDto from json.
func (s *CreateConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDto) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes CreateConfigProfileResponseDtoResponse from json.
func (s *CreateConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]CreateConfigProfileResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateConfigProfileResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]CreateConfigProfileResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateConfigProfileResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateConfigProfileResponseDtoResponseInboundsItem from json.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateConfigProfileResponseDtoResponseNodesItem from json.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConfigProfileResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConfigProfileResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfCreateConfigProfileResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConfigProfileResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateExternalSquadRequestDto = [1]string{
	0: "name",
}

// Decode decodes CreateExternalSquadRequestDto from json.
func (s *CreateExternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExternalSquadRequestDto) {
					name = jsonFieldsNameOfCreateExternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateExternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateExternalSquadResponseDto from json.
func (s *CreateExternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExternalSquadResponseDto) {
					name = jsonFieldsNameOfCreateExternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionSettings")
		s.SubscriptionSettings.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateExternalSquadResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "templates",
	4: "subscriptionSettings",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes CreateExternalSquadResponseDtoResponse from json.
func (s *CreateExternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "templates":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Templates = make([]CreateExternalSquadResponseDtoResponseTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateExternalSquadResponseDtoResponseTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "subscriptionSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SubscriptionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionSettings\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfCreateExternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
}

var jsonFieldsNameOfCreateExternalSquadResponseDtoResponseInfo = [1]string{
	0: "membersCount",
}

// Decode decodes CreateExternalSquadResponseDtoResponseInfo from json.
func (s *CreateExternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfCreateExternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadResponseDtoResponseSubscriptionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateExternalSquadResponseDtoResponseSubscriptionSettings = [10]string{
	0: "profileTitle",
	1: "supportLink",
	2: "profileUpdateInterval",
	3: "isProfileWebpageUrlEnabled",
	4: "serveJsonAtBaseSubscription",
	5: "addUsernameToBaseSubscription",
	6: "isShowCustomRemarks",
	7: "happAnnounce",
	8: "happRouting",
	9: "randomizeHosts",
}

// Decode decodes CreateExternalSquadResponseDtoResponseSubscriptionSettings from json.
func (s *CreateExternalSquadResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDtoResponseSubscriptionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadResponseDtoResponseSubscriptionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateUuid")
		json.EncodeUUID(e, s.TemplateUuid)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfCreateExternalSquadResponseDtoResponseTemplatesItem = [2]string{
	0: "templateUuid",
	1: "templateType",
}

// Decode decodes CreateExternalSquadResponseDtoResponseTemplatesItem from json.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDtoResponseTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateUuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateExternalSquadResponseDtoResponseTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateExternalSquadResponseDtoResponseTemplatesItem) {
					name = jsonFieldsNameOfCreateExternalSquadResponseDtoResponseTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType as json.
func (s CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType from json.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType(v) {
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeMIHOMO:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeMIHOMO
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSTASH:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSTASH
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeCLASH:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeCLASH
	case CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSINGBOX:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSINGBOX
	default:
		*s = CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateExternalSquadResponseDtoResponseTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.VlessRouteId.Set {
			e.FieldStart("vlessRouteId")
			s.VlessRouteId.Encode(e)
		}
	}
	{
		if s.ShuffleHost.Set {
			e.FieldStart("shuffleHost")
			s.ShuffleHost.Encode(e)
		}
	}
	{
		if s.MihomoX25519.Set {
			e.FieldStart("mihomoX25519")
			s.MihomoX25519.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfCreateHostRequestDto = [23]string{
	0:  "inbound",
	1:  "remark",
	2:  "address",
	3:  "port",
	4:  "path",
	5:  "sni",
	6:  "host",
	7:  "alpn",
	8:  "fingerprint",
	9:  "isDisabled",
	10: "securityLayer",
	11: "xHttpExtraParams",
	12: "muxParams",
	13: "sockoptParams",
	14: "serverDescription",
	15: "tag",
	16: "isHidden",
	17: "overrideSniFromAddress",
	18: "allowInsecure",
	19: "vlessRouteId",
	20: "shuffleHost",
	21: "mihomoX25519",
	22: "nodes",
}

// Decode decodes CreateHostRequestDto from json.
func (s *CreateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDto to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "inbound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "vlessRouteId":
			if err := func() error {
				s.VlessRouteId.Reset()
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "shuffleHost":
			if err := func() error {
				s.ShuffleHost.Reset()
				if err := s.ShuffleHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			if err := func() error {
				s.MihomoX25519.Reset()
				if err := s.MihomoX25519.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00001111,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostRequestDto) {
					name = jsonFieldsNameOfCreateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (s CreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (s *CreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoAlpn(v) {
	case CreateHostRequestDtoAlpnH3:
		*s = CreateHostRequestDtoAlpnH3
	case CreateHostRequestDtoAlpnH2:
		*s = CreateHostRequestDtoAlpnH2
	case CreateHostRequestDtoAlpnHTTP11:
		*s = CreateHostRequestDtoAlpnHTTP11
	case CreateHostRequestDtoAlpnH2HTTP11:
		*s = CreateHostRequestDtoAlpnH2HTTP11
	case CreateHostRequestDtoAlpnH3H2HTTP11:
		*s = CreateHostRequestDtoAlpnH3H2HTTP11
	case CreateHostRequestDtoAlpnH3H2:
		*s = CreateHostRequestDtoAlpnH3H2
	default:
		*s = CreateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (s CreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (s *CreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoFingerprint(v) {
	case CreateHostRequestDtoFingerprintChrome:
		*s = CreateHostRequestDtoFingerprintChrome
	case CreateHostRequestDtoFingerprintFirefox:
		*s = CreateHostRequestDtoFingerprintFirefox
	case CreateHostRequestDtoFingerprintSafari:
		*s = CreateHostRequestDtoFingerprintSafari
	case CreateHostRequestDtoFingerprintIos:
		*s = CreateHostRequestDtoFingerprintIos
	case CreateHostRequestDtoFingerprintAndroid:
		*s = CreateHostRequestDtoFingerprintAndroid
	case CreateHostRequestDtoFingerprintEdge:
		*s = CreateHostRequestDtoFingerprintEdge
	case CreateHostRequestDtoFingerprintQq:
		*s = CreateHostRequestDtoFingerprintQq
	case CreateHostRequestDtoFingerprintRandom:
		*s = CreateHostRequestDtoFingerprintRandom
	case CreateHostRequestDtoFingerprintRandomized:
		*s = CreateHostRequestDtoFingerprintRandomized
	default:
		*s = CreateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostRequestDtoInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfCreateHostRequestDtoInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes CreateHostRequestDtoInbound from json.
func (s *CreateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostRequestDtoInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostRequestDtoInbound) {
					name = jsonFieldsNameOfCreateHostRequestDtoInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (s CreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (s *CreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostRequestDtoSecurityLayer(v) {
	case CreateHostRequestDtoSecurityLayerDEFAULT:
		*s = CreateHostRequestDtoSecurityLayerDEFAULT
	case CreateHostRequestDtoSecurityLayerTLS:
		*s = CreateHostRequestDtoSecurityLayerTLS
	case CreateHostRequestDtoSecurityLayerNONE:
		*s = CreateHostRequestDtoSecurityLayerNONE
	default:
		*s = CreateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateHostResponseDto from json.
func (s *CreateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDto) {
					name = jsonFieldsNameOfCreateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateHostResponseDtoResponse = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes CreateHostResponseDtoResponse from json.
func (s *CreateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDtoResponse) {
					name = jsonFieldsNameOfCreateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfCreateHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes CreateHostResponseDtoResponseInbound from json.
func (s *CreateHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfCreateHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (s CreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (s *CreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateHostResponseDtoResponseSecurityLayer(v) {
	case CreateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = CreateHostResponseDtoResponseSecurityLayerDEFAULT
	case CreateHostResponseDtoResponseSecurityLayerTLS:
		*s = CreateHostResponseDtoResponseSecurityLayerTLS
	case CreateHostResponseDtoResponseSecurityLayerNONE:
		*s = CreateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = CreateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto = [3]string{
	0: "providerUuid",
	1: "amount",
	2: "billedAt",
}

// Decode decodes CreateInfraBillingHistoryRecordRequestDto from json.
func (s *CreateInfraBillingHistoryRecordRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDto from json.
func (s *CreateInfraBillingHistoryRecordResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponse from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider from json.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfCreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingHistoryRecordResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		if s.NextBillingAt.Set {
			e.FieldStart("nextBillingAt")
			s.NextBillingAt.Encode(e, json.EncodeDateTime)
		}
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeRequestDto = [3]string{
	0: "providerUuid",
	1: "nodeUuid",
	2: "nextBillingAt",
}

// Decode decodes CreateInfraBillingNodeRequestDto from json.
func (s *CreateInfraBillingNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "providerUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nextBillingAt":
			if err := func() error {
				s.NextBillingAt.Reset()
				if err := s.NextBillingAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeRequestDto) {
					name = jsonFieldsNameOfCreateInfraBillingNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraBillingNodeResponseDto from json.
func (s *CreateInfraBillingNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDto) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponse from json.
func (s *CreateInfraBillingNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]CreateInfraBillingNodeResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingNodeResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem from json.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItem from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider from json.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes CreateInfraBillingNodeResponseDtoResponseStats from json.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraBillingNodeResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraBillingNodeResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats) {
					name = jsonFieldsNameOfCreateInfraBillingNodeResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraBillingNodeResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.FaviconLink.Set {
			e.FieldStart("faviconLink")
			s.FaviconLink.Encode(e)
		}
	}
	{
		if s.LoginUrl.Set {
			e.FieldStart("loginUrl")
			s.LoginUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateInfraProviderRequestDto = [3]string{
	0: "name",
	1: "faviconLink",
	2: "loginUrl",
}

// Decode decodes CreateInfraProviderRequestDto from json.
func (s *CreateInfraProviderRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			if err := func() error {
				s.FaviconLink.Reset()
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			if err := func() error {
				s.LoginUrl.Reset()
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderRequestDto) {
					name = jsonFieldsNameOfCreateInfraProviderRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInfraProviderResponseDto from json.
func (s *CreateInfraProviderResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDto) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes CreateInfraProviderResponseDtoResponse from json.
func (s *CreateInfraProviderResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]CreateInfraProviderResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInfraProviderResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes CreateInfraProviderResponseDtoResponseBillingHistory from json.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes CreateInfraProviderResponseDtoResponseBillingNodesItem from json.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInfraProviderResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInfraProviderResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfCreateInfraProviderResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInfraProviderResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateInternalSquadRequestDto = [2]string{
	0: "name",
	1: "inbounds",
}

// Decode decodes CreateInternalSquadRequestDto from json.
func (s *CreateInternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadRequestDto) {
					name = jsonFieldsNameOfCreateInternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateInternalSquadResponseDto from json.
func (s *CreateInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDto) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes CreateInternalSquadResponseDtoResponse from json.
func (s *CreateInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]CreateInternalSquadResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateInternalSquadResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateInternalSquadResponseDtoResponseInboundsItem from json.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateInternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes CreateInternalSquadResponseDtoResponseInfo from json.
func (s *CreateInternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateInternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateInternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfCreateInternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateInternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		if s.ProviderUuid.Set {
			e.FieldStart("providerUuid")
			s.ProviderUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateNodeRequestDto = [11]string{
	0:  "name",
	1:  "address",
	2:  "port",
	3:  "isTrafficTrackingActive",
	4:  "trafficLimitBytes",
	5:  "notifyPercent",
	6:  "trafficResetDay",
	7:  "countryCode",
	8:  "consumptionMultiplier",
	9:  "configProfile",
	10: "providerUuid",
}

// Decode decodes CreateNodeRequestDto from json.
func (s *CreateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "configProfile":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			if err := func() error {
				s.ProviderUuid.Reset()
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeRequestDto) {
					name = jsonFieldsNameOfCreateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeRequestDtoConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		json.EncodeUUID(e, s.ActiveConfigProfileUuid)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateNodeRequestDtoConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes CreateNodeRequestDtoConfigProfile from json.
func (s *CreateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeRequestDtoConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActiveConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeRequestDtoConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeRequestDtoConfigProfile) {
					name = jsonFieldsNameOfCreateNodeRequestDtoConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateNodeResponseDto from json.
func (s *CreateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDto) {
					name = jsonFieldsNameOfCreateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes CreateNodeResponseDtoResponse from json.
func (s *CreateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes CreateNodeResponseDtoResponseConfigProfile from json.
func (s *CreateNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes CreateNodeResponseDtoResponseProvider from json.
func (s *CreateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfCreateNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnippetRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnippetRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("snippet")
		e.ArrStart()
		for _, elem := range s.Snippet {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateSnippetRequestDto = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes CreateSnippetRequestDto from json.
func (s *CreateSnippetRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnippetRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippet = make([]CreateSnippetRequestDtoSnippetItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateSnippetRequestDtoSnippetItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippet = append(s.Snippet, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnippetRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSnippetRequestDto) {
					name = jsonFieldsNameOfCreateSnippetRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnippetRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnippetRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnippetRequestDtoSnippetItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnippetRequestDtoSnippetItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfCreateSnippetRequestDtoSnippetItem = [0]string{}

// Decode decodes CreateSnippetRequestDtoSnippetItem from json.
func (s *CreateSnippetRequestDtoSnippetItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnippetRequestDtoSnippetItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnippetRequestDtoSnippetItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnippetRequestDtoSnippetItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnippetRequestDtoSnippetItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnippetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnippetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateSnippetResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateSnippetResponseDto from json.
func (s *CreateSnippetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnippetResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnippetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSnippetResponseDto) {
					name = jsonFieldsNameOfCreateSnippetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnippetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnippetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnippetResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnippetResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("snippets")
		e.ArrStart()
		for _, elem := range s.Snippets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateSnippetResponseDtoResponse = [2]string{
	0: "total",
	1: "snippets",
}

// Decode decodes CreateSnippetResponseDtoResponse from json.
func (s *CreateSnippetResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnippetResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "snippets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippets = make([]CreateSnippetResponseDtoResponseSnippetsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateSnippetResponseDtoResponseSnippetsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippets = append(s.Snippets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnippetResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSnippetResponseDtoResponse) {
					name = jsonFieldsNameOfCreateSnippetResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnippetResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnippetResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSnippetResponseDtoResponseSnippetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSnippetResponseDtoResponseSnippetsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Snippet) != 0 {
			e.FieldStart("snippet")
			e.Raw(s.Snippet)
		}
	}
}

var jsonFieldsNameOfCreateSnippetResponseDtoResponseSnippetsItem = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes CreateSnippetResponseDtoResponseSnippetsItem from json.
func (s *CreateSnippetResponseDtoResponseSnippetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSnippetResponseDtoResponseSnippetsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Snippet = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSnippetResponseDtoResponseSnippetsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSnippetResponseDtoResponseSnippetsItem) {
					name = jsonFieldsNameOfCreateSnippetResponseDtoResponseSnippetsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSnippetResponseDtoResponseSnippetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSnippetResponseDtoResponseSnippetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSubscriptionTemplateRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSubscriptionTemplateRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfCreateSubscriptionTemplateRequestDto = [2]string{
	0: "name",
	1: "templateType",
}

// Decode decodes CreateSubscriptionTemplateRequestDto from json.
func (s *CreateSubscriptionTemplateRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSubscriptionTemplateRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSubscriptionTemplateRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSubscriptionTemplateRequestDto) {
					name = jsonFieldsNameOfCreateSubscriptionTemplateRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSubscriptionTemplateRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSubscriptionTemplateRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSubscriptionTemplateRequestDtoTemplateType as json.
func (s CreateSubscriptionTemplateRequestDtoTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSubscriptionTemplateRequestDtoTemplateType from json.
func (s *CreateSubscriptionTemplateRequestDtoTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSubscriptionTemplateRequestDtoTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSubscriptionTemplateRequestDtoTemplateType(v) {
	case CreateSubscriptionTemplateRequestDtoTemplateTypeXRAYJSON:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeXRAYJSON
	case CreateSubscriptionTemplateRequestDtoTemplateTypeXRAYBASE64:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeXRAYBASE64
	case CreateSubscriptionTemplateRequestDtoTemplateTypeMIHOMO:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeMIHOMO
	case CreateSubscriptionTemplateRequestDtoTemplateTypeSTASH:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeSTASH
	case CreateSubscriptionTemplateRequestDtoTemplateTypeCLASH:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeCLASH
	case CreateSubscriptionTemplateRequestDtoTemplateTypeSINGBOX:
		*s = CreateSubscriptionTemplateRequestDtoTemplateTypeSINGBOX
	default:
		*s = CreateSubscriptionTemplateRequestDtoTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSubscriptionTemplateRequestDtoTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSubscriptionTemplateRequestDtoTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSubscriptionTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSubscriptionTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateSubscriptionTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateSubscriptionTemplateResponseDto from json.
func (s *CreateSubscriptionTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSubscriptionTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSubscriptionTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSubscriptionTemplateResponseDto) {
					name = jsonFieldsNameOfCreateSubscriptionTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSubscriptionTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSubscriptionTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSubscriptionTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSubscriptionTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfCreateSubscriptionTemplateResponseDtoResponse = [5]string{
	0: "uuid",
	1: "name",
	2: "templateType",
	3: "templateJson",
	4: "encodedTemplateYaml",
}

// Decode decodes CreateSubscriptionTemplateResponseDtoResponse from json.
func (s *CreateSubscriptionTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSubscriptionTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSubscriptionTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSubscriptionTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfCreateSubscriptionTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSubscriptionTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSubscriptionTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSubscriptionTemplateResponseDtoResponseTemplateType as json.
func (s CreateSubscriptionTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateSubscriptionTemplateResponseDtoResponseTemplateType from json.
func (s *CreateSubscriptionTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSubscriptionTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateSubscriptionTemplateResponseDtoResponseTemplateType(v) {
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeXRAYBASE64:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeXRAYBASE64
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeMIHOMO
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeSTASH
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeCLASH
	case CreateSubscriptionTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateTypeSINGBOX
	default:
		*s = CreateSubscriptionTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateSubscriptionTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSubscriptionTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		if s.Platform.Set {
			e.FieldStart("platform")
			s.Platform.Encode(e)
		}
	}
	{
		if s.OsVersion.Set {
			e.FieldStart("osVersion")
			s.OsVersion.Encode(e)
		}
	}
	{
		if s.DeviceModel.Set {
			e.FieldStart("deviceModel")
			s.DeviceModel.Encode(e)
		}
	}
	{
		if s.UserAgent.Set {
			e.FieldStart("userAgent")
			s.UserAgent.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceRequestDto = [6]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
}

// Decode decodes CreateUserHwidDeviceRequestDto from json.
func (s *CreateUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			if err := func() error {
				s.Platform.Reset()
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			if err := func() error {
				s.OsVersion.Reset()
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			if err := func() error {
				s.DeviceModel.Reset()
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			if err := func() error {
				s.UserAgent.Reset()
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateUserHwidDeviceResponseDto from json.
func (s *CreateUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes CreateUserHwidDeviceResponseDtoResponse from json.
func (s *CreateUserHwidDeviceResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]CreateUserHwidDeviceResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateUserHwidDeviceResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes CreateUserHwidDeviceResponseDtoResponseDevicesItem from json.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserHwidDeviceResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserHwidDeviceResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfCreateUserHwidDeviceResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserHwidDeviceResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.ShortUuid.Set {
			e.FieldStart("shortUuid")
			s.ShortUuid.Encode(e)
		}
	}
	{
		if s.TrojanPassword.Set {
			e.FieldStart("trojanPassword")
			s.TrojanPassword.Encode(e)
		}
	}
	{
		if s.VlessUuid.Set {
			e.FieldStart("vlessUuid")
			s.VlessUuid.Encode(e)
		}
	}
	{
		if s.SsPassword.Set {
			e.FieldStart("ssPassword")
			s.SsPassword.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		if s.CreatedAt.Set {
			e.FieldStart("createdAt")
			s.CreatedAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.LastTrafficResetAt.Set {
			e.FieldStart("lastTrafficResetAt")
			s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ActiveInternalSquads != nil {
			e.FieldStart("activeInternalSquads")
			e.ArrStart()
			for _, elem := range s.ActiveInternalSquads {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.ExternalSquadUuid.Set {
			e.FieldStart("externalSquadUuid")
			s.ExternalSquadUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateUserRequestDto = [19]string{
	0:  "username",
	1:  "status",
	2:  "shortUuid",
	3:  "trojanPassword",
	4:  "vlessUuid",
	5:  "ssPassword",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "expireAt",
	9:  "createdAt",
	10: "lastTrafficResetAt",
	11: "description",
	12: "tag",
	13: "telegramId",
	14: "email",
	15: "hwidDeviceLimit",
	16: "activeInternalSquads",
	17: "uuid",
	18: "externalSquadUuid",
}

// Decode decodes CreateUserRequestDto from json.
func (s *CreateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDto to nil")
	}
	var requiredBitSet [3]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "shortUuid":
			if err := func() error {
				s.ShortUuid.Reset()
				if err := s.ShortUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "trojanPassword":
			if err := func() error {
				s.TrojanPassword.Reset()
				if err := s.TrojanPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			if err := func() error {
				s.VlessUuid.Reset()
				if err := s.VlessUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			if err := func() error {
				s.SsPassword.Reset()
				if err := s.SsPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "createdAt":
			if err := func() error {
				s.CreatedAt.Reset()
				if err := s.CreatedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "lastTrafficResetAt":
			if err := func() error {
				s.LastTrafficResetAt.Reset()
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "activeInternalSquads":
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "externalSquadUuid":
			if err := func() error {
				s.ExternalSquadUuid.Reset()
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserRequestDto) {
					name = jsonFieldsNameOfCreateUserRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (s CreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (s *CreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoStatus(v) {
	case CreateUserRequestDtoStatusACTIVE:
		*s = CreateUserRequestDtoStatusACTIVE
	case CreateUserRequestDtoStatusDISABLED:
		*s = CreateUserRequestDtoStatusDISABLED
	case CreateUserRequestDtoStatusLIMITED:
		*s = CreateUserRequestDtoStatusLIMITED
	case CreateUserRequestDtoStatusEXPIRED:
		*s = CreateUserRequestDtoStatusEXPIRED
	default:
		*s = CreateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoTrafficLimitStrategy as json.
func (s CreateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserRequestDtoTrafficLimitStrategy from json.
func (s *CreateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserRequestDtoTrafficLimitStrategy(v) {
	case CreateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = CreateUserRequestDtoTrafficLimitStrategyNORESET
	case CreateUserRequestDtoTrafficLimitStrategyDAY:
		*s = CreateUserRequestDtoTrafficLimitStrategyDAY
	case CreateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = CreateUserRequestDtoTrafficLimitStrategyWEEK
	case CreateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = CreateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = CreateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes CreateUserResponseDto from json.
func (s *CreateUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseDto) {
					name = jsonFieldsNameOfCreateUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfCreateUserResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes CreateUserResponseDtoResponse from json.
func (s *CreateUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]CreateUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem CreateUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseDtoResponse) {
					name = jsonFieldsNameOfCreateUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes CreateUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *CreateUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfCreateUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfCreateUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes CreateUserResponseDtoResponseHapp from json.
func (s *CreateUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfCreateUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfCreateUserResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes CreateUserResponseDtoResponseLastConnectedNode from json.
func (s *CreateUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfCreateUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseDtoResponseStatus as json.
func (s CreateUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserResponseDtoResponseStatus from json.
func (s *CreateUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserResponseDtoResponseStatus(v) {
	case CreateUserResponseDtoResponseStatusACTIVE:
		*s = CreateUserResponseDtoResponseStatusACTIVE
	case CreateUserResponseDtoResponseStatusDISABLED:
		*s = CreateUserResponseDtoResponseStatusDISABLED
	case CreateUserResponseDtoResponseStatusLIMITED:
		*s = CreateUserResponseDtoResponseStatusLIMITED
	case CreateUserResponseDtoResponseStatusEXPIRED:
		*s = CreateUserResponseDtoResponseStatusEXPIRED
	default:
		*s = CreateUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseDtoResponseTrafficLimitStrategy as json.
func (s CreateUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes CreateUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *CreateUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch CreateUserResponseDtoResponseTrafficLimitStrategy(v) {
	case CreateUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = CreateUserResponseDtoResponseTrafficLimitStrategyNORESET
	case CreateUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = CreateUserResponseDtoResponseTrafficLimitStrategyDAY
	case CreateUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = CreateUserResponseDtoResponseTrafficLimitStrategyWEEK
	case CreateUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = CreateUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = CreateUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("responseRules")
		s.ResponseRules.Encode(e)
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDto = [1]string{
	0: "responseRules",
}

// Decode decodes DebugSrrMatcherRequestDto from json.
func (s *DebugSrrMatcherRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "responseRules":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ResponseRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseRules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherRequestDto) {
					name = jsonFieldsNameOfDebugSrrMatcherRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDtoResponseRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRules = [2]string{
	0: "version",
	1: "rules",
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRules from json.
func (s *DebugSrrMatcherRequestDtoResponseRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Rules = make([]DebugSrrMatcherRequestDtoResponseRulesRulesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DebugSrrMatcherRequestDtoResponseRulesRulesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDtoResponseRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRules) {
					name = jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		if s.ResponseModifications.Set {
			e.FieldStart("responseModifications")
			s.ResponseModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItem = [7]string{
	0: "name",
	1: "description",
	2: "enabled",
	3: "operator",
	4: "conditions",
	5: "responseType",
	6: "responseModifications",
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItem from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "conditions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Conditions = make([]DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "responseModifications":
			if err := func() error {
				s.ResponseModifications.Reset()
				if err := s.ResponseModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseModifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDtoResponseRulesRulesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItem) {
					name = jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headerName")
		e.Str(s.HeaderName)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("caseSensitive")
		e.Bool(s.CaseSensitive)
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem = [4]string{
	0: "headerName",
	1: "operator",
	2: "value",
	3: "caseSensitive",
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeaderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerName\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "caseSensitive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CaseSensitive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseSensitive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) {
					name = jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator as json.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator(v) {
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorEQUALS:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorEQUALS
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTEQUALS:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTEQUALS
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorCONTAINS:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorCONTAINS
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorSTARTSWITH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorSTARTSWITH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorENDSWITH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorENDSWITH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorREGEX:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorREGEX
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTREGEX:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTREGEX
	default:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator as json.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator(v) {
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemOperatorAND:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemOperatorAND
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemOperatorOR:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemOperatorOR
	default:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionTemplate.Set {
			e.FieldStart("subscriptionTemplate")
			s.SubscriptionTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications = [2]string{
	0: "headers",
	1: "subscriptionTemplate",
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "subscriptionTemplate":
			if err := func() error {
				s.SubscriptionTemplate.Reset()
				if err := s.SubscriptionTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) {
					name = jsonFieldsNameOfDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType as json.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType(v) {
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeXRAYJSON:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeXRAYJSON
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeXRAYBASE64:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeXRAYBASE64
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeMIHOMO:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeMIHOMO
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTASH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTASH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeCLASH:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeCLASH
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSINGBOX:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSINGBOX
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeBROWSER:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeBROWSER
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeBLOCK:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeBLOCK
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE404:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE404
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE451:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE451
	case DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSOCKETDROP:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseTypeSOCKETDROP
	default:
		*s = DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherRequestDtoResponseRulesVersion as json.
func (s DebugSrrMatcherRequestDtoResponseRulesVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesVersion from json.
func (s *DebugSrrMatcherRequestDtoResponseRulesVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherRequestDtoResponseRulesVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherRequestDtoResponseRulesVersion(v) {
	case DebugSrrMatcherRequestDtoResponseRulesVersion1:
		*s = DebugSrrMatcherRequestDtoResponseRulesVersion1
	default:
		*s = DebugSrrMatcherRequestDtoResponseRulesVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherRequestDtoResponseRulesVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherRequestDtoResponseRulesVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDto = [1]string{
	0: "response",
}

// Decode decodes DebugSrrMatcherResponseDto from json.
func (s *DebugSrrMatcherResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherResponseDto) {
					name = jsonFieldsNameOfDebugSrrMatcherResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("matched")
		e.Bool(s.Matched)
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		e.FieldStart("matchedRule")
		s.MatchedRule.Encode(e)
	}
	{
		e.FieldStart("inputHeaders")
		s.InputHeaders.Encode(e)
	}
	{
		e.FieldStart("outputHeaders")
		s.OutputHeaders.Encode(e)
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDtoResponse = [5]string{
	0: "matched",
	1: "responseType",
	2: "matchedRule",
	3: "inputHeaders",
	4: "outputHeaders",
}

// Decode decodes DebugSrrMatcherResponseDtoResponse from json.
func (s *DebugSrrMatcherResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "matched":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Matched = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matched\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "matchedRule":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.MatchedRule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"matchedRule\"")
			}
		case "inputHeaders":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.InputHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inputHeaders\"")
			}
		case "outputHeaders":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.OutputHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outputHeaders\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherResponseDtoResponse) {
					name = jsonFieldsNameOfDebugSrrMatcherResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseInputHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseInputHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DebugSrrMatcherResponseDtoResponseInputHeaders from json.
func (s *DebugSrrMatcherResponseDtoResponseInputHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseInputHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseInputHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseInputHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseInputHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		if s.ResponseModifications.Set {
			e.FieldStart("responseModifications")
			s.ResponseModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRule = [7]string{
	0: "name",
	1: "description",
	2: "enabled",
	3: "operator",
	4: "conditions",
	5: "responseType",
	6: "responseModifications",
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRule from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "conditions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Conditions = make([]DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "responseModifications":
			if err := func() error {
				s.ResponseModifications.Reset()
				if err := s.ResponseModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseModifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseMatchedRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRule) {
					name = jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headerName")
		e.Str(s.HeaderName)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("caseSensitive")
		e.Bool(s.CaseSensitive)
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem = [4]string{
	0: "headerName",
	1: "operator",
	2: "value",
	3: "caseSensitive",
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeaderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerName\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "caseSensitive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CaseSensitive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseSensitive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) {
					name = jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator as json.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator(v) {
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorEQUALS:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorEQUALS
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTEQUALS:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTEQUALS
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorCONTAINS:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorCONTAINS
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTCONTAINS:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTCONTAINS
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorSTARTSWITH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorSTARTSWITH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTSTARTSWITH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTSTARTSWITH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorENDSWITH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorENDSWITH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTENDSWITH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTENDSWITH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorREGEX:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorREGEX
	case DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTREGEX:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperatorNOTREGEX
	default:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseMatchedRuleOperator as json.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleOperator from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherResponseDtoResponseMatchedRuleOperator(v) {
	case DebugSrrMatcherResponseDtoResponseMatchedRuleOperatorAND:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleOperatorAND
	case DebugSrrMatcherResponseDtoResponseMatchedRuleOperatorOR:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleOperatorOR
	default:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionTemplate.Set {
			e.FieldStart("subscriptionTemplate")
			s.SubscriptionTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications = [2]string{
	0: "headers",
	1: "subscriptionTemplate",
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "subscriptionTemplate":
			if err := func() error {
				s.SubscriptionTemplate.Reset()
				if err := s.SubscriptionTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) {
					name = jsonFieldsNameOfDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType as json.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType from json.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType(v) {
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeXRAYJSON:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeXRAYJSON
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeXRAYBASE64:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeXRAYBASE64
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeMIHOMO:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeMIHOMO
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTASH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTASH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeCLASH:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeCLASH
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSINGBOX:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSINGBOX
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeBROWSER:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeBROWSER
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeBLOCK:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeBLOCK
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTATUSCODE404:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTATUSCODE404
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTATUSCODE451:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSTATUSCODE451
	case DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSOCKETDROP:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseTypeSOCKETDROP
	default:
		*s = DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseOutputHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseOutputHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DebugSrrMatcherResponseDtoResponseOutputHeaders from json.
func (s *DebugSrrMatcherResponseDtoResponseOutputHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseOutputHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DebugSrrMatcherResponseDtoResponseOutputHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseOutputHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseOutputHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseResponseType as json.
func (s DebugSrrMatcherResponseDtoResponseResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DebugSrrMatcherResponseDtoResponseResponseType from json.
func (s *DebugSrrMatcherResponseDtoResponseResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DebugSrrMatcherResponseDtoResponseResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DebugSrrMatcherResponseDtoResponseResponseType(v) {
	case DebugSrrMatcherResponseDtoResponseResponseTypeXRAYJSON:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeXRAYJSON
	case DebugSrrMatcherResponseDtoResponseResponseTypeXRAYBASE64:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeXRAYBASE64
	case DebugSrrMatcherResponseDtoResponseResponseTypeMIHOMO:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeMIHOMO
	case DebugSrrMatcherResponseDtoResponseResponseTypeSTASH:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeSTASH
	case DebugSrrMatcherResponseDtoResponseResponseTypeCLASH:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeCLASH
	case DebugSrrMatcherResponseDtoResponseResponseTypeSINGBOX:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeSINGBOX
	case DebugSrrMatcherResponseDtoResponseResponseTypeBROWSER:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeBROWSER
	case DebugSrrMatcherResponseDtoResponseResponseTypeBLOCK:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeBLOCK
	case DebugSrrMatcherResponseDtoResponseResponseTypeSTATUSCODE404:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeSTATUSCODE404
	case DebugSrrMatcherResponseDtoResponseResponseTypeSTATUSCODE451:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeSTATUSCODE451
	case DebugSrrMatcherResponseDtoResponseResponseTypeSOCKETDROP:
		*s = DebugSrrMatcherResponseDtoResponseResponseTypeSOCKETDROP
	default:
		*s = DebugSrrMatcherResponseDtoResponseResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DebugSrrMatcherResponseDtoResponseResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DebugSrrMatcherResponseDtoResponseResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAllUserHwidDevicesRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAllUserHwidDevicesRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
}

var jsonFieldsNameOfDeleteAllUserHwidDevicesRequestDto = [1]string{
	0: "userUuid",
}

// Decode decodes DeleteAllUserHwidDevicesRequestDto from json.
func (s *DeleteAllUserHwidDevicesRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAllUserHwidDevicesRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAllUserHwidDevicesRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAllUserHwidDevicesRequestDto) {
					name = jsonFieldsNameOfDeleteAllUserHwidDevicesRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAllUserHwidDevicesRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAllUserHwidDevicesRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAllUserHwidDevicesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteAllUserHwidDevicesResponseDto from json.
func (s *DeleteAllUserHwidDevicesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAllUserHwidDevicesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAllUserHwidDevicesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDto) {
					name = jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAllUserHwidDevicesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAllUserHwidDevicesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes DeleteAllUserHwidDevicesResponseDtoResponse from json.
func (s *DeleteAllUserHwidDevicesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAllUserHwidDevicesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAllUserHwidDevicesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem from json.
func (s *DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfDeleteAllUserHwidDevicesResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteAllUserHwidDevicesResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteApiTokenResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteApiTokenResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.Bool(s.Response)
	}
}

var jsonFieldsNameOfDeleteApiTokenResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteApiTokenResponseDto from json.
func (s *DeleteApiTokenResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteApiTokenResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Response = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteApiTokenResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteApiTokenResponseDto) {
					name = jsonFieldsNameOfDeleteApiTokenResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteApiTokenResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteApiTokenResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteConfigProfileResponseDto from json.
func (s *DeleteConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteConfigProfileResponseDto) {
					name = jsonFieldsNameOfDeleteConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteConfigProfileResponseDtoResponse from json.
func (s *DeleteConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteExternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteExternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteExternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteExternalSquadResponseDto from json.
func (s *DeleteExternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteExternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteExternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteExternalSquadResponseDto) {
					name = jsonFieldsNameOfDeleteExternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteExternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteExternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteExternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteExternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteExternalSquadResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteExternalSquadResponseDtoResponse from json.
func (s *DeleteExternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteExternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteExternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteExternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteExternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteExternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteExternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteHostResponseDto from json.
func (s *DeleteHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDto) {
					name = jsonFieldsNameOfDeleteHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteHostResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteHostResponseDtoResponse from json.
func (s *DeleteHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteHostResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDto from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider from json.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfDeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingHistoryRecordByUuidResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDto from json.
func (s *DeleteInfraBillingNodeByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponse from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes DeleteInfraBillingNodeByUuidResponseDtoResponseStats from json.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraBillingNodeByUuidResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraBillingNodeByUuidResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats) {
					name = jsonFieldsNameOfDeleteInfraBillingNodeByUuidResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraBillingNodeByUuidResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraProviderByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInfraProviderByUuidResponseDto from json.
func (s *DeleteInfraProviderByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraProviderByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraProviderByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto) {
					name = jsonFieldsNameOfDeleteInfraProviderByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraProviderByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteInfraProviderByUuidResponseDtoResponse from json.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInfraProviderByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInfraProviderByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInfraProviderByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInfraProviderByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteInternalSquadResponseDto from json.
func (s *DeleteInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInternalSquadResponseDto) {
					name = jsonFieldsNameOfDeleteInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteInternalSquadResponseDtoResponse from json.
func (s *DeleteInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteNodeResponseDto from json.
func (s *DeleteNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDto) {
					name = jsonFieldsNameOfDeleteNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteNodeResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteNodeResponseDtoResponse from json.
func (s *DeleteNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeletePasskeyRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeletePasskeyRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
}

var jsonFieldsNameOfDeletePasskeyRequestDto = [1]string{
	0: "id",
}

// Decode decodes DeletePasskeyRequestDto from json.
func (s *DeletePasskeyRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeletePasskeyRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeletePasskeyRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeletePasskeyRequestDto) {
					name = jsonFieldsNameOfDeletePasskeyRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeletePasskeyRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeletePasskeyRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSnippetRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSnippetRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDeleteSnippetRequestDto = [1]string{
	0: "name",
}

// Decode decodes DeleteSnippetRequestDto from json.
func (s *DeleteSnippetRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSnippetRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSnippetRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSnippetRequestDto) {
					name = jsonFieldsNameOfDeleteSnippetRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSnippetRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSnippetRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSnippetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSnippetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteSnippetResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteSnippetResponseDto from json.
func (s *DeleteSnippetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSnippetResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSnippetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSnippetResponseDto) {
					name = jsonFieldsNameOfDeleteSnippetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSnippetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSnippetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSnippetResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSnippetResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("snippets")
		e.ArrStart()
		for _, elem := range s.Snippets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteSnippetResponseDtoResponse = [2]string{
	0: "total",
	1: "snippets",
}

// Decode decodes DeleteSnippetResponseDtoResponse from json.
func (s *DeleteSnippetResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSnippetResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "snippets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippets = make([]DeleteSnippetResponseDtoResponseSnippetsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteSnippetResponseDtoResponseSnippetsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippets = append(s.Snippets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSnippetResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSnippetResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteSnippetResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSnippetResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSnippetResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSnippetResponseDtoResponseSnippetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSnippetResponseDtoResponseSnippetsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Snippet) != 0 {
			e.FieldStart("snippet")
			e.Raw(s.Snippet)
		}
	}
}

var jsonFieldsNameOfDeleteSnippetResponseDtoResponseSnippetsItem = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes DeleteSnippetResponseDtoResponseSnippetsItem from json.
func (s *DeleteSnippetResponseDtoResponseSnippetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSnippetResponseDtoResponseSnippetsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Snippet = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSnippetResponseDtoResponseSnippetsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSnippetResponseDtoResponseSnippetsItem) {
					name = jsonFieldsNameOfDeleteSnippetResponseDtoResponseSnippetsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSnippetResponseDtoResponseSnippetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSnippetResponseDtoResponseSnippetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSubscriptionTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSubscriptionTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteSubscriptionTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteSubscriptionTemplateResponseDto from json.
func (s *DeleteSubscriptionTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSubscriptionTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSubscriptionTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSubscriptionTemplateResponseDto) {
					name = jsonFieldsNameOfDeleteSubscriptionTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSubscriptionTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSubscriptionTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteSubscriptionTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteSubscriptionTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteSubscriptionTemplateResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteSubscriptionTemplateResponseDtoResponse from json.
func (s *DeleteSubscriptionTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteSubscriptionTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteSubscriptionTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteSubscriptionTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteSubscriptionTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteSubscriptionTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteSubscriptionTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceRequestDto = [2]string{
	0: "userUuid",
	1: "hwid",
}

// Decode decodes DeleteUserHwidDeviceRequestDto from json.
func (s *DeleteUserHwidDeviceRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "hwid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceRequestDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserHwidDeviceResponseDto from json.
func (s *DeleteUserHwidDeviceResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDto) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes DeleteUserHwidDeviceResponseDtoResponse from json.
func (s *DeleteUserHwidDeviceResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]DeleteUserHwidDeviceResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DeleteUserHwidDeviceResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes DeleteUserHwidDeviceResponseDtoResponseDevicesItem from json.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserHwidDeviceResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserHwidDeviceResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfDeleteUserHwidDeviceResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserHwidDeviceResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDeleteUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DeleteUserResponseDto from json.
func (s *DeleteUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDto) {
					name = jsonFieldsNameOfDeleteUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDeleted")
		e.Bool(s.IsDeleted)
	}
}

var jsonFieldsNameOfDeleteUserResponseDtoResponse = [1]string{
	0: "isDeleted",
}

// Decode decodes DeleteUserResponseDtoResponse from json.
func (s *DeleteUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteUserResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDeleted":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDeleted = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeleted\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDeleteUserResponseDtoResponse) {
					name = jsonFieldsNameOfDeleteUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableNodeResponseDto from json.
func (s *DisableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDto) {
					name = jsonFieldsNameOfDisableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes DisableNodeResponseDtoResponse from json.
func (s *DisableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes DisableNodeResponseDtoResponseConfigProfile from json.
func (s *DisableNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfDisableNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes DisableNodeResponseDtoResponseProvider from json.
func (s *DisableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfDisableNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes DisableUserResponseDto from json.
func (s *DisableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDto) {
					name = jsonFieldsNameOfDisableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes DisableUserResponseDtoResponse from json.
func (s *DisableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]DisableUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DisableUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponse) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes DisableUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes DisableUserResponseDtoResponseHapp from json.
func (s *DisableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DisableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (s *DisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DisableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfDisableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (s DisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (s *DisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseStatus(v) {
	case DisableUserResponseDtoResponseStatusACTIVE:
		*s = DisableUserResponseDtoResponseStatusACTIVE
	case DisableUserResponseDtoResponseStatusDISABLED:
		*s = DisableUserResponseDtoResponseStatusDISABLED
	case DisableUserResponseDtoResponseStatusLIMITED:
		*s = DisableUserResponseDtoResponseStatusLIMITED
	case DisableUserResponseDtoResponseStatusEXPIRED:
		*s = DisableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = DisableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DisableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case DisableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case DisableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyDAY
	case DisableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case DisableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = DisableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableNodeResponseDto from json.
func (s *EnableNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDto) {
					name = jsonFieldsNameOfEnableNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes EnableNodeResponseDtoResponse from json.
func (s *EnableNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponse) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes EnableNodeResponseDtoResponseConfigProfile from json.
func (s *EnableNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfEnableNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes EnableNodeResponseDtoResponseProvider from json.
func (s *EnableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfEnableNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes EnableUserResponseDto from json.
func (s *EnableUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDto) {
					name = jsonFieldsNameOfEnableUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes EnableUserResponseDtoResponse from json.
func (s *EnableUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]EnableUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EnableUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponse) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes EnableUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes EnableUserResponseDtoResponseHapp from json.
func (s *EnableUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EnableUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (s *EnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EnableUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfEnableUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (s EnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (s *EnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseStatus(v) {
	case EnableUserResponseDtoResponseStatusACTIVE:
		*s = EnableUserResponseDtoResponseStatusACTIVE
	case EnableUserResponseDtoResponseStatusDISABLED:
		*s = EnableUserResponseDtoResponseStatusDISABLED
	case EnableUserResponseDtoResponseStatusLIMITED:
		*s = EnableUserResponseDtoResponseStatusLIMITED
	case EnableUserResponseDtoResponseStatusEXPIRED:
		*s = EnableUserResponseDtoResponseStatusEXPIRED
	default:
		*s = EnableUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch EnableUserResponseDtoResponseTrafficLimitStrategy(v) {
	case EnableUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyNORESET
	case EnableUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyDAY
	case EnableUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyWEEK
	case EnableUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = EnableUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptHappCryptoLinkRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptHappCryptoLinkRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("linkToEncrypt")
		json.EncodeURI(e, s.LinkToEncrypt)
	}
}

var jsonFieldsNameOfEncryptHappCryptoLinkRequestDto = [1]string{
	0: "linkToEncrypt",
}

// Decode decodes EncryptHappCryptoLinkRequestDto from json.
func (s *EncryptHappCryptoLinkRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptHappCryptoLinkRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "linkToEncrypt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.LinkToEncrypt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"linkToEncrypt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptHappCryptoLinkRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptHappCryptoLinkRequestDto) {
					name = jsonFieldsNameOfEncryptHappCryptoLinkRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptHappCryptoLinkRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptHappCryptoLinkRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptHappCryptoLinkResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptHappCryptoLinkResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfEncryptHappCryptoLinkResponseDto = [1]string{
	0: "response",
}

// Decode decodes EncryptHappCryptoLinkResponseDto from json.
func (s *EncryptHappCryptoLinkResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptHappCryptoLinkResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptHappCryptoLinkResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptHappCryptoLinkResponseDto) {
					name = jsonFieldsNameOfEncryptHappCryptoLinkResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptHappCryptoLinkResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptHappCryptoLinkResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EncryptHappCryptoLinkResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EncryptHappCryptoLinkResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("encryptedLink")
		e.Str(s.EncryptedLink)
	}
}

var jsonFieldsNameOfEncryptHappCryptoLinkResponseDtoResponse = [1]string{
	0: "encryptedLink",
}

// Decode decodes EncryptHappCryptoLinkResponseDtoResponse from json.
func (s *EncryptHappCryptoLinkResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EncryptHappCryptoLinkResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "encryptedLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.EncryptedLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryptedLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EncryptHappCryptoLinkResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEncryptHappCryptoLinkResponseDtoResponse) {
					name = jsonFieldsNameOfEncryptHappCryptoLinkResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EncryptHappCryptoLinkResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EncryptHappCryptoLinkResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerAddUsersToExternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerAddUsersToExternalSquadBadRequest from json.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerAddUsersToExternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerAddUsersToExternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem from json.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerAddUsersToExternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerAddUsersToExternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerAddUsersToExternalSquadInternalServerError from json.
func (s *ExternalSquadControllerAddUsersToExternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerAddUsersToExternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerAddUsersToExternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerAddUsersToExternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerCreateExternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerCreateExternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerCreateExternalSquadBadRequest from json.
func (s *ExternalSquadControllerCreateExternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerCreateExternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerCreateExternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerCreateExternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem from json.
func (s *ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerCreateExternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerCreateExternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerCreateExternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerCreateExternalSquadInternalServerError from json.
func (s *ExternalSquadControllerCreateExternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerCreateExternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerCreateExternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerCreateExternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerCreateExternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerDeleteExternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerDeleteExternalSquadBadRequest from json.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerDeleteExternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerDeleteExternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem from json.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerDeleteExternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerDeleteExternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerDeleteExternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerDeleteExternalSquadInternalServerError from json.
func (s *ExternalSquadControllerDeleteExternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerDeleteExternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerDeleteExternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerDeleteExternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerDeleteExternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerGetExternalSquadByUuidBadRequest from json.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem from json.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerGetExternalSquadByUuidInternalServerError from json.
func (s *ExternalSquadControllerGetExternalSquadByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerGetExternalSquadsBadRequest from json.
func (s *ExternalSquadControllerGetExternalSquadsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadsBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem from json.
func (s *ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerGetExternalSquadsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerGetExternalSquadsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerGetExternalSquadsInternalServerError from json.
func (s *ExternalSquadControllerGetExternalSquadsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerGetExternalSquadsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerGetExternalSquadsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerGetExternalSquadsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerGetExternalSquadsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerRemoveUsersFromExternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest from json.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem from json.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError from json.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerRemoveUsersFromExternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerUpdateExternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes ExternalSquadControllerUpdateExternalSquadBadRequest from json.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerUpdateExternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerUpdateExternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem from json.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerUpdateExternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ExternalSquadControllerUpdateExternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfExternalSquadControllerUpdateExternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes ExternalSquadControllerUpdateExternalSquadInternalServerError from json.
func (s *ExternalSquadControllerUpdateExternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ExternalSquadControllerUpdateExternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ExternalSquadControllerUpdateExternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ExternalSquadControllerUpdateExternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ExternalSquadControllerUpdateExternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDto = [1]string{
	0: "response",
}

// Decode decodes FindAllApiTokensResponseDto from json.
func (s *FindAllApiTokensResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDto) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKeys")
		e.ArrStart()
		for _, elem := range s.ApiKeys {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("docs")
		s.Docs.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponse = [2]string{
	0: "apiKeys",
	1: "docs",
}

// Decode decodes FindAllApiTokensResponseDtoResponse from json.
func (s *FindAllApiTokensResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKeys":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ApiKeys = make([]FindAllApiTokensResponseDtoResponseApiKeysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem FindAllApiTokensResponseDtoResponseApiKeysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ApiKeys = append(s.ApiKeys, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeys\"")
			}
		case "docs":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Docs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"docs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponse) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("token")
		e.Str(s.Token)
	}
	{
		e.FieldStart("tokenName")
		e.Str(s.TokenName)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem = [5]string{
	0: "uuid",
	1: "token",
	2: "tokenName",
	3: "createdAt",
	4: "updatedAt",
}

// Decode decodes FindAllApiTokensResponseDtoResponseApiKeysItem from json.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseApiKeysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "token":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Token = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"token\"")
			}
		case "tokenName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TokenName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenName\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseApiKeysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseApiKeysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseApiKeysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *FindAllApiTokensResponseDtoResponseDocs) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isDocsEnabled")
		e.Bool(s.IsDocsEnabled)
	}
	{
		e.FieldStart("scalarPath")
		s.ScalarPath.Encode(e)
	}
	{
		e.FieldStart("swaggerPath")
		s.SwaggerPath.Encode(e)
	}
}

var jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs = [3]string{
	0: "isDocsEnabled",
	1: "scalarPath",
	2: "swaggerPath",
}

// Decode decodes FindAllApiTokensResponseDtoResponseDocs from json.
func (s *FindAllApiTokensResponseDtoResponseDocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode FindAllApiTokensResponseDtoResponseDocs to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isDocsEnabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsDocsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDocsEnabled\"")
			}
		case "scalarPath":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ScalarPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scalarPath\"")
			}
		case "swaggerPath":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.SwaggerPath.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"swaggerPath\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode FindAllApiTokensResponseDtoResponseDocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs) {
					name = jsonFieldsNameOfFindAllApiTokensResponseDtoResponseDocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *FindAllApiTokensResponseDtoResponseDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateX25519ResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateX25519ResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGenerateX25519ResponseDto = [1]string{
	0: "response",
}

// Decode decodes GenerateX25519ResponseDto from json.
func (s *GenerateX25519ResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateX25519ResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateX25519ResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateX25519ResponseDto) {
					name = jsonFieldsNameOfGenerateX25519ResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateX25519ResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateX25519ResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateX25519ResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateX25519ResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("keypairs")
		e.ArrStart()
		for _, elem := range s.Keypairs {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGenerateX25519ResponseDtoResponse = [1]string{
	0: "keypairs",
}

// Decode decodes GenerateX25519ResponseDtoResponse from json.
func (s *GenerateX25519ResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateX25519ResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "keypairs":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Keypairs = make([]GenerateX25519ResponseDtoResponseKeypairsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GenerateX25519ResponseDtoResponseKeypairsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Keypairs = append(s.Keypairs, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"keypairs\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateX25519ResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateX25519ResponseDtoResponse) {
					name = jsonFieldsNameOfGenerateX25519ResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateX25519ResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateX25519ResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GenerateX25519ResponseDtoResponseKeypairsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GenerateX25519ResponseDtoResponseKeypairsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("publicKey")
		e.Str(s.PublicKey)
	}
	{
		e.FieldStart("privateKey")
		e.Str(s.PrivateKey)
	}
}

var jsonFieldsNameOfGenerateX25519ResponseDtoResponseKeypairsItem = [2]string{
	0: "publicKey",
	1: "privateKey",
}

// Decode decodes GenerateX25519ResponseDtoResponseKeypairsItem from json.
func (s *GenerateX25519ResponseDtoResponseKeypairsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GenerateX25519ResponseDtoResponseKeypairsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "publicKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PublicKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "privateKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.PrivateKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privateKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GenerateX25519ResponseDtoResponseKeypairsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGenerateX25519ResponseDtoResponseKeypairsItem) {
					name = jsonFieldsNameOfGenerateX25519ResponseDtoResponseKeypairsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GenerateX25519ResponseDtoResponseKeypairsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GenerateX25519ResponseDtoResponseKeypairsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostTagsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostTagsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllHostTagsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllHostTagsResponseDto from json.
func (s *GetAllHostTagsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostTagsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostTagsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostTagsResponseDto) {
					name = jsonFieldsNameOfGetAllHostTagsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostTagsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostTagsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostTagsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostTagsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllHostTagsResponseDtoResponse = [1]string{
	0: "tags",
}

// Decode decodes GetAllHostTagsResponseDtoResponse from json.
func (s *GetAllHostTagsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostTagsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostTagsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostTagsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllHostTagsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostTagsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostTagsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllHostsResponseDto from json.
func (s *GetAllHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDto) {
					name = jsonFieldsNameOfGetAllHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes GetAllHostsResponseDtoResponseItem from json.
func (s *GetAllHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes GetAllHostsResponseDtoResponseItemInbound from json.
func (s *GetAllHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfGetAllHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllHostsResponseDtoResponseItemSecurityLayer(v) {
	case GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case GetAllHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerTLS
	case GetAllHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = GetAllHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHwidDevicesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHwidDevicesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllHwidDevicesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllHwidDevicesResponseDto from json.
func (s *GetAllHwidDevicesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHwidDevicesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHwidDevicesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHwidDevicesResponseDto) {
					name = jsonFieldsNameOfGetAllHwidDevicesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHwidDevicesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHwidDevicesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHwidDevicesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHwidDevicesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponse = [2]string{
	0: "devices",
	1: "total",
}

// Decode decodes GetAllHwidDevicesResponseDtoResponse from json.
func (s *GetAllHwidDevicesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHwidDevicesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "devices":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Devices = make([]GetAllHwidDevicesResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllHwidDevicesResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHwidDevicesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHwidDevicesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHwidDevicesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllHwidDevicesResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllHwidDevicesResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetAllHwidDevicesResponseDtoResponseDevicesItem from json.
func (s *GetAllHwidDevicesResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllHwidDevicesResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllHwidDevicesResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfGetAllHwidDevicesResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllHwidDevicesResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllHwidDevicesResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllInboundsResponseDto from json.
func (s *GetAllInboundsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDto) {
					name = jsonFieldsNameOfGetAllInboundsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDtoResponse = [2]string{
	0: "total",
	1: "inbounds",
}

// Decode decodes GetAllInboundsResponseDtoResponse from json.
func (s *GetAllInboundsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]GetAllInboundsResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllInboundsResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllInboundsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
	{
		e.FieldStart("activeSquads")
		e.ArrStart()
		for _, elem := range s.ActiveSquads {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem = [9]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
	8: "activeSquads",
}

// Decode decodes GetAllInboundsResponseDtoResponseInboundsItem from json.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllInboundsResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		case "activeSquads":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.ActiveSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveSquads = append(s.ActiveSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllInboundsResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetAllInboundsResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllInboundsResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllNodesResponseDto from json.
func (s *GetAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetAllNodesResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDto) {
					name = jsonFieldsNameOfGetAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes GetAllNodesResponseDtoResponseItem from json.
func (s *GetAllNodesResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes GetAllNodesResponseDtoResponseItemConfigProfile from json.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem from json.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllNodesResponseDtoResponseItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetAllNodesResponseDtoResponseItemProvider from json.
func (s *GetAllNodesResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllNodesResponseDtoResponseItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllNodesResponseDtoResponseItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider) {
					name = jsonFieldsNameOfGetAllNodesResponseDtoResponseItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllNodesResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllSubscriptionsResponseDto from json.
func (s *GetAllSubscriptionsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDto) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("subscriptions")
		e.ArrStart()
		for _, elem := range s.Subscriptions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse = [2]string{
	0: "subscriptions",
	1: "total",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponse from json.
func (s *GetAllSubscriptionsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "subscriptions":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Subscriptions = make([]GetAllSubscriptionsResponseDtoResponseSubscriptionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Subscriptions = append(s.Subscriptions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptions\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem = [5]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItem from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser = [9]string{
	0: "shortUuid",
	1: "daysLeft",
	2: "trafficUsed",
	3: "trafficLimit",
	4: "username",
	5: "expiresAt",
	6: "isActive",
	7: "userStatus",
	8: "trafficLimitStrategy",
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) {
					name = jsonFieldsNameOfGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyNORESET
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyDAY
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyWEEK
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategyMONTH
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus as json.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus from json.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v) {
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusACTIVE
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusDISABLED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusLIMITED
	case GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatusEXPIRED
	default:
		*s = GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllTagsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllTagsResponseDto from json.
func (s *GetAllTagsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDto) {
					name = jsonFieldsNameOfGetAllTagsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllTagsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllTagsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tags")
		e.ArrStart()
		for _, elem := range s.Tags {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetAllTagsResponseDtoResponse = [1]string{
	0: "tags",
}

// Decode decodes GetAllTagsResponseDtoResponse from json.
func (s *GetAllTagsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllTagsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllTagsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllTagsResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllTagsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllTagsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllTagsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetAllUsersResponseDto from json.
func (s *GetAllUsersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDto) {
					name = jsonFieldsNameOfGetAllUsersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("users")
		e.ArrStart()
		for _, elem := range s.Users {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponse = [2]string{
	0: "users",
	1: "total",
}

// Decode decodes GetAllUsersResponseDtoResponse from json.
func (s *GetAllUsersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "users":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Users = make([]GetAllUsersResponseDtoResponseUsersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllUsersResponseDtoResponseUsersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Users = append(s.Users, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponse) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponseUsersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItem = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItem from json.
func (s *GetAllUsersResponseDtoResponseUsersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponseUsersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItem) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem from json.
func (s *GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponseUsersItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemHapp from json.
func (s *GetAllUsersResponseDtoResponseUsersItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponseUsersItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemHapp) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetAllUsersResponseDtoResponseUsersItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemLastConnectedNode from json.
func (s *GetAllUsersResponseDtoResponseUsersItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetAllUsersResponseDtoResponseUsersItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemLastConnectedNode) {
					name = jsonFieldsNameOfGetAllUsersResponseDtoResponseUsersItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllUsersResponseDtoResponseUsersItemStatus as json.
func (s GetAllUsersResponseDtoResponseUsersItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemStatus from json.
func (s *GetAllUsersResponseDtoResponseUsersItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllUsersResponseDtoResponseUsersItemStatus(v) {
	case GetAllUsersResponseDtoResponseUsersItemStatusACTIVE:
		*s = GetAllUsersResponseDtoResponseUsersItemStatusACTIVE
	case GetAllUsersResponseDtoResponseUsersItemStatusDISABLED:
		*s = GetAllUsersResponseDtoResponseUsersItemStatusDISABLED
	case GetAllUsersResponseDtoResponseUsersItemStatusLIMITED:
		*s = GetAllUsersResponseDtoResponseUsersItemStatusLIMITED
	case GetAllUsersResponseDtoResponseUsersItemStatusEXPIRED:
		*s = GetAllUsersResponseDtoResponseUsersItemStatusEXPIRED
	default:
		*s = GetAllUsersResponseDtoResponseUsersItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllUsersResponseDtoResponseUsersItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy as json.
func (s GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy from json.
func (s *GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy(v) {
	case GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyNORESET:
		*s = GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyNORESET
	case GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyDAY:
		*s = GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyDAY
	case GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyWEEK:
		*s = GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyWEEK
	case GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyMONTH:
		*s = GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategyMONTH
	default:
		*s = GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetBandwidthStatsResponseDto from json.
func (s *GetBandwidthStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDto) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("bandwidthLastTwoDays")
		s.BandwidthLastTwoDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLastSevenDays")
		s.BandwidthLastSevenDays.Encode(e)
	}
	{
		e.FieldStart("bandwidthLast30Days")
		s.BandwidthLast30Days.Encode(e)
	}
	{
		e.FieldStart("bandwidthCalendarMonth")
		s.BandwidthCalendarMonth.Encode(e)
	}
	{
		e.FieldStart("bandwidthCurrentYear")
		s.BandwidthCurrentYear.Encode(e)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse = [5]string{
	0: "bandwidthLastTwoDays",
	1: "bandwidthLastSevenDays",
	2: "bandwidthLast30Days",
	3: "bandwidthCalendarMonth",
	4: "bandwidthCurrentYear",
}

// Decode decodes GetBandwidthStatsResponseDtoResponse from json.
func (s *GetBandwidthStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "bandwidthLastTwoDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.BandwidthLastTwoDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastTwoDays\"")
			}
		case "bandwidthLastSevenDays":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BandwidthLastSevenDays.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLastSevenDays\"")
			}
		case "bandwidthLast30Days":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.BandwidthLast30Days.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthLast30Days\"")
			}
		case "bandwidthCalendarMonth":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.BandwidthCalendarMonth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCalendarMonth\"")
			}
		case "bandwidthCurrentYear":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BandwidthCurrentYear.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bandwidthCurrentYear\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLast30Days from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLast30Days")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLast30Days[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLast30Days) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("current")
		e.Str(s.Current)
	}
	{
		e.FieldStart("previous")
		e.Str(s.Previous)
	}
	{
		e.FieldStart("difference")
		e.Str(s.Difference)
	}
}

var jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays = [3]string{
	0: "current",
	1: "previous",
	2: "difference",
}

// Decode decodes GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays from json.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "current":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Current = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"current\"")
			}
		case "previous":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Previous = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"previous\"")
			}
		case "difference":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Difference = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"difference\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) {
					name = jsonFieldsNameOfGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetConfigProfileByUuidResponseDto from json.
func (s *GetConfigProfileByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDto) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponse from json.
func (s *GetConfigProfileByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetConfigProfileByUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfileByUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]GetConfigProfileByUuidResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfileByUuidResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponseInboundsItem from json.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetConfigProfileByUuidResponseDtoResponseNodesItem from json.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfileByUuidResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfileByUuidResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfGetConfigProfileByUuidResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfileByUuidResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetConfigProfilesResponseDto from json.
func (s *GetConfigProfilesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDto) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("configProfiles")
		e.ArrStart()
		for _, elem := range s.ConfigProfiles {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponse = [2]string{
	0: "total",
	1: "configProfiles",
}

// Decode decodes GetConfigProfilesResponseDtoResponse from json.
func (s *GetConfigProfilesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "configProfiles":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ConfigProfiles = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ConfigProfiles = append(s.ConfigProfiles, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfiles\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponse) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem from json.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) {
					name = jsonFieldsNameOfGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetExternalSquadByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetExternalSquadByUuidResponseDto from json.
func (s *GetExternalSquadByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadByUuidResponseDto) {
					name = jsonFieldsNameOfGetExternalSquadByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionSettings")
		s.SubscriptionSettings.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "templates",
	4: "subscriptionSettings",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponse from json.
func (s *GetExternalSquadByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "templates":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Templates = make([]GetExternalSquadByUuidResponseDtoResponseTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetExternalSquadByUuidResponseDtoResponseTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "subscriptionSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SubscriptionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionSettings\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadByUuidResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
}

var jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseInfo = [1]string{
	0: "membersCount",
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponseInfo from json.
func (s *GetExternalSquadByUuidResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadByUuidResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseInfo) {
					name = jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings = [10]string{
	0: "profileTitle",
	1: "supportLink",
	2: "profileUpdateInterval",
	3: "isProfileWebpageUrlEnabled",
	4: "serveJsonAtBaseSubscription",
	5: "addUsernameToBaseSubscription",
	6: "isShowCustomRemarks",
	7: "happAnnounce",
	8: "happRouting",
	9: "randomizeHosts",
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings from json.
func (s *GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateUuid")
		json.EncodeUUID(e, s.TemplateUuid)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseTemplatesItem = [2]string{
	0: "templateUuid",
	1: "templateType",
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponseTemplatesItem from json.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDtoResponseTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateUuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadByUuidResponseDtoResponseTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseTemplatesItem) {
					name = jsonFieldsNameOfGetExternalSquadByUuidResponseDtoResponseTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType as json.
func (s GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType from json.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType(v) {
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeMIHOMO:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeMIHOMO
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeSTASH:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeSTASH
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeCLASH:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeCLASH
	case GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeSINGBOX:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateTypeSINGBOX
	default:
		*s = GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadByUuidResponseDtoResponseTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetExternalSquadsResponseDto from json.
func (s *GetExternalSquadsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadsResponseDto) {
					name = jsonFieldsNameOfGetExternalSquadsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("externalSquads")
		e.ArrStart()
		for _, elem := range s.ExternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDtoResponse = [2]string{
	0: "total",
	1: "externalSquads",
}

// Decode decodes GetExternalSquadsResponseDtoResponse from json.
func (s *GetExternalSquadsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "externalSquads":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ExternalSquads = make([]GetExternalSquadsResponseDtoResponseExternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetExternalSquadsResponseDtoResponseExternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ExternalSquads = append(s.ExternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadsResponseDtoResponse) {
					name = jsonFieldsNameOfGetExternalSquadsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionSettings")
		s.SubscriptionSettings.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItem = [7]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "templates",
	4: "subscriptionSettings",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItem from json.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponseExternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "templates":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Templates = make([]GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "subscriptionSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SubscriptionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionSettings\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDtoResponseExternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItem) {
					name = jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemInfo = [1]string{
	0: "membersCount",
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo from json.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) {
					name = jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings = [10]string{
	0: "profileTitle",
	1: "supportLink",
	2: "profileUpdateInterval",
	3: "isProfileWebpageUrlEnabled",
	4: "serveJsonAtBaseSubscription",
	5: "addUsernameToBaseSubscription",
	6: "isShowCustomRemarks",
	7: "happAnnounce",
	8: "happRouting",
	9: "randomizeHosts",
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings from json.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateUuid")
		json.EncodeUUID(e, s.TemplateUuid)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem = [2]string{
	0: "templateUuid",
	1: "templateType",
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem from json.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateUuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) {
					name = jsonFieldsNameOfGetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType as json.
func (s GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType from json.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType(v) {
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeXRAYJSON:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeXRAYJSON
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeXRAYBASE64:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeXRAYBASE64
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeMIHOMO:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeMIHOMO
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeSTASH:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeSTASH
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeCLASH:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeCLASH
	case GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeSINGBOX:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateTypeSINGBOX
	default:
		*s = GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHwidDevicesStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHwidDevicesStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetHwidDevicesStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetHwidDevicesStatsResponseDto from json.
func (s *GetHwidDevicesStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHwidDevicesStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHwidDevicesStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHwidDevicesStatsResponseDto) {
					name = jsonFieldsNameOfGetHwidDevicesStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHwidDevicesStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHwidDevicesStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHwidDevicesStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("byPlatform")
		e.ArrStart()
		for _, elem := range s.ByPlatform {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("byApp")
		e.ArrStart()
		for _, elem := range s.ByApp {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponse = [3]string{
	0: "byPlatform",
	1: "byApp",
	2: "stats",
}

// Decode decodes GetHwidDevicesStatsResponseDtoResponse from json.
func (s *GetHwidDevicesStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHwidDevicesStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "byPlatform":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ByPlatform = make([]GetHwidDevicesStatsResponseDtoResponseByPlatformItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetHwidDevicesStatsResponseDtoResponseByPlatformItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ByPlatform = append(s.ByPlatform, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"byPlatform\"")
			}
		case "byApp":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ByApp = make([]GetHwidDevicesStatsResponseDtoResponseByAppItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetHwidDevicesStatsResponseDtoResponseByAppItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ByApp = append(s.ByApp, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"byApp\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHwidDevicesStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHwidDevicesStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByAppItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHwidDevicesStatsResponseDtoResponseByAppItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("app")
		e.Str(s.App)
	}
	{
		e.FieldStart("count")
		e.Float64(s.Count)
	}
}

var jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByAppItem = [2]string{
	0: "app",
	1: "count",
}

// Decode decodes GetHwidDevicesStatsResponseDtoResponseByAppItem from json.
func (s *GetHwidDevicesStatsResponseDtoResponseByAppItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHwidDevicesStatsResponseDtoResponseByAppItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.App = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Count = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHwidDevicesStatsResponseDtoResponseByAppItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByAppItem) {
					name = jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByAppItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByAppItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByAppItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByPlatformItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHwidDevicesStatsResponseDtoResponseByPlatformItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("platform")
		e.Str(s.Platform)
	}
	{
		e.FieldStart("count")
		e.Float64(s.Count)
	}
}

var jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByPlatformItem = [2]string{
	0: "platform",
	1: "count",
}

// Decode decodes GetHwidDevicesStatsResponseDtoResponseByPlatformItem from json.
func (s *GetHwidDevicesStatsResponseDtoResponseByPlatformItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHwidDevicesStatsResponseDtoResponseByPlatformItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "platform":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Platform = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Count = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHwidDevicesStatsResponseDtoResponseByPlatformItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByPlatformItem) {
					name = jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseByPlatformItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByPlatformItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseByPlatformItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetHwidDevicesStatsResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalUniqueDevices")
		e.Float64(s.TotalUniqueDevices)
	}
	{
		e.FieldStart("totalHwidDevices")
		e.Float64(s.TotalHwidDevices)
	}
	{
		e.FieldStart("averageHwidDevicesPerUser")
		e.Float64(s.AverageHwidDevicesPerUser)
	}
}

var jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseStats = [3]string{
	0: "totalUniqueDevices",
	1: "totalHwidDevices",
	2: "averageHwidDevicesPerUser",
}

// Decode decodes GetHwidDevicesStatsResponseDtoResponseStats from json.
func (s *GetHwidDevicesStatsResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetHwidDevicesStatsResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalUniqueDevices":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalUniqueDevices = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUniqueDevices\"")
			}
		case "totalHwidDevices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalHwidDevices = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalHwidDevices\"")
			}
		case "averageHwidDevicesPerUser":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.AverageHwidDevicesPerUser = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"averageHwidDevicesPerUser\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetHwidDevicesStatsResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseStats) {
					name = jsonFieldsNameOfGetHwidDevicesStatsResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetHwidDevicesStatsResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInboundsByProfileUuidResponseDto from json.
func (s *GetInboundsByProfileUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDto) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse = [2]string{
	0: "total",
	1: "inbounds",
}

// Decode decodes GetInboundsByProfileUuidResponseDtoResponse from json.
func (s *GetInboundsByProfileUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Inbounds = make([]GetInboundsByProfileUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInboundsByProfileUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
	{
		e.FieldStart("activeSquads")
		e.ArrStart()
		for _, elem := range s.ActiveSquads {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem = [9]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
	8: "activeSquads",
}

// Decode decodes GetInboundsByProfileUuidResponseDtoResponseInboundsItem from json.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInboundsByProfileUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		case "activeSquads":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				s.ActiveSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveSquads = append(s.ActiveSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInboundsByProfileUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetInboundsByProfileUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInboundsByProfileUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDto from json.
func (s *GetInfraBillingHistoryRecordsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponse from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("amount")
		e.Float64(s.Amount)
	}
	{
		e.FieldStart("billedAt")
		json.EncodeDateTime(e, s.BilledAt)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem = [5]string{
	0: "uuid",
	1: "providerUuid",
	2: "amount",
	3: "billedAt",
	4: "provider",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "amount":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Amount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"amount\"")
			}
		case "billedAt":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.BilledAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billedAt\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider = [3]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
}

// Decode decodes GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider from json.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) {
					name = jsonFieldsNameOfGetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingHistoryRecordsResponseDtoResponseRecordsItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraBillingNodesResponseDto from json.
func (s *GetInfraBillingNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDto) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponse from json.
func (s *GetInfraBillingNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]GetInfraBillingNodesResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingNodesResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem from json.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItem from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider from json.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraBillingNodesResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes GetInfraBillingNodesResponseDtoResponseStats from json.
func (s *GetInfraBillingNodesResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraBillingNodesResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraBillingNodesResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats) {
					name = jsonFieldsNameOfGetInfraBillingNodesResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraBillingNodesResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraProviderByUuidResponseDto from json.
func (s *GetInfraProviderByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDto) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponse from json.
func (s *GetInfraProviderByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]GetInfraProviderByUuidResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProviderByUuidResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponseBillingHistory from json.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraProviderByUuidResponseDtoResponseBillingNodesItem from json.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProviderByUuidResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProviderByUuidResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraProviderByUuidResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProviderByUuidResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInfraProvidersResponseDto from json.
func (s *GetInfraProvidersResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDto) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("providers")
		e.ArrStart()
		for _, elem := range s.Providers {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponse = [2]string{
	0: "total",
	1: "providers",
}

// Decode decodes GetInfraProvidersResponseDtoResponse from json.
func (s *GetInfraProvidersResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "providers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Providers = make([]GetInfraProvidersResponseDtoResponseProvidersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProvidersResponseDtoResponseProvidersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Providers = append(s.Providers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providers\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponse) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItem from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem from json.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) {
					name = jsonFieldsNameOfGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadAccessibleNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInternalSquadAccessibleNodesResponseDto from json.
func (s *GetInternalSquadAccessibleNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadAccessibleNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadAccessibleNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDto) {
					name = jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadAccessibleNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("squadUuid")
		json.EncodeUUID(e, s.SquadUuid)
	}
	{
		e.FieldStart("accessibleNodes")
		e.ArrStart()
		for _, elem := range s.AccessibleNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponse = [2]string{
	0: "squadUuid",
	1: "accessibleNodes",
}

// Decode decodes GetInternalSquadAccessibleNodesResponseDtoResponse from json.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadAccessibleNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "squadUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.SquadUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"squadUuid\"")
			}
		case "accessibleNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.AccessibleNodes = make([]GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AccessibleNodes = append(s.AccessibleNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"accessibleNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadAccessibleNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponse) {
					name = jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileName")
		e.Str(s.ConfigProfileName)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem = [6]string{
	0: "uuid",
	1: "nodeName",
	2: "countryCode",
	3: "configProfileUuid",
	4: "configProfileName",
	5: "activeInbounds",
}

// Decode decodes GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem from json.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ConfigProfileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileName\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.ActiveInbounds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) {
					name = jsonFieldsNameOfGetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInternalSquadByUuidResponseDto from json.
func (s *GetInternalSquadByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDto) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponse from json.
func (s *GetInternalSquadByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetInternalSquadByUuidResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadByUuidResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponseInboundsItem from json.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes GetInternalSquadByUuidResponseDtoResponseInfo from json.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadByUuidResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadByUuidResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo) {
					name = jsonFieldsNameOfGetInternalSquadByUuidResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadByUuidResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetInternalSquadsResponseDto from json.
func (s *GetInternalSquadsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDto) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("internalSquads")
		e.ArrStart()
		for _, elem := range s.InternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponse = [2]string{
	0: "total",
	1: "internalSquads",
}

// Decode decodes GetInternalSquadsResponseDtoResponse from json.
func (s *GetInternalSquadsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "internalSquads":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.InternalSquads = make([]GetInternalSquadsResponseDtoResponseInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadsResponseDtoResponseInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InternalSquads = append(s.InternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"internalSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponse) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItem from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo from json.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) {
					name = jsonFieldsNameOfGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodeUserUsageByRangeResponseDto from json.
func (s *GetNodeUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodeUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodeUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem = [5]string{
	0: "userUuid",
	1: "username",
	2: "nodeUuid",
	3: "total",
	4: "date",
}

// Decode decodes GetNodeUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodeUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodeUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodeUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodeUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesMetricsResponseDto from json.
func (s *GetNodesMetricsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDto) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponse = [1]string{
	0: "nodes",
}

// Decode decodes GetNodesMetricsResponseDtoResponse from json.
func (s *GetNodesMetricsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]GetNodesMetricsResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponse) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		e.Str(s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryEmoji")
		e.Str(s.CountryEmoji)
	}
	{
		e.FieldStart("providerName")
		e.Str(s.ProviderName)
	}
	{
		e.FieldStart("usersOnline")
		e.Float64(s.UsersOnline)
	}
	{
		e.FieldStart("inboundsStats")
		e.ArrStart()
		for _, elem := range s.InboundsStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("outboundsStats")
		e.ArrStart()
		for _, elem := range s.OutboundsStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem = [7]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "countryEmoji",
	3: "providerName",
	4: "usersOnline",
	5: "inboundsStats",
	6: "outboundsStats",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryEmoji":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryEmoji = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryEmoji\"")
			}
		case "providerName":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ProviderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerName\"")
			}
		case "usersOnline":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsersOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "inboundsStats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.InboundsStats = make([]GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.InboundsStats = append(s.InboundsStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsStats\"")
			}
		case "outboundsStats":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				s.OutboundsStats = make([]GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OutboundsStats = append(s.OutboundsStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"outboundsStats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("upload")
		e.Str(s.Upload)
	}
	{
		e.FieldStart("download")
		e.Str(s.Download)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem = [3]string{
	0: "tag",
	1: "upload",
	2: "download",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "upload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Upload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload\"")
			}
		case "download":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Download = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("upload")
		e.Str(s.Upload)
	}
	{
		e.FieldStart("download")
		e.Str(s.Download)
	}
}

var jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem = [3]string{
	0: "tag",
	1: "upload",
	2: "download",
}

// Decode decodes GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem from json.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tag":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "upload":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Upload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upload\"")
			}
		case "download":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Download = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"download\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) {
					name = jsonFieldsNameOfGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesRealtimeUsageResponseDto from json.
func (s *GetNodesRealtimeUsageResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesRealtimeUsageResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesRealtimeUsageResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDto) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("downloadBytes")
		e.Float64(s.DownloadBytes)
	}
	{
		e.FieldStart("uploadBytes")
		e.Float64(s.UploadBytes)
	}
	{
		e.FieldStart("totalBytes")
		e.Float64(s.TotalBytes)
	}
	{
		e.FieldStart("downloadSpeedBps")
		e.Float64(s.DownloadSpeedBps)
	}
	{
		e.FieldStart("uploadSpeedBps")
		e.Float64(s.UploadSpeedBps)
	}
	{
		e.FieldStart("totalSpeedBps")
		e.Float64(s.TotalSpeedBps)
	}
}

var jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem = [9]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "countryCode",
	3: "downloadBytes",
	4: "uploadBytes",
	5: "totalBytes",
	6: "downloadSpeedBps",
	7: "uploadSpeedBps",
	8: "totalSpeedBps",
}

// Decode decodes GetNodesRealtimeUsageResponseDtoResponseItem from json.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesRealtimeUsageResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "downloadBytes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.DownloadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadBytes\"")
			}
		case "uploadBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UploadBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadBytes\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.TotalBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		case "downloadSpeedBps":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.DownloadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"downloadSpeedBps\"")
			}
		case "uploadSpeedBps":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Float64()
				s.UploadSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uploadSpeedBps\"")
			}
		case "totalSpeedBps":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpeedBps = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpeedBps\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesRealtimeUsageResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesRealtimeUsageResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesRealtimeUsageResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesStatisticsResponseDto from json.
func (s *GetNodesStatisticsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDto) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastSevenDays")
		e.ArrStart()
		for _, elem := range s.LastSevenDays {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse = [1]string{
	0: "lastSevenDays",
}

// Decode decodes GetNodesStatisticsResponseDtoResponse from json.
func (s *GetNodesStatisticsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastSevenDays":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.LastSevenDays = make([]GetNodesStatisticsResponseDtoResponseLastSevenDaysItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.LastSevenDays = append(s.LastSevenDays, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastSevenDays\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
	{
		e.FieldStart("totalBytes")
		e.Str(s.TotalBytes)
	}
}

var jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem = [3]string{
	0: "nodeName",
	1: "date",
	2: "totalBytes",
}

// Decode decodes GetNodesStatisticsResponseDtoResponseLastSevenDaysItem from json.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		case "totalBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesStatisticsResponseDtoResponseLastSevenDaysItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem) {
					name = jsonFieldsNameOfGetNodesStatisticsResponseDtoResponseLastSevenDaysItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesStatisticsResponseDtoResponseLastSevenDaysItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetNodesUsageByRangeResponseDto from json.
func (s *GetNodesUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetNodesUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetNodesUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("nodeCountryCode")
		e.Str(s.NodeCountryCode)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("totalDownload")
		e.Float64(s.TotalDownload)
	}
	{
		e.FieldStart("totalUpload")
		e.Float64(s.TotalUpload)
	}
	{
		e.FieldStart("humanReadableTotal")
		e.Str(s.HumanReadableTotal)
	}
	{
		e.FieldStart("humanReadableTotalDownload")
		e.Str(s.HumanReadableTotalDownload)
	}
	{
		e.FieldStart("humanReadableTotalUpload")
		e.Str(s.HumanReadableTotalUpload)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem = [10]string{
	0: "nodeUuid",
	1: "nodeName",
	2: "nodeCountryCode",
	3: "total",
	4: "totalDownload",
	5: "totalUpload",
	6: "humanReadableTotal",
	7: "humanReadableTotalDownload",
	8: "humanReadableTotalUpload",
	9: "date",
}

// Decode decodes GetNodesUsageByRangeResponseDtoResponseItem from json.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetNodesUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "nodeCountryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeCountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeCountryCode\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "totalDownload":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.TotalDownload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalDownload\"")
			}
		case "totalUpload":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.TotalUpload = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUpload\"")
			}
		case "humanReadableTotal":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotal = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotal\"")
			}
		case "humanReadableTotalDownload":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalDownload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalDownload\"")
			}
		case "humanReadableTotalUpload":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HumanReadableTotalUpload = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"humanReadableTotalUpload\"")
			}
		case "date":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetNodesUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetNodesUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetNodesUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneHostResponseDto from json.
func (s *GetOneHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDto) {
					name = jsonFieldsNameOfGetOneHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetOneHostResponseDtoResponse = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes GetOneHostResponseDtoResponse from json.
func (s *GetOneHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfGetOneHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes GetOneHostResponseDtoResponseInbound from json.
func (s *GetOneHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfGetOneHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (s GetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (s *GetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetOneHostResponseDtoResponseSecurityLayer(v) {
	case GetOneHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = GetOneHostResponseDtoResponseSecurityLayerDEFAULT
	case GetOneHostResponseDtoResponseSecurityLayerTLS:
		*s = GetOneHostResponseDtoResponseSecurityLayerTLS
	case GetOneHostResponseDtoResponseSecurityLayerNONE:
		*s = GetOneHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = GetOneHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetOneNodeResponseDto from json.
func (s *GetOneNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDto) {
					name = jsonFieldsNameOfGetOneNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes GetOneNodeResponseDtoResponse from json.
func (s *GetOneNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponse) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes GetOneNodeResponseDtoResponseConfigProfile from json.
func (s *GetOneNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetOneNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetOneNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes GetOneNodeResponseDtoResponseProvider from json.
func (s *GetOneNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetOneNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetOneNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfGetOneNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetOneNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetOneNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetPubKeyResponseDto from json.
func (s *GetPubKeyResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDto) {
					name = jsonFieldsNameOfGetPubKeyResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetPubKeyResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetPubKeyResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pubKey")
		e.Str(s.PubKey)
	}
}

var jsonFieldsNameOfGetPubKeyResponseDtoResponse = [1]string{
	0: "pubKey",
}

// Decode decodes GetPubKeyResponseDtoResponse from json.
func (s *GetPubKeyResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetPubKeyResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pubKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PubKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pubKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetPubKeyResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetPubKeyResponseDtoResponse) {
					name = jsonFieldsNameOfGetPubKeyResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetPubKeyResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetPubKeyResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDto from json.
func (s *GetRawSubscriptionByShortUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("convertedUserInfo")
		s.ConvertedUserInfo.Encode(e)
	}
	{
		e.FieldStart("headers")
		s.Headers.Encode(e)
	}
	{
		e.FieldStart("rawHosts")
		e.ArrStart()
		for _, elem := range s.RawHosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse = [4]string{
	0: "user",
	1: "convertedUserInfo",
	2: "headers",
	3: "rawHosts",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponse from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "user":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "convertedUserInfo":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConvertedUserInfo.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"convertedUserInfo\"")
			}
		case "headers":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "rawHosts":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.RawHosts = make([]GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.RawHosts = append(s.RawHosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("lifetimeTrafficUsed")
		e.Str(s.LifetimeTrafficUsed)
	}
	{
		e.FieldStart("isHwidLimited")
		e.Bool(s.IsHwidLimited)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo = [5]string{
	0: "daysLeft",
	1: "trafficLimit",
	2: "trafficUsed",
	3: "lifetimeTrafficUsed",
	4: "isHwidLimited",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "daysLeft":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "lifetimeTrafficUsed":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsed\"")
			}
		case "isHwidLimited":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsHwidLimited = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHwidLimited\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseHeaders from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) encodeFields(e *jx.Encoder) {
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Network.Set {
			e.FieldStart("network")
			s.Network.Encode(e)
		}
	}
	{
		e.FieldStart("password")
		s.Password.Encode(e)
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.PublicKey.Set {
			e.FieldStart("publicKey")
			s.PublicKey.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Protocol.Set {
			e.FieldStart("protocol")
			s.Protocol.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.ShortId.Set {
			e.FieldStart("shortId")
			s.ShortId.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.SpiderX.Set {
			e.FieldStart("spiderX")
			s.SpiderX.Encode(e)
		}
	}
	{
		if s.TLS.Set {
			e.FieldStart("tls")
			s.TLS.Encode(e)
		}
	}
	{
		if s.HeaderType.Set {
			e.FieldStart("headerType")
			s.HeaderType.Encode(e)
		}
	}
	{
		if s.AdditionalParams.Set {
			e.FieldStart("additionalParams")
			s.AdditionalParams.Encode(e)
		}
	}
	{
		if s.XHttpExtraParams.Set {
			e.FieldStart("xHttpExtraParams")
			s.XHttpExtraParams.Encode(e)
		}
	}
	{
		if s.MuxParams.Set {
			e.FieldStart("muxParams")
			s.MuxParams.Encode(e)
		}
	}
	{
		if s.SockoptParams.Set {
			e.FieldStart("sockoptParams")
			s.SockoptParams.Encode(e)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
	{
		if s.Flow.Set {
			e.FieldStart("flow")
			s.Flow.Encode(e)
		}
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.ShuffleHost.Set {
			e.FieldStart("shuffleHost")
			s.ShuffleHost.Encode(e)
		}
	}
	{
		if s.MihomoX25519.Set {
			e.FieldStart("mihomoX25519")
			s.MihomoX25519.Encode(e)
		}
	}
	{
		if s.Mldsa65Verify.Set {
			e.FieldStart("mldsa65Verify")
			s.Mldsa65Verify.Encode(e)
		}
	}
	{
		if s.Encryption.Set {
			e.FieldStart("encryption")
			s.Encryption.Encode(e)
		}
	}
	{
		if s.ProtocolOptions.Set {
			e.FieldStart("protocolOptions")
			s.ProtocolOptions.Encode(e)
		}
	}
	{
		if s.DbData.Set {
			e.FieldStart("dbData")
			s.DbData.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem = [29]string{
	0:  "address",
	1:  "alpn",
	2:  "fingerprint",
	3:  "host",
	4:  "network",
	5:  "password",
	6:  "path",
	7:  "publicKey",
	8:  "port",
	9:  "protocol",
	10: "remark",
	11: "shortId",
	12: "sni",
	13: "spiderX",
	14: "tls",
	15: "headerType",
	16: "additionalParams",
	17: "xHttpExtraParams",
	18: "muxParams",
	19: "sockoptParams",
	20: "serverDescription",
	21: "flow",
	22: "allowInsecure",
	23: "shuffleHost",
	24: "mihomoX25519",
	25: "mldsa65Verify",
	26: "encryption",
	27: "protocolOptions",
	28: "dbData",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "network":
			if err := func() error {
				s.Network.Reset()
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "publicKey":
			if err := func() error {
				s.PublicKey.Reset()
				if err := s.PublicKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"publicKey\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "protocol":
			if err := func() error {
				s.Protocol.Reset()
				if err := s.Protocol.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocol\"")
			}
		case "remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "shortId":
			if err := func() error {
				s.ShortId.Reset()
				if err := s.ShortId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortId\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "spiderX":
			if err := func() error {
				s.SpiderX.Reset()
				if err := s.SpiderX.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"spiderX\"")
			}
		case "tls":
			if err := func() error {
				s.TLS.Reset()
				if err := s.TLS.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tls\"")
			}
		case "headerType":
			if err := func() error {
				s.HeaderType.Reset()
				if err := s.HeaderType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerType\"")
			}
		case "additionalParams":
			if err := func() error {
				s.AdditionalParams.Reset()
				if err := s.AdditionalParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalParams\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				s.XHttpExtraParams.Reset()
				if err := s.XHttpExtraParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			if err := func() error {
				s.MuxParams.Reset()
				if err := s.MuxParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			if err := func() error {
				s.SockoptParams.Reset()
				if err := s.SockoptParams.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "flow":
			if err := func() error {
				s.Flow.Reset()
				if err := s.Flow.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flow\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			if err := func() error {
				s.ShuffleHost.Reset()
				if err := s.ShuffleHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			if err := func() error {
				s.MihomoX25519.Reset()
				if err := s.MihomoX25519.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "mldsa65Verify":
			if err := func() error {
				s.Mldsa65Verify.Reset()
				if err := s.Mldsa65Verify.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mldsa65Verify\"")
			}
		case "encryption":
			if err := func() error {
				s.Encryption.Reset()
				if err := s.Encryption.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encryption\"")
			}
		case "protocolOptions":
			if err := func() error {
				s.ProtocolOptions.Reset()
				if err := s.ProtocolOptions.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"protocolOptions\"")
			}
		case "dbData":
			if err := func() error {
				s.DbData.Reset()
				if err := s.DbData.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dbData\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00100000,
		0b00000000,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) encodeFields(e *jx.Encoder) {
	{
		if s.Mode.Set {
			e.FieldStart("mode")
			s.Mode.Encode(e)
		}
	}
	{
		if s.HeartbeatPeriod.Set {
			e.FieldStart("heartbeatPeriod")
			s.HeartbeatPeriod.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams = [2]string{
	0: "mode",
	1: "heartbeatPeriod",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "mode":
			if err := func() error {
				s.Mode.Reset()
				if err := s.Mode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mode\"")
			}
		case "heartbeatPeriod":
			if err := func() error {
				s.HeartbeatPeriod.Reset()
				if err := s.HeartbeatPeriod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"heartbeatPeriod\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rawInbound")
		if s.RawInbound == nil {
			e.Null()
		} else {
			s.RawInbound.Encode(e)
		}
	}
	{
		e.FieldStart("inboundTag")
		e.Str(s.InboundTag)
	}
	{
		e.FieldStart("uuid")
		e.Str(s.UUID)
	}
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("viewPosition")
		e.Float64(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("isHidden")
		e.Bool(s.IsHidden)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData = [11]string{
	0:  "rawInbound",
	1:  "inboundTag",
	2:  "uuid",
	3:  "configProfileUuid",
	4:  "configProfileInboundUuid",
	5:  "isDisabled",
	6:  "viewPosition",
	7:  "remark",
	8:  "isHidden",
	9:  "tag",
	10: "vlessRouteId",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rawInbound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.RawInbound = nil
				var elem GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.RawInbound = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		case "inboundTag":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.InboundTag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundTag\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.UUID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ViewPosition = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "isHidden":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsHidden = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "tag":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "vlessRouteId":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound = [0]string{}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams = [0]string{}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessPassword")
		e.Str(s.VlessPassword)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword = [3]string{
	0: "ssPassword",
	1: "trojanPassword",
	2: "vlessPassword",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ssPassword":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "trojanPassword":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessPassword":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.VlessPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessPassword\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) encodeFields(e *jx.Encoder) {
	{
		if s.Ss.Set {
			e.FieldStart("ss")
			s.Ss.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions = [1]string{
	0: "ss",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ss":
			if err := func() error {
				s.Ss.Reset()
				if err := s.Ss.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ss\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) encodeFields(e *jx.Encoder) {
	{
		if s.Method.Set {
			e.FieldStart("method")
			s.Method.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs = [1]string{
	0: "method",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "method":
			if err := func() error {
				s.Method.Reset()
				if err := s.Method.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"method\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams = [0]string{}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams = [0]string{}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUser from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUser to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) {
					name = jsonFieldsNameOfGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus as json.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus(v) {
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusACTIVE:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusACTIVE
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusDISABLED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusDISABLED
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusLIMITED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusLIMITED
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusEXPIRED:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserStatusEXPIRED
	default:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetRemnawaveHealthResponseDto from json.
func (s *GetRemnawaveHealthResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDto) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("pm2Stats")
		e.ArrStart()
		for _, elem := range s.Pm2Stats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse = [1]string{
	0: "pm2Stats",
}

// Decode decodes GetRemnawaveHealthResponseDtoResponse from json.
func (s *GetRemnawaveHealthResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "pm2Stats":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Pm2Stats = make([]GetRemnawaveHealthResponseDtoResponsePm2StatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetRemnawaveHealthResponseDtoResponsePm2StatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Pm2Stats = append(s.Pm2Stats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pm2Stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("memory")
		e.Str(s.Memory)
	}
	{
		e.FieldStart("cpu")
		e.Str(s.CPU)
	}
}

var jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem = [3]string{
	0: "name",
	1: "memory",
	2: "cpu",
}

// Decode decodes GetRemnawaveHealthResponseDtoResponsePm2StatsItem from json.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveHealthResponseDtoResponsePm2StatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "memory":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Memory = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "cpu":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CPU = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveHealthResponseDtoResponsePm2StatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem) {
					name = jsonFieldsNameOfGetRemnawaveHealthResponseDtoResponsePm2StatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveHealthResponseDtoResponsePm2StatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetRemnawaveSettingsResponseDto from json.
func (s *GetRemnawaveSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDto) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("passkeySettings")
		s.PasskeySettings.Encode(e)
	}
	{
		e.FieldStart("oauth2Settings")
		s.Oauth2Settings.Encode(e)
	}
	{
		e.FieldStart("tgAuthSettings")
		s.TgAuthSettings.Encode(e)
	}
	{
		e.FieldStart("passwordSettings")
		s.PasswordSettings.Encode(e)
	}
	{
		e.FieldStart("brandingSettings")
		s.BrandingSettings.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponse = [5]string{
	0: "passkeySettings",
	1: "oauth2Settings",
	2: "tgAuthSettings",
	3: "passwordSettings",
	4: "brandingSettings",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponse from json.
func (s *GetRemnawaveSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "passkeySettings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PasskeySettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passkeySettings\"")
			}
		case "oauth2Settings":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Oauth2Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2Settings\"")
			}
		case "tgAuthSettings":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TgAuthSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgAuthSettings\"")
			}
		case "passwordSettings":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PasswordSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordSettings\"")
			}
		case "brandingSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BrandingSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brandingSettings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseBrandingSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseBrandingSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("logoUrl")
		s.LogoUrl.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseBrandingSettings = [2]string{
	0: "title",
	1: "logoUrl",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseBrandingSettings from json.
func (s *GetRemnawaveSettingsResponseDtoResponseBrandingSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseBrandingSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "logoUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LogoUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logoUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseBrandingSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseBrandingSettings) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseBrandingSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2Settings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2Settings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("github")
		s.Github.Encode(e)
	}
	{
		e.FieldStart("pocketid")
		s.Pocketid.Encode(e)
	}
	{
		e.FieldStart("yandex")
		s.Yandex.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2Settings = [3]string{
	0: "github",
	1: "pocketid",
	2: "yandex",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseOauth2Settings from json.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2Settings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseOauth2Settings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Github.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github\"")
			}
		case "pocketid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pocketid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pocketid\"")
			}
		case "yandex":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Yandex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yandex\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseOauth2Settings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2Settings) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2Settings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub from json.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("plainDomain")
		s.PlainDomain.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid = [5]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "plainDomain",
	4: "allowedEmails",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid from json.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "plainDomain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PlainDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plainDomain\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex from json.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasskeySettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponsePasskeySettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("rpId")
		s.RpId.Encode(e)
	}
	{
		e.FieldStart("origin")
		s.Origin.Encode(e)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasskeySettings = [3]string{
	0: "enabled",
	1: "rpId",
	2: "origin",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponsePasskeySettings from json.
func (s *GetRemnawaveSettingsResponseDtoResponsePasskeySettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponsePasskeySettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "rpId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RpId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rpId\"")
			}
		case "origin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Origin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponsePasskeySettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasskeySettings) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasskeySettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasswordSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponsePasswordSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasswordSettings = [1]string{
	0: "enabled",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponsePasswordSettings from json.
func (s *GetRemnawaveSettingsResponseDtoResponsePasswordSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponsePasswordSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponsePasswordSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasswordSettings) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponsePasswordSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponsePasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseTgAuthSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetRemnawaveSettingsResponseDtoResponseTgAuthSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("botToken")
		s.BotToken.Encode(e)
	}
	{
		e.FieldStart("adminIds")
		e.ArrStart()
		for _, elem := range s.AdminIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseTgAuthSettings = [3]string{
	0: "enabled",
	1: "botToken",
	2: "adminIds",
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseTgAuthSettings from json.
func (s *GetRemnawaveSettingsResponseDtoResponseTgAuthSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetRemnawaveSettingsResponseDtoResponseTgAuthSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "botToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BotToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"botToken\"")
			}
		case "adminIds":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AdminIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdminIds = append(s.AdminIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetRemnawaveSettingsResponseDtoResponseTgAuthSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseTgAuthSettings) {
					name = jsonFieldsNameOfGetRemnawaveSettingsResponseDtoResponseTgAuthSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetRemnawaveSettingsResponseDtoResponseTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSnippetsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSnippetsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSnippetsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSnippetsResponseDto from json.
func (s *GetSnippetsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSnippetsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSnippetsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSnippetsResponseDto) {
					name = jsonFieldsNameOfGetSnippetsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSnippetsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSnippetsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSnippetsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSnippetsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("snippets")
		e.ArrStart()
		for _, elem := range s.Snippets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetSnippetsResponseDtoResponse = [2]string{
	0: "total",
	1: "snippets",
}

// Decode decodes GetSnippetsResponseDtoResponse from json.
func (s *GetSnippetsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSnippetsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "snippets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippets = make([]GetSnippetsResponseDtoResponseSnippetsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSnippetsResponseDtoResponseSnippetsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippets = append(s.Snippets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSnippetsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSnippetsResponseDtoResponse) {
					name = jsonFieldsNameOfGetSnippetsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSnippetsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSnippetsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSnippetsResponseDtoResponseSnippetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSnippetsResponseDtoResponseSnippetsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Snippet) != 0 {
			e.FieldStart("snippet")
			e.Raw(s.Snippet)
		}
	}
}

var jsonFieldsNameOfGetSnippetsResponseDtoResponseSnippetsItem = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes GetSnippetsResponseDtoResponseSnippetsItem from json.
func (s *GetSnippetsResponseDtoResponseSnippetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSnippetsResponseDtoResponseSnippetsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Snippet = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSnippetsResponseDtoResponseSnippetsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSnippetsResponseDtoResponseSnippetsItem) {
					name = jsonFieldsNameOfGetSnippetsResponseDtoResponseSnippetsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSnippetsResponseDtoResponseSnippetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSnippetsResponseDtoResponseSnippetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetStatsResponseDto from json.
func (s *GetStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDto) {
					name = jsonFieldsNameOfGetStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cpu")
		s.CPU.Encode(e)
	}
	{
		e.FieldStart("memory")
		s.Memory.Encode(e)
	}
	{
		e.FieldStart("uptime")
		e.Float64(s.Uptime)
	}
	{
		e.FieldStart("timestamp")
		e.Float64(s.Timestamp)
	}
	{
		e.FieldStart("users")
		s.Users.Encode(e)
	}
	{
		e.FieldStart("onlineStats")
		s.OnlineStats.Encode(e)
	}
	{
		e.FieldStart("nodes")
		s.Nodes.Encode(e)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponse = [7]string{
	0: "cpu",
	1: "memory",
	2: "uptime",
	3: "timestamp",
	4: "users",
	5: "onlineStats",
	6: "nodes",
}

// Decode decodes GetStatsResponseDtoResponse from json.
func (s *GetStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cpu":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.CPU.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpu\"")
			}
		case "memory":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Memory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"memory\"")
			}
		case "uptime":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Uptime = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uptime\"")
			}
		case "timestamp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Timestamp = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "users":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Users.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"users\"")
			}
		case "onlineStats":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.OnlineStats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineStats\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Nodes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseCPU) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cores")
		e.Float64(s.Cores)
	}
	{
		e.FieldStart("physicalCores")
		e.Float64(s.PhysicalCores)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseCPU = [2]string{
	0: "cores",
	1: "physicalCores",
}

// Decode decodes GetStatsResponseDtoResponseCPU from json.
func (s *GetStatsResponseDtoResponseCPU) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseCPU to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cores":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Cores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cores\"")
			}
		case "physicalCores":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.PhysicalCores = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"physicalCores\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseCPU")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseCPU) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseCPU[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseCPU) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseCPU) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseMemory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("free")
		e.Float64(s.Free)
	}
	{
		e.FieldStart("used")
		e.Float64(s.Used)
	}
	{
		e.FieldStart("active")
		e.Float64(s.Active)
	}
	{
		e.FieldStart("available")
		e.Float64(s.Available)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseMemory = [5]string{
	0: "total",
	1: "free",
	2: "used",
	3: "active",
	4: "available",
}

// Decode decodes GetStatsResponseDtoResponseMemory from json.
func (s *GetStatsResponseDtoResponseMemory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseMemory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "free":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Free = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"free\"")
			}
		case "used":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.Used = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"used\"")
			}
		case "active":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.Active = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"active\"")
			}
		case "available":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Available = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"available\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseMemory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseMemory) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseMemory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseMemory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseMemory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseNodes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseNodes) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalOnline")
		e.Float64(s.TotalOnline)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseNodes = [1]string{
	0: "totalOnline",
}

// Decode decodes GetStatsResponseDtoResponseNodes from json.
func (s *GetStatsResponseDtoResponseNodes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseNodes to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalOnline":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalOnline\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseNodes")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseNodes) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseNodes[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseNodes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseNodes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseOnlineStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("lastDay")
		e.Float64(s.LastDay)
	}
	{
		e.FieldStart("lastWeek")
		e.Float64(s.LastWeek)
	}
	{
		e.FieldStart("neverOnline")
		e.Float64(s.NeverOnline)
	}
	{
		e.FieldStart("onlineNow")
		e.Float64(s.OnlineNow)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats = [4]string{
	0: "lastDay",
	1: "lastWeek",
	2: "neverOnline",
	3: "onlineNow",
}

// Decode decodes GetStatsResponseDtoResponseOnlineStats from json.
func (s *GetStatsResponseDtoResponseOnlineStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseOnlineStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "lastDay":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.LastDay = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastDay\"")
			}
		case "lastWeek":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.LastWeek = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastWeek\"")
			}
		case "neverOnline":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.NeverOnline = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"neverOnline\"")
			}
		case "onlineNow":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.OnlineNow = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineNow\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseOnlineStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseOnlineStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseOnlineStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetStatsResponseDtoResponseUsers) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("statusCounts")
		s.StatusCounts.Encode(e)
	}
	{
		e.FieldStart("totalUsers")
		e.Float64(s.TotalUsers)
	}
	{
		e.FieldStart("totalTrafficBytes")
		e.Str(s.TotalTrafficBytes)
	}
}

var jsonFieldsNameOfGetStatsResponseDtoResponseUsers = [3]string{
	0: "statusCounts",
	1: "totalUsers",
	2: "totalTrafficBytes",
}

// Decode decodes GetStatsResponseDtoResponseUsers from json.
func (s *GetStatsResponseDtoResponseUsers) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsers to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "statusCounts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.StatusCounts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCounts\"")
			}
		case "totalUsers":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalUsers = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalUsers\"")
			}
		case "totalTrafficBytes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TotalTrafficBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalTrafficBytes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsers")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetStatsResponseDtoResponseUsers) {
					name = jsonFieldsNameOfGetStatsResponseDtoResponseUsers[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetStatsResponseDtoResponseUsers) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsers) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Float64(elem)
	}
}

// Decode decodes GetStatsResponseDtoResponseUsersStatusCounts from json.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetStatsResponseDtoResponseUsersStatusCounts to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem float64
		if err := func() error {
			v, err := d.Float64()
			elem = float64(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetStatsResponseDtoResponseUsersStatusCounts")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetStatsResponseDtoResponseUsersStatusCounts) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetStatsResponseDtoResponseUsersStatusCounts) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByShortUuidProtectedResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDto from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByShortUuidProtectedResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponse = [6]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
	5: "happ",
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponse from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "happ":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByShortUuidProtectedResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("lifetimeTrafficUsed")
		e.Str(s.LifetimeTrafficUsed)
	}
	{
		e.FieldStart("trafficUsedBytes")
		e.Str(s.TrafficUsedBytes)
	}
	{
		e.FieldStart("trafficLimitBytes")
		e.Str(s.TrafficLimitBytes)
	}
	{
		e.FieldStart("lifetimeTrafficUsedBytes")
		e.Str(s.LifetimeTrafficUsedBytes)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseUser = [13]string{
	0:  "shortUuid",
	1:  "daysLeft",
	2:  "trafficUsed",
	3:  "trafficLimit",
	4:  "lifetimeTrafficUsed",
	5:  "trafficUsedBytes",
	6:  "trafficLimitBytes",
	7:  "lifetimeTrafficUsedBytes",
	8:  "username",
	9:  "expiresAt",
	10: "isActive",
	11: "userStatus",
	12: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponseUser from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "lifetimeTrafficUsed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsed\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimitBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "lifetimeTrafficUsedBytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsedBytes\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByShortUuidProtectedResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionByShortUuidProtectedResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByShortUuidProtectedResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionByUsernameResponseDto from json.
func (s *GetSubscriptionByUsernameResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse = [6]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
	5: "happ",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponse from json.
func (s *GetSubscriptionByUsernameResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "happ":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseHapp from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("lifetimeTrafficUsed")
		e.Str(s.LifetimeTrafficUsed)
	}
	{
		e.FieldStart("trafficUsedBytes")
		e.Str(s.TrafficUsedBytes)
	}
	{
		e.FieldStart("trafficLimitBytes")
		e.Str(s.TrafficLimitBytes)
	}
	{
		e.FieldStart("lifetimeTrafficUsedBytes")
		e.Str(s.LifetimeTrafficUsedBytes)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser = [13]string{
	0:  "shortUuid",
	1:  "daysLeft",
	2:  "trafficUsed",
	3:  "trafficLimit",
	4:  "lifetimeTrafficUsed",
	5:  "trafficUsedBytes",
	6:  "trafficLimitBytes",
	7:  "lifetimeTrafficUsedBytes",
	8:  "username",
	9:  "expiresAt",
	10: "isActive",
	11: "userStatus",
	12: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUser from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "lifetimeTrafficUsed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsed\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimitBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "lifetimeTrafficUsedBytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsedBytes\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUsernameResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionByUsernameResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUsernameResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUsernameResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionByUsernameResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUsernameResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionByUuidResponseDto from json.
func (s *GetSubscriptionByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUuidResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponse = [6]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
	5: "happ",
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponse from json.
func (s *GetSubscriptionByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "happ":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUuidResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponseHapp from json.
func (s *GetSubscriptionByUuidResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUuidResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionByUuidResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionByUuidResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionByUuidResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUuidResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUuidResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionByUuidResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("lifetimeTrafficUsed")
		e.Str(s.LifetimeTrafficUsed)
	}
	{
		e.FieldStart("trafficUsedBytes")
		e.Str(s.TrafficUsedBytes)
	}
	{
		e.FieldStart("trafficLimitBytes")
		e.Str(s.TrafficLimitBytes)
	}
	{
		e.FieldStart("lifetimeTrafficUsedBytes")
		e.Str(s.LifetimeTrafficUsedBytes)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseUser = [13]string{
	0:  "shortUuid",
	1:  "daysLeft",
	2:  "trafficUsed",
	3:  "trafficLimit",
	4:  "lifetimeTrafficUsed",
	5:  "trafficUsedBytes",
	6:  "trafficLimitBytes",
	7:  "lifetimeTrafficUsedBytes",
	8:  "username",
	9:  "expiresAt",
	10: "isActive",
	11: "userStatus",
	12: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponseUser from json.
func (s *GetSubscriptionByUuidResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "lifetimeTrafficUsed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsed\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimitBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "lifetimeTrafficUsedBytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsedBytes\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionByUuidResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionByUuidResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionByUuidResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionByUuidResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionByUuidResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionByUuidResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionByUuidResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionByUuidResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionByUuidResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionByUuidResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionByUuidResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionByUuidResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionByUuidResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionByUuidResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionByUuidResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionByUuidResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionByUuidResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionByUuidResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionByUuidResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionInfoResponseDto from json.
func (s *GetSubscriptionInfoResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isFound")
		e.Bool(s.IsFound)
	}
	{
		e.FieldStart("user")
		s.User.Encode(e)
	}
	{
		e.FieldStart("links")
		e.ArrStart()
		for _, elem := range s.Links {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("ssConfLinks")
		s.SsConfLinks.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse = [6]string{
	0: "isFound",
	1: "user",
	2: "links",
	3: "ssConfLinks",
	4: "subscriptionUrl",
	5: "happ",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponse from json.
func (s *GetSubscriptionInfoResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isFound":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsFound = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isFound\"")
			}
		case "user":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		case "links":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.Links = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Links = append(s.Links, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "ssConfLinks":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.SsConfLinks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssConfLinks\"")
			}
		case "subscriptionUrl":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "happ":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseHapp from json.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseSsConfLinks from json.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseSsConfLinks to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseSsConfLinks")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseSsConfLinks) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseSsConfLinks) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionInfoResponseDtoResponseUser) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("daysLeft")
		e.Float64(s.DaysLeft)
	}
	{
		e.FieldStart("trafficUsed")
		e.Str(s.TrafficUsed)
	}
	{
		e.FieldStart("trafficLimit")
		e.Str(s.TrafficLimit)
	}
	{
		e.FieldStart("lifetimeTrafficUsed")
		e.Str(s.LifetimeTrafficUsed)
	}
	{
		e.FieldStart("trafficUsedBytes")
		e.Str(s.TrafficUsedBytes)
	}
	{
		e.FieldStart("trafficLimitBytes")
		e.Str(s.TrafficLimitBytes)
	}
	{
		e.FieldStart("lifetimeTrafficUsedBytes")
		e.Str(s.LifetimeTrafficUsedBytes)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("expiresAt")
		json.EncodeDateTime(e, s.ExpiresAt)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("userStatus")
		s.UserStatus.Encode(e)
	}
	{
		e.FieldStart("trafficLimitStrategy")
		s.TrafficLimitStrategy.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser = [13]string{
	0:  "shortUuid",
	1:  "daysLeft",
	2:  "trafficUsed",
	3:  "trafficLimit",
	4:  "lifetimeTrafficUsed",
	5:  "trafficUsedBytes",
	6:  "trafficLimitBytes",
	7:  "lifetimeTrafficUsedBytes",
	8:  "username",
	9:  "expiresAt",
	10: "isActive",
	11: "userStatus",
	12: "trafficLimitStrategy",
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUser from json.
func (s *GetSubscriptionInfoResponseDtoResponseUser) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUser to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "daysLeft":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.DaysLeft = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"daysLeft\"")
			}
		case "trafficUsed":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsed\"")
			}
		case "trafficLimit":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimit = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimit\"")
			}
		case "lifetimeTrafficUsed":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsed = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsed\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.TrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrafficLimitBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "lifetimeTrafficUsedBytes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.LifetimeTrafficUsedBytes = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeTrafficUsedBytes\"")
			}
		case "username":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "expiresAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpiresAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiresAt\"")
			}
		case "isActive":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "userStatus":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.UserStatus.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userStatus\"")
			}
		case "trafficLimitStrategy":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionInfoResponseDtoResponseUser")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11111111,
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser) {
					name = jsonFieldsNameOfGetSubscriptionInfoResponseDtoResponseUser[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUser) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy as json.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v) {
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyNORESET
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyDAY
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyWEEK
	case GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategyMONTH
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionInfoResponseDtoResponseUserUserStatus as json.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionInfoResponseDtoResponseUserUserStatus from json.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionInfoResponseDtoResponseUserUserStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionInfoResponseDtoResponseUserUserStatus(v) {
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusACTIVE
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusDISABLED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusLIMITED
	case GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatusEXPIRED
	default:
		*s = GetSubscriptionInfoResponseDtoResponseUserUserStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionInfoResponseDtoResponseUserUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionInfoResponseDtoResponseUserUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionRequestHistoryResponseDto from json.
func (s *GetSubscriptionRequestHistoryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponse = [2]string{
	0: "records",
	1: "total",
}

// Decode decodes GetSubscriptionRequestHistoryResponseDtoResponse from json.
func (s *GetSubscriptionRequestHistoryResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "records":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Records = make([]GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("requestIp")
		s.RequestIp.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("requestAt")
		json.EncodeDateTime(e, s.RequestAt)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponseRecordsItem = [5]string{
	0: "id",
	1: "userUuid",
	2: "requestIp",
	3: "userAgent",
	4: "requestAt",
}

// Decode decodes GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem from json.
func (s *GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "requestIp":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.RequestIp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestIp\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "requestAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.RequestAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryStatsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionRequestHistoryStatsResponseDto from json.
func (s *GetSubscriptionRequestHistoryStatsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryStatsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryStatsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("byParsedApp")
		e.ArrStart()
		for _, elem := range s.ByParsedApp {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("hourlyRequestStats")
		e.ArrStart()
		for _, elem := range s.HourlyRequestStats {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponse = [2]string{
	0: "byParsedApp",
	1: "hourlyRequestStats",
}

// Decode decodes GetSubscriptionRequestHistoryStatsResponseDtoResponse from json.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryStatsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "byParsedApp":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.ByParsedApp = make([]GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ByParsedApp = append(s.ByParsedApp, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"byParsedApp\"")
			}
		case "hourlyRequestStats":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.HourlyRequestStats = make([]GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.HourlyRequestStats = append(s.HourlyRequestStats, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hourlyRequestStats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryStatsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("app")
		e.Str(s.App)
	}
	{
		e.FieldStart("count")
		e.Float64(s.Count)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem = [2]string{
	0: "app",
	1: "count",
}

// Decode decodes GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem from json.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "app":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.App = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"app\"")
			}
		case "count":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.Count = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("dateTime")
		json.EncodeDateTime(e, s.DateTime)
	}
	{
		e.FieldStart("requestCount")
		e.Float64(s.RequestCount)
	}
}

var jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem = [2]string{
	0: "dateTime",
	1: "requestCount",
}

// Decode decodes GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem from json.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "dateTime":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.DateTime = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"dateTime\"")
			}
		case "requestCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.RequestCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) {
					name = jsonFieldsNameOfGetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetSubscriptionSettingsResponseDto from json.
func (s *GetSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("randomizeHosts")
		e.Bool(s.RandomizeHosts)
	}
	{
		e.FieldStart("responseRules")
		s.ResponseRules.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse = [18]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
	15: "responseRules",
	16: "createdAt",
	17: "updatedAt",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponse from json.
func (s *GetSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.RandomizeHosts = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		case "responseRules":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.ResponseRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseRules\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRules = [2]string{
	0: "version",
	1: "rules",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRules from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Rules = make([]GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseResponseRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRules) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		if s.ResponseModifications.Set {
			e.FieldStart("responseModifications")
			s.ResponseModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem = [7]string{
	0: "name",
	1: "description",
	2: "enabled",
	3: "operator",
	4: "conditions",
	5: "responseType",
	6: "responseModifications",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "conditions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Conditions = make([]GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "responseModifications":
			if err := func() error {
				s.ResponseModifications.Reset()
				if err := s.ResponseModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseModifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headerName")
		e.Str(s.HeaderName)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("caseSensitive")
		e.Bool(s.CaseSensitive)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem = [4]string{
	0: "headerName",
	1: "operator",
	2: "value",
	3: "caseSensitive",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeaderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerName\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "caseSensitive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CaseSensitive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseSensitive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator as json.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator(v) {
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorEQUALS:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorEQUALS
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTEQUALS:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTEQUALS
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorCONTAINS:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorCONTAINS
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorSTARTSWITH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorSTARTSWITH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorENDSWITH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorENDSWITH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorREGEX:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorREGEX
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTREGEX:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTREGEX
	default:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator as json.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator(v) {
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorAND:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorAND
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorOR:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorOR
	default:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionTemplate.Set {
			e.FieldStart("subscriptionTemplate")
			s.SubscriptionTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications = [2]string{
	0: "headers",
	1: "subscriptionTemplate",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "subscriptionTemplate":
			if err := func() error {
				s.SubscriptionTemplate.Reset()
				if err := s.SubscriptionTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) {
					name = jsonFieldsNameOfGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType as json.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType(v) {
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYJSON:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYJSON
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYBASE64:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYBASE64
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeMIHOMO:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeMIHOMO
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTASH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTASH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeCLASH:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeCLASH
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSINGBOX:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSINGBOX
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBROWSER:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBROWSER
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBLOCK:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBLOCK
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE404:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE404
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE451:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE451
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSOCKETDROP:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSOCKETDROP
	default:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion as json.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion from json.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion(v) {
	case GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion1:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion1
	default:
		*s = GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetSubscriptionSettingsResponseDtoResponseResponseRulesVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetTemplateResponseDto from json.
func (s *GetTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDto) {
					name = jsonFieldsNameOfGetTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplateResponseDtoResponse = [5]string{
	0: "uuid",
	1: "name",
	2: "templateType",
	3: "templateJson",
	4: "encodedTemplateYaml",
}

// Decode decodes GetTemplateResponseDtoResponse from json.
func (s *GetTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfGetTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTemplateResponseDtoResponseTemplateType as json.
func (s GetTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetTemplateResponseDtoResponseTemplateType from json.
func (s *GetTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetTemplateResponseDtoResponseTemplateType(v) {
	case GetTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = GetTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case GetTemplateResponseDtoResponseTemplateTypeXRAYBASE64:
		*s = GetTemplateResponseDtoResponseTemplateTypeXRAYBASE64
	case GetTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = GetTemplateResponseDtoResponseTemplateTypeMIHOMO
	case GetTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeSTASH
	case GetTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = GetTemplateResponseDtoResponseTemplateTypeCLASH
	case GetTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = GetTemplateResponseDtoResponseTemplateTypeSINGBOX
	default:
		*s = GetTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplatesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplatesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplatesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetTemplatesResponseDto from json.
func (s *GetTemplatesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplatesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplatesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplatesResponseDto) {
					name = jsonFieldsNameOfGetTemplatesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplatesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplatesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplatesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplatesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetTemplatesResponseDtoResponse = [2]string{
	0: "total",
	1: "templates",
}

// Decode decodes GetTemplatesResponseDtoResponse from json.
func (s *GetTemplatesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplatesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "templates":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Templates = make([]GetTemplatesResponseDtoResponseTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetTemplatesResponseDtoResponseTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplatesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplatesResponseDtoResponse) {
					name = jsonFieldsNameOfGetTemplatesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplatesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplatesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetTemplatesResponseDtoResponseTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetTemplatesResponseDtoResponseTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfGetTemplatesResponseDtoResponseTemplatesItem = [5]string{
	0: "uuid",
	1: "name",
	2: "templateType",
	3: "templateJson",
	4: "encodedTemplateYaml",
}

// Decode decodes GetTemplatesResponseDtoResponseTemplatesItem from json.
func (s *GetTemplatesResponseDtoResponseTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplatesResponseDtoResponseTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetTemplatesResponseDtoResponseTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetTemplatesResponseDtoResponseTemplatesItem) {
					name = jsonFieldsNameOfGetTemplatesResponseDtoResponseTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetTemplatesResponseDtoResponseTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplatesResponseDtoResponseTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetTemplatesResponseDtoResponseTemplatesItemTemplateType as json.
func (s GetTemplatesResponseDtoResponseTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetTemplatesResponseDtoResponseTemplatesItemTemplateType from json.
func (s *GetTemplatesResponseDtoResponseTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetTemplatesResponseDtoResponseTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetTemplatesResponseDtoResponseTemplatesItemTemplateType(v) {
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeMIHOMO:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeMIHOMO
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeSTASH:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeSTASH
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeCLASH:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeCLASH
	case GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeSINGBOX:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateTypeSINGBOX
	default:
		*s = GetTemplatesResponseDtoResponseTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetTemplatesResponseDtoResponseTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetTemplatesResponseDtoResponseTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserAccessibleNodesResponseDto from json.
func (s *GetUserAccessibleNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDto) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("activeNodes")
		e.ArrStart()
		for _, elem := range s.ActiveNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse = [2]string{
	0: "userUuid",
	1: "activeNodes",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponse from json.
func (s *GetUserAccessibleNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "activeNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveNodes = make([]GetUserAccessibleNodesResponseDtoResponseActiveNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveNodes = append(s.ActiveNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileName")
		e.Str(s.ConfigProfileName)
	}
	{
		e.FieldStart("activeSquads")
		e.ArrStart()
		for _, elem := range s.ActiveSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem = [6]string{
	0: "uuid",
	1: "nodeName",
	2: "countryCode",
	3: "configProfileUuid",
	4: "configProfileName",
	5: "activeSquads",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponseActiveNodesItem from json.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileName":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ConfigProfileName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileName\"")
			}
		case "activeSquads":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				s.ActiveSquads = make([]GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveSquads = append(s.ActiveSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeSquads\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("squadName")
		e.Str(s.SquadName)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem = [2]string{
	0: "squadName",
	1: "activeInbounds",
}

// Decode decodes GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem from json.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "squadName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SquadName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"squadName\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) {
					name = jsonFieldsNameOfGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByEmailResponseDto from json.
func (s *GetUserByEmailResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByEmailResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByEmailResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDto) {
					name = jsonFieldsNameOfGetUserByEmailResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByEmailResponseDtoResponseItem from json.
func (s *GetUserByEmailResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem from json.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemHapp from json.
func (s *GetUserByEmailResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByEmailResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByEmailResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByEmailResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemStatus as json.
func (s GetUserByEmailResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemStatus from json.
func (s *GetUserByEmailResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByEmailResponseDtoResponseItemStatus(v) {
	case GetUserByEmailResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByEmailResponseDtoResponseItemStatusACTIVE
	case GetUserByEmailResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByEmailResponseDtoResponseItemStatusDISABLED
	case GetUserByEmailResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByEmailResponseDtoResponseItemStatusLIMITED
	case GetUserByEmailResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByEmailResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByEmailResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByEmailResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByShortUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByShortUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByShortUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByShortUuidResponseDto from json.
func (s *GetUserByShortUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByShortUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByShortUuidResponseDto) {
					name = jsonFieldsNameOfGetUserByShortUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByShortUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByShortUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByShortUuidResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByShortUuidResponseDtoResponse from json.
func (s *GetUserByShortUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByShortUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByShortUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserByShortUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem from json.
func (s *GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByShortUuidResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByShortUuidResponseDtoResponseHapp from json.
func (s *GetUserByShortUuidResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByShortUuidResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByShortUuidResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByShortUuidResponseDtoResponseLastConnectedNode from json.
func (s *GetUserByShortUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByShortUuidResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByShortUuidResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByShortUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByShortUuidResponseDtoResponseStatus as json.
func (s GetUserByShortUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByShortUuidResponseDtoResponseStatus from json.
func (s *GetUserByShortUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByShortUuidResponseDtoResponseStatus(v) {
	case GetUserByShortUuidResponseDtoResponseStatusACTIVE:
		*s = GetUserByShortUuidResponseDtoResponseStatusACTIVE
	case GetUserByShortUuidResponseDtoResponseStatusDISABLED:
		*s = GetUserByShortUuidResponseDtoResponseStatusDISABLED
	case GetUserByShortUuidResponseDtoResponseStatusLIMITED:
		*s = GetUserByShortUuidResponseDtoResponseStatusLIMITED
	case GetUserByShortUuidResponseDtoResponseStatusEXPIRED:
		*s = GetUserByShortUuidResponseDtoResponseStatusEXPIRED
	default:
		*s = GetUserByShortUuidResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByShortUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy as json.
func (s GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy from json.
func (s *GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy(v) {
	case GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyNORESET
	case GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyDAY:
		*s = GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyDAY
	case GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyWEEK
	case GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = GetUserByShortUuidResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByTagResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByTagResponseDto from json.
func (s *GetUserByTagResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByTagResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDto) {
					name = jsonFieldsNameOfGetUserByTagResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByTagResponseDtoResponseItem from json.
func (s *GetUserByTagResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem from json.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByTagResponseDtoResponseItemHapp from json.
func (s *GetUserByTagResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTagResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByTagResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (s GetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (s *GetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemStatus(v) {
	case GetUserByTagResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByTagResponseDtoResponseItemStatusACTIVE
	case GetUserByTagResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByTagResponseDtoResponseItemStatusDISABLED
	case GetUserByTagResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByTagResponseDtoResponseItemStatusLIMITED
	case GetUserByTagResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByTagResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByTagResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByTagResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTelegramIdResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTelegramIdResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserByTelegramIdResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByTelegramIdResponseDto from json.
func (s *GetUserByTelegramIdResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserByTelegramIdResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTelegramIdResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTelegramIdResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTelegramIdResponseDto) {
					name = jsonFieldsNameOfGetUserByTelegramIdResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTelegramIdResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTelegramIdResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItem from json.
func (s *GetUserByTelegramIdResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTelegramIdResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem from json.
func (s *GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTelegramIdResponseDtoResponseItemHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemHapp from json.
func (s *GetUserByTelegramIdResponseDtoResponseItemHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItemHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTelegramIdResponseDtoResponseItemHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemHapp) {
					name = jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode from json.
func (s *GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTelegramIdResponseDtoResponseItemStatus as json.
func (s GetUserByTelegramIdResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemStatus from json.
func (s *GetUserByTelegramIdResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItemStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTelegramIdResponseDtoResponseItemStatus(v) {
	case GetUserByTelegramIdResponseDtoResponseItemStatusACTIVE:
		*s = GetUserByTelegramIdResponseDtoResponseItemStatusACTIVE
	case GetUserByTelegramIdResponseDtoResponseItemStatusDISABLED:
		*s = GetUserByTelegramIdResponseDtoResponseItemStatusDISABLED
	case GetUserByTelegramIdResponseDtoResponseItemStatusLIMITED:
		*s = GetUserByTelegramIdResponseDtoResponseItemStatusLIMITED
	case GetUserByTelegramIdResponseDtoResponseItemStatusEXPIRED:
		*s = GetUserByTelegramIdResponseDtoResponseItemStatusEXPIRED
	default:
		*s = GetUserByTelegramIdResponseDtoResponseItemStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTelegramIdResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy as json.
func (s GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy from json.
func (s *GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy(v) {
	case GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyNORESET:
		*s = GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyNORESET
	case GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyDAY:
		*s = GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyDAY
	case GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyWEEK:
		*s = GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyWEEK
	case GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyMONTH:
		*s = GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategyMONTH
	default:
		*s = GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByUsernameResponseDto from json.
func (s *GetUserByUsernameResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDto) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByUsernameResponseDtoResponse from json.
func (s *GetUserByUsernameResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem from json.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByUsernameResponseDtoResponseHapp from json.
func (s *GetUserByUsernameResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByUsernameResponseDtoResponseLastConnectedNode from json.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUsernameResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByUsernameResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseStatus as json.
func (s GetUserByUsernameResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUsernameResponseDtoResponseStatus from json.
func (s *GetUserByUsernameResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUsernameResponseDtoResponseStatus(v) {
	case GetUserByUsernameResponseDtoResponseStatusACTIVE:
		*s = GetUserByUsernameResponseDtoResponseStatusACTIVE
	case GetUserByUsernameResponseDtoResponseStatusDISABLED:
		*s = GetUserByUsernameResponseDtoResponseStatusDISABLED
	case GetUserByUsernameResponseDtoResponseStatusLIMITED:
		*s = GetUserByUsernameResponseDtoResponseStatusLIMITED
	case GetUserByUsernameResponseDtoResponseStatusEXPIRED:
		*s = GetUserByUsernameResponseDtoResponseStatusEXPIRED
	default:
		*s = GetUserByUsernameResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUsernameResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy as json.
func (s GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy from json.
func (s *GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUsernameResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUsernameResponseDtoResponseTrafficLimitStrategy(v) {
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyNORESET
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyDAY:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyDAY
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyWEEK
	case GetUserByUsernameResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = GetUserByUsernameResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUsernameResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserByUuidResponseDto from json.
func (s *GetUserByUuidResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDto) {
					name = jsonFieldsNameOfGetUserByUuidResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes GetUserByUuidResponseDtoResponse from json.
func (s *GetUserByUuidResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]GetUserByUuidResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserByUuidResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes GetUserByUuidResponseDtoResponseActiveInternalSquadsItem from json.
func (s *GetUserByUuidResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes GetUserByUuidResponseDtoResponseHapp from json.
func (s *GetUserByUuidResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes GetUserByUuidResponseDtoResponseLastConnectedNode from json.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserByUuidResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfGetUserByUuidResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseStatus as json.
func (s GetUserByUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUuidResponseDtoResponseStatus from json.
func (s *GetUserByUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUuidResponseDtoResponseStatus(v) {
	case GetUserByUuidResponseDtoResponseStatusACTIVE:
		*s = GetUserByUuidResponseDtoResponseStatusACTIVE
	case GetUserByUuidResponseDtoResponseStatusDISABLED:
		*s = GetUserByUuidResponseDtoResponseStatusDISABLED
	case GetUserByUuidResponseDtoResponseStatusLIMITED:
		*s = GetUserByUuidResponseDtoResponseStatusLIMITED
	case GetUserByUuidResponseDtoResponseStatusEXPIRED:
		*s = GetUserByUuidResponseDtoResponseStatusEXPIRED
	default:
		*s = GetUserByUuidResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy as json.
func (s GetUserByUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy from json.
func (s *GetUserByUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserByUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch GetUserByUuidResponseDtoResponseTrafficLimitStrategy(v) {
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyNORESET
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyDAY:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyDAY
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyWEEK
	case GetUserByUuidResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = GetUserByUuidResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetUserByUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserByUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserHwidDevicesResponseDto from json.
func (s *GetUserHwidDevicesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDto) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("devices")
		e.ArrStart()
		for _, elem := range s.Devices {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse = [2]string{
	0: "total",
	1: "devices",
}

// Decode decodes GetUserHwidDevicesResponseDtoResponse from json.
func (s *GetUserHwidDevicesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "devices":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Devices = make([]GetUserHwidDevicesResponseDtoResponseDevicesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserHwidDevicesResponseDtoResponseDevicesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Devices = append(s.Devices, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"devices\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hwid")
		e.Str(s.Hwid)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("platform")
		s.Platform.Encode(e)
	}
	{
		e.FieldStart("osVersion")
		s.OsVersion.Encode(e)
	}
	{
		e.FieldStart("deviceModel")
		s.DeviceModel.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem = [8]string{
	0: "hwid",
	1: "userUuid",
	2: "platform",
	3: "osVersion",
	4: "deviceModel",
	5: "userAgent",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes GetUserHwidDevicesResponseDtoResponseDevicesItem from json.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserHwidDevicesResponseDtoResponseDevicesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hwid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Hwid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwid\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "platform":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Platform.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"platform\"")
			}
		case "osVersion":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.OsVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"osVersion\"")
			}
		case "deviceModel":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.DeviceModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deviceModel\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserHwidDevicesResponseDtoResponseDevicesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem) {
					name = jsonFieldsNameOfGetUserHwidDevicesResponseDtoResponseDevicesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserHwidDevicesResponseDtoResponseDevicesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserSubscriptionRequestHistoryResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserSubscriptionRequestHistoryResponseDto from json.
func (s *GetUserSubscriptionRequestHistoryResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserSubscriptionRequestHistoryResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserSubscriptionRequestHistoryResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDto) {
					name = jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("records")
		e.ArrStart()
		for _, elem := range s.Records {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponse = [2]string{
	0: "total",
	1: "records",
}

// Decode decodes GetUserSubscriptionRequestHistoryResponseDtoResponse from json.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserSubscriptionRequestHistoryResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "records":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Records = make([]GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Records = append(s.Records, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"records\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserSubscriptionRequestHistoryResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponse) {
					name = jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("requestAt")
		json.EncodeDateTime(e, s.RequestAt)
	}
	{
		e.FieldStart("requestIp")
		s.RequestIp.Encode(e)
	}
	{
		e.FieldStart("userAgent")
		s.UserAgent.Encode(e)
	}
}

var jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem = [5]string{
	0: "id",
	1: "userUuid",
	2: "requestAt",
	3: "requestIp",
	4: "userAgent",
}

// Decode decodes GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem from json.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "userUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "requestAt":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.RequestAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestAt\"")
			}
		case "requestIp":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.RequestIp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestIp\"")
			}
		case "userAgent":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.UserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userAgent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) {
					name = jsonFieldsNameOfGetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDto = [1]string{
	0: "response",
}

// Decode decodes GetUserUsageByRangeResponseDto from json.
func (s *GetUserUsageByRangeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]GetUserUsageByRangeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem GetUserUsageByRangeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDto) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetUserUsageByRangeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("userUuid")
		json.EncodeUUID(e, s.UserUuid)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("date")
		e.Str(s.Date)
	}
}

var jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem = [6]string{
	0: "userUuid",
	1: "nodeUuid",
	2: "nodeName",
	3: "countryCode",
	4: "total",
	5: "date",
}

// Decode decodes GetUserUsageByRangeResponseDtoResponseItem from json.
func (s *GetUserUsageByRangeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetUserUsageByRangeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "userUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UserUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userUuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "total":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Date = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"date\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetUserUsageByRangeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem) {
					name = jsonFieldsNameOfGetUserUsageByRangeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetUserUsageByRangeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDeleteHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDeleteHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsBulkActionsControllerDeleteHostsBadRequest from json.
func (s *HostsBulkActionsControllerDeleteHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDeleteHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDeleteHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsBulkActionsControllerDeleteHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem from json.
func (s *HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDeleteHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDeleteHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerDeleteHostsInternalServerError from json.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDeleteHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDeleteHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDeleteHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDisableHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDisableHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsBulkActionsControllerDisableHostsBadRequest from json.
func (s *HostsBulkActionsControllerDisableHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDisableHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsBulkActionsControllerDisableHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsBulkActionsControllerDisableHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDisableHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDisableHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsBulkActionsControllerDisableHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsBulkActionsControllerDisableHostsBadRequestErrorsItem from json.
func (s *HostsBulkActionsControllerDisableHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDisableHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDisableHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDisableHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerDisableHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerDisableHostsInternalServerError from json.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerDisableHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerDisableHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerDisableHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerEnableHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerEnableHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsBulkActionsControllerEnableHostsBadRequest from json.
func (s *HostsBulkActionsControllerEnableHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerEnableHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsBulkActionsControllerEnableHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsBulkActionsControllerEnableHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerEnableHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerEnableHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsBulkActionsControllerEnableHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsBulkActionsControllerEnableHostsBadRequestErrorsItem from json.
func (s *HostsBulkActionsControllerEnableHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerEnableHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerEnableHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerEnableHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerEnableHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerEnableHostsInternalServerError from json.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerEnableHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerEnableHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerEnableHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetInboundToHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsBulkActionsControllerSetInboundToHostsBadRequest from json.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetInboundToHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetInboundToHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem from json.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetInboundToHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerSetInboundToHostsInternalServerError from json.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetInboundToHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetInboundToHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetInboundToHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetPortToHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsBulkActionsControllerSetPortToHostsBadRequest from json.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetPortToHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetPortToHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem from json.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetPortToHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsBulkActionsControllerSetPortToHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsBulkActionsControllerSetPortToHostsInternalServerError from json.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsBulkActionsControllerSetPortToHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsBulkActionsControllerSetPortToHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsBulkActionsControllerSetPortToHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerCreateHostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerCreateHostBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerCreateHostBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerCreateHostBadRequest from json.
func (s *HostsControllerCreateHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerCreateHostBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerCreateHostBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerCreateHostBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerCreateHostBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerCreateHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerCreateHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerCreateHostBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerCreateHostBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerCreateHostBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerCreateHostBadRequestErrorsItem from json.
func (s *HostsControllerCreateHostBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerCreateHostBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerCreateHostBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerCreateHostBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerCreateHostBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerCreateHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerCreateHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerCreateHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerCreateHostInternalServerError from json.
func (s *HostsControllerCreateHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerCreateHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerCreateHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerCreateHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerCreateHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerDeleteHostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerDeleteHostBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerDeleteHostBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerDeleteHostBadRequest from json.
func (s *HostsControllerDeleteHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerDeleteHostBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerDeleteHostBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerDeleteHostBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerDeleteHostBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerDeleteHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerDeleteHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerDeleteHostBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerDeleteHostBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerDeleteHostBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerDeleteHostBadRequestErrorsItem from json.
func (s *HostsControllerDeleteHostBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerDeleteHostBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerDeleteHostBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerDeleteHostBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerDeleteHostBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerDeleteHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerDeleteHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerDeleteHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerDeleteHostInternalServerError from json.
func (s *HostsControllerDeleteHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerDeleteHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerDeleteHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerDeleteHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerDeleteHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostTagsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostTagsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerGetAllHostTagsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerGetAllHostTagsBadRequest from json.
func (s *HostsControllerGetAllHostTagsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostTagsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerGetAllHostTagsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerGetAllHostTagsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostTagsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostTagsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostTagsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostTagsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostTagsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerGetAllHostTagsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerGetAllHostTagsBadRequestErrorsItem from json.
func (s *HostsControllerGetAllHostTagsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostTagsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostTagsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostTagsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostTagsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostTagsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostTagsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerGetAllHostTagsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerGetAllHostTagsInternalServerError from json.
func (s *HostsControllerGetAllHostTagsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostTagsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostTagsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostTagsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostTagsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerGetAllHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerGetAllHostsBadRequest from json.
func (s *HostsControllerGetAllHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerGetAllHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerGetAllHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerGetAllHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerGetAllHostsBadRequestErrorsItem from json.
func (s *HostsControllerGetAllHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetAllHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetAllHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerGetAllHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerGetAllHostsInternalServerError from json.
func (s *HostsControllerGetAllHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetAllHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetAllHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetAllHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetAllHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetOneHostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetOneHostBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerGetOneHostBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerGetOneHostBadRequest from json.
func (s *HostsControllerGetOneHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetOneHostBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerGetOneHostBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerGetOneHostBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetOneHostBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetOneHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetOneHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetOneHostBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetOneHostBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerGetOneHostBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerGetOneHostBadRequestErrorsItem from json.
func (s *HostsControllerGetOneHostBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetOneHostBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetOneHostBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetOneHostBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetOneHostBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerGetOneHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerGetOneHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerGetOneHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerGetOneHostInternalServerError from json.
func (s *HostsControllerGetOneHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerGetOneHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerGetOneHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerGetOneHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerGetOneHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerReorderHostsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerReorderHostsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerReorderHostsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerReorderHostsBadRequest from json.
func (s *HostsControllerReorderHostsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerReorderHostsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerReorderHostsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerReorderHostsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerReorderHostsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerReorderHostsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerReorderHostsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerReorderHostsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerReorderHostsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerReorderHostsBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerReorderHostsBadRequestErrorsItem from json.
func (s *HostsControllerReorderHostsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerReorderHostsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerReorderHostsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerReorderHostsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerReorderHostsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerReorderHostsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerReorderHostsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerReorderHostsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerReorderHostsInternalServerError from json.
func (s *HostsControllerReorderHostsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerReorderHostsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerReorderHostsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerReorderHostsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerReorderHostsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerUpdateHostBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerUpdateHostBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHostsControllerUpdateHostBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HostsControllerUpdateHostBadRequest from json.
func (s *HostsControllerUpdateHostBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerUpdateHostBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HostsControllerUpdateHostBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HostsControllerUpdateHostBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerUpdateHostBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerUpdateHostBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerUpdateHostBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerUpdateHostBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerUpdateHostBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHostsControllerUpdateHostBadRequestErrorsItem = [0]string{}

// Decode decodes HostsControllerUpdateHostBadRequestErrorsItem from json.
func (s *HostsControllerUpdateHostBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerUpdateHostBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerUpdateHostBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerUpdateHostBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerUpdateHostBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HostsControllerUpdateHostInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HostsControllerUpdateHostInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHostsControllerUpdateHostInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HostsControllerUpdateHostInternalServerError from json.
func (s *HostsControllerUpdateHostInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HostsControllerUpdateHostInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HostsControllerUpdateHostInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HostsControllerUpdateHostInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HostsControllerUpdateHostInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerCreateUserHwidDeviceBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerCreateUserHwidDeviceBadRequest from json.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerCreateUserHwidDeviceBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerCreateUserHwidDeviceBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerCreateUserHwidDeviceInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError from json.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerCreateUserHwidDeviceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest from json.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError from json.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteAllUserHwidDevicesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteUserHwidDeviceBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest from json.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError from json.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerDeleteUserHwidDeviceInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetAllUsersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetAllUsersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerGetAllUsersBadRequest from json.
func (s *HwidUserDevicesControllerGetAllUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetAllUsersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetAllUsersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerGetAllUsersBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetAllUsersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetAllUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetAllUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerGetAllUsersInternalServerError from json.
func (s *HwidUserDevicesControllerGetAllUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetAllUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetAllUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetAllUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetAllUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetHwidDevicesStatsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerGetHwidDevicesStatsBadRequest from json.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetHwidDevicesStatsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetHwidDevicesStatsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetHwidDevicesStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError from json.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetHwidDevicesStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetUserHwidDevicesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes HwidUserDevicesControllerGetUserHwidDevicesBadRequest from json.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetUserHwidDevicesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetUserHwidDevicesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfHwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem = [0]string{}

// Decode decodes HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem from json.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfHwidUserDevicesControllerGetUserHwidDevicesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes HwidUserDevicesControllerGetUserHwidDevicesInternalServerError from json.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode HwidUserDevicesControllerGetUserHwidDevicesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode HwidUserDevicesControllerGetUserHwidDevicesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *HwidUserDevicesControllerGetUserHwidDevicesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingHistoryRecordBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest from json.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem from json.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError from json.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingHistoryRecordInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerCreateInfraBillingNodeBadRequest from json.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem from json.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraBillingNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraBillingNodeInternalServerError from json.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraBillingNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraBillingNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraBillingNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraProviderBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraProviderBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerCreateInfraProviderBadRequest from json.
func (s *InfraBillingControllerCreateInfraProviderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraProviderBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerCreateInfraProviderBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerCreateInfraProviderBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraProviderBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraProviderBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraProviderBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerCreateInfraProviderBadRequestErrorsItem from json.
func (s *InfraBillingControllerCreateInfraProviderBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraProviderBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraProviderBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraProviderBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerCreateInfraProviderInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerCreateInfraProviderInternalServerError from json.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerCreateInfraProviderInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerCreateInfraProviderInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerCreateInfraProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest from json.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem from json.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest from json.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem from json.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraBillingNodeByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraProviderByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerDeleteInfraProviderByUuidBadRequest from json.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraProviderByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraProviderByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem from json.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerDeleteInfraProviderByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerDeleteInfraProviderByUuidInternalServerError from json.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerDeleteInfraProviderByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerDeleteInfraProviderByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerDeleteInfraProviderByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetBillingNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetBillingNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerGetBillingNodesBadRequest from json.
func (s *InfraBillingControllerGetBillingNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetBillingNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerGetBillingNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerGetBillingNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetBillingNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetBillingNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerGetBillingNodesBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerGetBillingNodesBadRequestErrorsItem from json.
func (s *InfraBillingControllerGetBillingNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetBillingNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetBillingNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetBillingNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetBillingNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetBillingNodesInternalServerError from json.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetBillingNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetBillingNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetBillingNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraBillingHistoryRecordsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest from json.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem from json.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError from json.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraBillingHistoryRecordsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProviderByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerGetInfraProviderByUuidBadRequest from json.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProviderByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProviderByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem from json.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProviderByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraProviderByUuidInternalServerError from json.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProviderByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProviderByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProviderByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProvidersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProvidersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerGetInfraProvidersBadRequest from json.
func (s *InfraBillingControllerGetInfraProvidersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProvidersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerGetInfraProvidersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerGetInfraProvidersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProvidersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProvidersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProvidersBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerGetInfraProvidersBadRequestErrorsItem from json.
func (s *InfraBillingControllerGetInfraProvidersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProvidersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProvidersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProvidersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerGetInfraProvidersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerGetInfraProvidersInternalServerError from json.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerGetInfraProvidersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerGetInfraProvidersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerGetInfraProvidersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraBillingNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerUpdateInfraBillingNodeBadRequest from json.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraBillingNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraBillingNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem from json.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraBillingNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerUpdateInfraBillingNodeInternalServerError from json.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraBillingNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraBillingNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraBillingNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraProviderBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraProviderBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InfraBillingControllerUpdateInfraProviderBadRequest from json.
func (s *InfraBillingControllerUpdateInfraProviderBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraProviderBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraProviderBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraProviderBadRequestErrorsItem = [0]string{}

// Decode decodes InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem from json.
func (s *InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraProviderBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInfraBillingControllerUpdateInfraProviderInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InfraBillingControllerUpdateInfraProviderInternalServerError from json.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InfraBillingControllerUpdateInfraProviderInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InfraBillingControllerUpdateInfraProviderInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InfraBillingControllerUpdateInfraProviderInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerAddUsersToInternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerAddUsersToInternalSquadBadRequest from json.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerAddUsersToInternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerAddUsersToInternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem from json.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerAddUsersToInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerAddUsersToInternalSquadInternalServerError from json.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerAddUsersToInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerAddUsersToInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerAddUsersToInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerCreateInternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerCreateInternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerCreateInternalSquadBadRequest from json.
func (s *InternalSquadControllerCreateInternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerCreateInternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerCreateInternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerCreateInternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerCreateInternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerCreateInternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerCreateInternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerCreateInternalSquadBadRequestErrorsItem from json.
func (s *InternalSquadControllerCreateInternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerCreateInternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerCreateInternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerCreateInternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerCreateInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerCreateInternalSquadInternalServerError from json.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerCreateInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerCreateInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerCreateInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerDeleteInternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerDeleteInternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerDeleteInternalSquadBadRequest from json.
func (s *InternalSquadControllerDeleteInternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerDeleteInternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerDeleteInternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerDeleteInternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem from json.
func (s *InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerDeleteInternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerDeleteInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerDeleteInternalSquadInternalServerError from json.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerDeleteInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerDeleteInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerDeleteInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadAccessibleNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest from json.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem from json.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError from json.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadAccessibleNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerGetInternalSquadByUuidBadRequest from json.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem from json.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerGetInternalSquadByUuidInternalServerError from json.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerGetInternalSquadsBadRequest from json.
func (s *InternalSquadControllerGetInternalSquadsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerGetInternalSquadsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerGetInternalSquadsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadsBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerGetInternalSquadsBadRequestErrorsItem from json.
func (s *InternalSquadControllerGetInternalSquadsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerGetInternalSquadsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerGetInternalSquadsInternalServerError from json.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerGetInternalSquadsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerGetInternalSquadsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerGetInternalSquadsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerRemoveUsersFromInternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerRemoveUsersFromInternalSquadBadRequest from json.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerRemoveUsersFromInternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerRemoveUsersFromInternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem from json.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerRemoveUsersFromInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError from json.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerRemoveUsersFromInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerUpdateInternalSquadBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerUpdateInternalSquadBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes InternalSquadControllerUpdateInternalSquadBadRequest from json.
func (s *InternalSquadControllerUpdateInternalSquadBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerUpdateInternalSquadBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerUpdateInternalSquadBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfInternalSquadControllerUpdateInternalSquadBadRequestErrorsItem = [0]string{}

// Decode decodes InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem from json.
func (s *InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerUpdateInternalSquadBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfInternalSquadControllerUpdateInternalSquadInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes InternalSquadControllerUpdateInternalSquadInternalServerError from json.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode InternalSquadControllerUpdateInternalSquadInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode InternalSquadControllerUpdateInternalSquadInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *InternalSquadControllerUpdateInternalSquadInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeygenControllerGenerateKeyBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeygenControllerGenerateKeyBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfKeygenControllerGenerateKeyBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes KeygenControllerGenerateKeyBadRequest from json.
func (s *KeygenControllerGenerateKeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeygenControllerGenerateKeyBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]KeygenControllerGenerateKeyBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem KeygenControllerGenerateKeyBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeygenControllerGenerateKeyBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeygenControllerGenerateKeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeygenControllerGenerateKeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeygenControllerGenerateKeyBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeygenControllerGenerateKeyBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfKeygenControllerGenerateKeyBadRequestErrorsItem = [0]string{}

// Decode decodes KeygenControllerGenerateKeyBadRequestErrorsItem from json.
func (s *KeygenControllerGenerateKeyBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeygenControllerGenerateKeyBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode KeygenControllerGenerateKeyBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeygenControllerGenerateKeyBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeygenControllerGenerateKeyBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *KeygenControllerGenerateKeyInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfKeygenControllerGenerateKeyInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes KeygenControllerGenerateKeyInternalServerError from json.
func (s *KeygenControllerGenerateKeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode KeygenControllerGenerateKeyInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode KeygenControllerGenerateKeyInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *KeygenControllerGenerateKeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LoginRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LoginRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfLoginRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes LoginRequestDto from json.
func (s *LoginRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LoginRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LoginRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLoginRequestDto) {
					name = jsonFieldsNameOfLoginRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LoginRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LoginRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateExternalSquadResponseDtoResponseSubscriptionSettings as json.
func (o NilCreateExternalSquadResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateExternalSquadResponseDtoResponseSubscriptionSettings from json.
func (o *NilCreateExternalSquadResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateExternalSquadResponseDtoResponseSubscriptionSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateExternalSquadResponseDtoResponseSubscriptionSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateExternalSquadResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateExternalSquadResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateNodeResponseDtoResponseProvider as json.
func (o NilCreateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateNodeResponseDtoResponseProvider from json.
func (o *NilCreateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseDtoResponseLastConnectedNode as json.
func (o NilCreateUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateUserResponseDtoResponseLastConnectedNode from json.
func (o *NilCreateUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilCreateUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilCreateUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilCreateUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o NilDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if o.Null {
		e.Null()
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *NilDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDateTime to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v time.Time
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseMatchedRule as json.
func (o NilDebugSrrMatcherResponseDtoResponseMatchedRule) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRule from json.
func (o *NilDebugSrrMatcherResponseDtoResponseMatchedRule) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDebugSrrMatcherResponseDtoResponseMatchedRule to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DebugSrrMatcherResponseDtoResponseMatchedRule
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDebugSrrMatcherResponseDtoResponseMatchedRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDebugSrrMatcherResponseDtoResponseMatchedRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableNodeResponseDtoResponseProvider as json.
func (o NilDisableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisableNodeResponseDtoResponseProvider from json.
func (o *NilDisableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDisableNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DisableNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDisableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDisableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseLastConnectedNode as json.
func (o NilDisableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DisableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilDisableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilDisableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v DisableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilDisableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilDisableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableNodeResponseDtoResponseProvider as json.
func (o NilEnableNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnableNodeResponseDtoResponseProvider from json.
func (o *NilEnableNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEnableNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnableNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEnableNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEnableNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseLastConnectedNode as json.
func (o NilEnableUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EnableUserResponseDtoResponseLastConnectedNode from json.
func (o *NilEnableUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilEnableUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v EnableUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilEnableUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilEnableUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o NilFloat64) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *NilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllNodesResponseDtoResponseItemProvider as json.
func (o NilGetAllNodesResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetAllNodesResponseDtoResponseItemProvider from json.
func (o *NilGetAllNodesResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetAllNodesResponseDtoResponseItemProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetAllNodesResponseDtoResponseItemProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetAllNodesResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetAllNodesResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllUsersResponseDtoResponseUsersItemLastConnectedNode as json.
func (o NilGetAllUsersResponseDtoResponseUsersItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemLastConnectedNode from json.
func (o *NilGetAllUsersResponseDtoResponseUsersItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetAllUsersResponseDtoResponseUsersItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetAllUsersResponseDtoResponseUsersItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetAllUsersResponseDtoResponseUsersItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetAllUsersResponseDtoResponseUsersItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings as json.
func (o NilGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings from json.
func (o *NilGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetExternalSquadByUuidResponseDtoResponseSubscriptionSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetExternalSquadByUuidResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings as json.
func (o NilGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings from json.
func (o *NilGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneNodeResponseDtoResponseProvider as json.
func (o NilGetOneNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetOneNodeResponseDtoResponseProvider from json.
func (o *NilGetOneNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetOneNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetOneNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetOneNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetOneNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode as json.
func (o NilGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode from json.
func (o *NilGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemnawaveSettingsResponseDtoResponseBrandingSettings as json.
func (o NilGetRemnawaveSettingsResponseDtoResponseBrandingSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseBrandingSettings from json.
func (o *NilGetRemnawaveSettingsResponseDtoResponseBrandingSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRemnawaveSettingsResponseDtoResponseBrandingSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRemnawaveSettingsResponseDtoResponseBrandingSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRemnawaveSettingsResponseDtoResponseBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRemnawaveSettingsResponseDtoResponseBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemnawaveSettingsResponseDtoResponseOauth2Settings as json.
func (o NilGetRemnawaveSettingsResponseDtoResponseOauth2Settings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseOauth2Settings from json.
func (o *NilGetRemnawaveSettingsResponseDtoResponseOauth2Settings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRemnawaveSettingsResponseDtoResponseOauth2Settings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRemnawaveSettingsResponseDtoResponseOauth2Settings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRemnawaveSettingsResponseDtoResponseOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRemnawaveSettingsResponseDtoResponseOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemnawaveSettingsResponseDtoResponsePasskeySettings as json.
func (o NilGetRemnawaveSettingsResponseDtoResponsePasskeySettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponsePasskeySettings from json.
func (o *NilGetRemnawaveSettingsResponseDtoResponsePasskeySettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRemnawaveSettingsResponseDtoResponsePasskeySettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRemnawaveSettingsResponseDtoResponsePasskeySettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRemnawaveSettingsResponseDtoResponsePasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRemnawaveSettingsResponseDtoResponsePasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemnawaveSettingsResponseDtoResponsePasswordSettings as json.
func (o NilGetRemnawaveSettingsResponseDtoResponsePasswordSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponsePasswordSettings from json.
func (o *NilGetRemnawaveSettingsResponseDtoResponsePasswordSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRemnawaveSettingsResponseDtoResponsePasswordSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRemnawaveSettingsResponseDtoResponsePasswordSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRemnawaveSettingsResponseDtoResponsePasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRemnawaveSettingsResponseDtoResponsePasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRemnawaveSettingsResponseDtoResponseTgAuthSettings as json.
func (o NilGetRemnawaveSettingsResponseDtoResponseTgAuthSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRemnawaveSettingsResponseDtoResponseTgAuthSettings from json.
func (o *NilGetRemnawaveSettingsResponseDtoResponseTgAuthSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetRemnawaveSettingsResponseDtoResponseTgAuthSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRemnawaveSettingsResponseDtoResponseTgAuthSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetRemnawaveSettingsResponseDtoResponseTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetRemnawaveSettingsResponseDtoResponseTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(GetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRules as json.
func (o NilGetSubscriptionSettingsResponseDtoResponseResponseRules) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRules from json.
func (o *NilGetSubscriptionSettingsResponseDtoResponseResponseRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetSubscriptionSettingsResponseDtoResponseResponseRules to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetSubscriptionSettingsResponseDtoResponseResponseRules
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetSubscriptionSettingsResponseDtoResponseResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetSubscriptionSettingsResponseDtoResponseResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByEmailResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByEmailResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByEmailResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByEmailResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByShortUuidResponseDtoResponseLastConnectedNode as json.
func (o NilGetUserByShortUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByShortUuidResponseDtoResponseLastConnectedNode from json.
func (o *NilGetUserByShortUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByShortUuidResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByShortUuidResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByShortUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByShortUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByTagResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByTagResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByTagResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByTagResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByTagResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode as json.
func (o NilGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode from json.
func (o *NilGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByTelegramIdResponseDtoResponseItemLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByTelegramIdResponseDtoResponseItemLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseLastConnectedNode as json.
func (o NilGetUserByUsernameResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByUsernameResponseDtoResponseLastConnectedNode from json.
func (o *NilGetUserByUsernameResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByUsernameResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByUsernameResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByUsernameResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByUsernameResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseLastConnectedNode as json.
func (o NilGetUserByUuidResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetUserByUuidResponseDtoResponseLastConnectedNode from json.
func (o *NilGetUserByUuidResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilGetUserByUuidResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetUserByUuidResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilGetUserByUuidResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilGetUserByUuidResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o NilInt) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *NilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ReorderNodeResponseDtoResponseItemProvider as json.
func (o NilReorderNodeResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ReorderNodeResponseDtoResponseItemProvider from json.
func (o *NilReorderNodeResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilReorderNodeResponseDtoResponseItemProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ReorderNodeResponseDtoResponseItemProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilReorderNodeResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilReorderNodeResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseLastConnectedNode as json.
func (o NilResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (o *NilResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v ResetUserTrafficResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode as json.
func (o NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (o *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v RevokeUserSubscriptionResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o NilString) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *NilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o NilURI) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *NilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o NilUUID) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *NilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExternalSquadResponseDtoResponseSubscriptionSettings as json.
func (o NilUpdateExternalSquadResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateExternalSquadResponseDtoResponseSubscriptionSettings from json.
func (o *NilUpdateExternalSquadResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateExternalSquadResponseDtoResponseSubscriptionSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateExternalSquadResponseDtoResponseSubscriptionSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateExternalSquadResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateExternalSquadResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNodeResponseDtoResponseProvider as json.
func (o NilUpdateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNodeResponseDtoResponseProvider from json.
func (o *NilUpdateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateNodeResponseDtoResponseProvider to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateNodeResponseDtoResponseProvider
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings as json.
func (o NilUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings from json.
func (o *NilUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings as json.
func (o NilUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings from json.
func (o *NilUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings as json.
func (o NilUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings from json.
func (o *NilUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings as json.
func (o NilUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings from json.
func (o *NilUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings as json.
func (o NilUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings from json.
func (o *NilUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders as json.
func (o NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (o *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	o.Value = make(UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRules as json.
func (o NilUpdateSubscriptionSettingsResponseDtoResponseResponseRules) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRules from json.
func (o *NilUpdateSubscriptionSettingsResponseDtoResponseResponseRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateSubscriptionSettingsResponseDtoResponseResponseRules to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateSubscriptionSettingsResponseDtoResponseResponseRules
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateSubscriptionSettingsResponseDtoResponseResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateSubscriptionSettingsResponseDtoResponseResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserResponseDtoResponseLastConnectedNode as json.
func (o NilUpdateUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateUserResponseDtoResponseLastConnectedNode from json.
func (o *NilUpdateUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode NilUpdateUserResponseDtoResponseLastConnectedNode to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateUserResponseDtoResponseLastConnectedNode
		o.Value = v
		o.Null = true
		return nil
	}
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NilUpdateUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NilUpdateUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerCreateNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerCreateNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerCreateNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerCreateNodeBadRequest from json.
func (s *NodesControllerCreateNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerCreateNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerCreateNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerCreateNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerCreateNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerCreateNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerCreateNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerCreateNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerCreateNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerCreateNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerCreateNodeBadRequestErrorsItem from json.
func (s *NodesControllerCreateNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerCreateNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerCreateNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerCreateNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerCreateNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerCreateNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerCreateNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerCreateNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerCreateNodeInternalServerError from json.
func (s *NodesControllerCreateNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerCreateNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerCreateNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerCreateNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerCreateNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDeleteNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDeleteNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerDeleteNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerDeleteNodeBadRequest from json.
func (s *NodesControllerDeleteNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDeleteNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerDeleteNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerDeleteNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDeleteNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDeleteNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDeleteNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDeleteNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDeleteNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerDeleteNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerDeleteNodeBadRequestErrorsItem from json.
func (s *NodesControllerDeleteNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDeleteNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDeleteNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDeleteNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDeleteNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDeleteNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDeleteNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerDeleteNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerDeleteNodeInternalServerError from json.
func (s *NodesControllerDeleteNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDeleteNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDeleteNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDeleteNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDeleteNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDisableNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDisableNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerDisableNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerDisableNodeBadRequest from json.
func (s *NodesControllerDisableNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDisableNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerDisableNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerDisableNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDisableNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDisableNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDisableNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDisableNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDisableNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerDisableNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerDisableNodeBadRequestErrorsItem from json.
func (s *NodesControllerDisableNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDisableNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDisableNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDisableNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDisableNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerDisableNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerDisableNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerDisableNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerDisableNodeInternalServerError from json.
func (s *NodesControllerDisableNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerDisableNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerDisableNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerDisableNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerDisableNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerEnableNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerEnableNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerEnableNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerEnableNodeBadRequest from json.
func (s *NodesControllerEnableNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerEnableNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerEnableNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerEnableNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerEnableNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerEnableNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerEnableNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerEnableNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerEnableNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerEnableNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerEnableNodeBadRequestErrorsItem from json.
func (s *NodesControllerEnableNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerEnableNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerEnableNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerEnableNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerEnableNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerEnableNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerEnableNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerEnableNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerEnableNodeInternalServerError from json.
func (s *NodesControllerEnableNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerEnableNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerEnableNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerEnableNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerEnableNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetAllNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetAllNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerGetAllNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerGetAllNodesBadRequest from json.
func (s *NodesControllerGetAllNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetAllNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerGetAllNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerGetAllNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetAllNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetAllNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetAllNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetAllNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetAllNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerGetAllNodesBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerGetAllNodesBadRequestErrorsItem from json.
func (s *NodesControllerGetAllNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetAllNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetAllNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetAllNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetAllNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetAllNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetAllNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerGetAllNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerGetAllNodesInternalServerError from json.
func (s *NodesControllerGetAllNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetAllNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetAllNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetAllNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetAllNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetOneNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetOneNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerGetOneNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerGetOneNodeBadRequest from json.
func (s *NodesControllerGetOneNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetOneNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerGetOneNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerGetOneNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetOneNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetOneNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetOneNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetOneNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetOneNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerGetOneNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerGetOneNodeBadRequestErrorsItem from json.
func (s *NodesControllerGetOneNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetOneNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetOneNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetOneNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetOneNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerGetOneNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerGetOneNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerGetOneNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerGetOneNodeInternalServerError from json.
func (s *NodesControllerGetOneNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerGetOneNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerGetOneNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerGetOneNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerGetOneNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerReorderNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerReorderNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerReorderNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerReorderNodesBadRequest from json.
func (s *NodesControllerReorderNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerReorderNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerReorderNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerReorderNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerReorderNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerReorderNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerReorderNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerReorderNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerReorderNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerReorderNodesBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerReorderNodesBadRequestErrorsItem from json.
func (s *NodesControllerReorderNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerReorderNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerReorderNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerReorderNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerReorderNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerReorderNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerReorderNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerReorderNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerReorderNodesInternalServerError from json.
func (s *NodesControllerReorderNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerReorderNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerReorderNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerReorderNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerReorderNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartAllNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartAllNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartAllNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerRestartAllNodesBadRequest from json.
func (s *NodesControllerRestartAllNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartAllNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerRestartAllNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerRestartAllNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartAllNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartAllNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartAllNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartAllNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartAllNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerRestartAllNodesBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerRestartAllNodesBadRequestErrorsItem from json.
func (s *NodesControllerRestartAllNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartAllNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartAllNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartAllNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartAllNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartAllNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartAllNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerRestartAllNodesInternalServerError from json.
func (s *NodesControllerRestartAllNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartAllNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartAllNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartAllNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerRestartNodeBadRequest from json.
func (s *NodesControllerRestartNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerRestartNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerRestartNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerRestartNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerRestartNodeBadRequestErrorsItem from json.
func (s *NodesControllerRestartNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerRestartNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerRestartNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerRestartNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerRestartNodeInternalServerError from json.
func (s *NodesControllerRestartNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerRestartNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerRestartNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerRestartNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerRestartNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerUpdateNodeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerUpdateNodeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesControllerUpdateNodeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesControllerUpdateNodeBadRequest from json.
func (s *NodesControllerUpdateNodeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerUpdateNodeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesControllerUpdateNodeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesControllerUpdateNodeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerUpdateNodeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerUpdateNodeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerUpdateNodeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerUpdateNodeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerUpdateNodeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesControllerUpdateNodeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesControllerUpdateNodeBadRequestErrorsItem from json.
func (s *NodesControllerUpdateNodeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerUpdateNodeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerUpdateNodeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerUpdateNodeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerUpdateNodeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesControllerUpdateNodeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesControllerUpdateNodeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesControllerUpdateNodeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesControllerUpdateNodeInternalServerError from json.
func (s *NodesControllerUpdateNodeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesControllerUpdateNodeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesControllerUpdateNodeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesControllerUpdateNodeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesControllerUpdateNodeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesUsageHistoryControllerGetNodesUsageByRangeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest from json.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem = [0]string{}

// Decode decodes NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem from json.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError from json.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUsageHistoryControllerGetNodesUsageByRangeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodeUserUsageBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest from json.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem = [0]string{}

// Decode decodes NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem from json.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError from json.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodeUserUsageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest from json.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem = [0]string{}

// Decode decodes NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem from json.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfNodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError from json.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NodesUserUsageHistoryControllerGetNodesRealtimeUsageInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2AuthorizeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2AuthorizeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfOAuth2AuthorizeRequestDto = [1]string{
	0: "provider",
}

// Decode decodes OAuth2AuthorizeRequestDto from json.
func (s *OAuth2AuthorizeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2AuthorizeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2AuthorizeRequestDto) {
					name = jsonFieldsNameOfOAuth2AuthorizeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2AuthorizeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2AuthorizeRequestDtoProvider as json.
func (s OAuth2AuthorizeRequestDtoProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2AuthorizeRequestDtoProvider from json.
func (s *OAuth2AuthorizeRequestDtoProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2AuthorizeRequestDtoProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2AuthorizeRequestDtoProvider(v) {
	case OAuth2AuthorizeRequestDtoProviderGithub:
		*s = OAuth2AuthorizeRequestDtoProviderGithub
	case OAuth2AuthorizeRequestDtoProviderPocketid:
		*s = OAuth2AuthorizeRequestDtoProviderPocketid
	case OAuth2AuthorizeRequestDtoProviderYandex:
		*s = OAuth2AuthorizeRequestDtoProviderYandex
	default:
		*s = OAuth2AuthorizeRequestDtoProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2AuthorizeRequestDtoProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2AuthorizeRequestDtoProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *OAuth2CallbackRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *OAuth2CallbackRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("code")
		e.Str(s.Code)
	}
	{
		e.FieldStart("state")
		e.Str(s.State)
	}
}

var jsonFieldsNameOfOAuth2CallbackRequestDto = [3]string{
	0: "provider",
	1: "code",
	2: "state",
}

// Decode decodes OAuth2CallbackRequestDto from json.
func (s *OAuth2CallbackRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "provider":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "code":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Code = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"code\"")
			}
		case "state":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.State = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"state\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode OAuth2CallbackRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfOAuth2CallbackRequestDto) {
					name = jsonFieldsNameOfOAuth2CallbackRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *OAuth2CallbackRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes OAuth2CallbackRequestDtoProvider as json.
func (s OAuth2CallbackRequestDtoProvider) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes OAuth2CallbackRequestDtoProvider from json.
func (s *OAuth2CallbackRequestDtoProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode OAuth2CallbackRequestDtoProvider to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch OAuth2CallbackRequestDtoProvider(v) {
	case OAuth2CallbackRequestDtoProviderGithub:
		*s = OAuth2CallbackRequestDtoProviderGithub
	case OAuth2CallbackRequestDtoProviderPocketid:
		*s = OAuth2CallbackRequestDtoProviderPocketid
	case OAuth2CallbackRequestDtoProviderYandex:
		*s = OAuth2CallbackRequestDtoProviderYandex
	default:
		*s = OAuth2CallbackRequestDtoProvider(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OAuth2CallbackRequestDtoProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OAuth2CallbackRequestDtoProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoStatus as json.
func (o OptBulkAllUpdateUsersRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoStatus from json.
func (o *OptBulkAllUpdateUsersRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy as json.
func (o OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkAllUpdateUsersRequestDtoTrafficLimitStrategy from json.
func (o *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkAllUpdateUsersRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDeleteUsersByStatusRequestDtoStatus as json.
func (o OptBulkDeleteUsersByStatusRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDeleteUsersByStatusRequestDtoStatus from json.
func (o *OptBulkDeleteUsersByStatusRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDeleteUsersByStatusRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDeleteUsersByStatusRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDeleteUsersByStatusRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkDisableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkDisableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkDisableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkDisableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkEnableHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkEnableHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkEnableHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkEnableHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsStatus as json.
func (o OptBulkUpdateUsersRequestDtoFieldsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsStatus from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy as json.
func (o OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy from json.
func (o *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoSecurityLayer as json.
func (o OptCreateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoSecurityLayer from json.
func (o *OptCreateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostResponseDtoResponseSecurityLayer as json.
func (o OptCreateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostResponseDtoResponseSecurityLayer from json.
func (o *OptCreateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoStatus as json.
func (o OptCreateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserRequestDtoStatus from json.
func (o *OptCreateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserRequestDtoTrafficLimitStrategy as json.
func (o OptCreateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserRequestDtoTrafficLimitStrategy from json.
func (o *OptCreateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseDtoResponseStatus as json.
func (o OptCreateUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserResponseDtoResponseStatus from json.
func (o *OptCreateUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptCreateUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptCreateUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes time.Time as json.
func (o OptDateTime) Encode(e *jx.Encoder, format func(*jx.Encoder, time.Time)) {
	if !o.Set {
		return
	}
	format(e, o.Value)
}

// Decode decodes time.Time from json.
func (o *OptDateTime) Decode(d *jx.Decoder, format func(*jx.Decoder) (time.Time, error)) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDateTime to nil")
	}
	o.Set = true
	v, err := format(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDateTime) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e, json.EncodeDateTime)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDateTime) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d, json.DecodeDateTime)
}

// Encode encodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications as json.
func (o OptDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications from json.
func (o *OptDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications as json.
func (o OptDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications from json.
func (o *OptDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseStatus as json.
func (o OptDisableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseStatus from json.
func (o *OptDisableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DisableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptDisableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DisableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptDisableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDisableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDisableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDisableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseStatus as json.
func (o OptEnableUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseStatus from json.
func (o *OptEnableUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EnableUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptEnableUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes EnableUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptEnableUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEnableUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEnableUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEnableUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat64 to nil")
	}
	o.Set = true
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptGetAllHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetAllHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptGetAllHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAllHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAllHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAllHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllUsersResponseDtoResponseUsersItemStatus as json.
func (o OptGetAllUsersResponseDtoResponseUsersItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemStatus from json.
func (o *OptGetAllUsersResponseDtoResponseUsersItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAllUsersResponseDtoResponseUsersItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAllUsersResponseDtoResponseUsersItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAllUsersResponseDtoResponseUsersItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy as json.
func (o OptGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy from json.
func (o *OptGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetOneHostResponseDtoResponseSecurityLayer as json.
func (o OptGetOneHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetOneHostResponseDtoResponseSecurityLayer from json.
func (o *OptGetOneHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetOneHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetOneHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetOneHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams to nil")
	}
	o.Set = true
	o.Value = new(GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams to nil")
	}
	o.Set = true
	o.Value = new(GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes *GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams to nil")
	}
	o.Set = true
	o.Value = new(GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy as json.
func (o OptGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy from json.
func (o *OptGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications as json.
func (o OptGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications from json.
func (o *OptGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemStatus as json.
func (o OptGetUserByEmailResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemStatus from json.
func (o *OptGetUserByEmailResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByEmailResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByEmailResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByEmailResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByEmailResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByEmailResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByShortUuidResponseDtoResponseStatus as json.
func (o OptGetUserByShortUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByShortUuidResponseDtoResponseStatus from json.
func (o *OptGetUserByShortUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByShortUuidResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByShortUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByShortUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy as json.
func (o OptGetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByShortUuidResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptGetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByShortUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByShortUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemStatus as json.
func (o OptGetUserByTagResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemStatus from json.
func (o *OptGetUserByTagResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTagResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTagResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTelegramIdResponseDtoResponseItemStatus as json.
func (o OptGetUserByTelegramIdResponseDtoResponseItemStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemStatus from json.
func (o *OptGetUserByTelegramIdResponseDtoResponseItemStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTelegramIdResponseDtoResponseItemStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTelegramIdResponseDtoResponseItemStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTelegramIdResponseDtoResponseItemStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy as json.
func (o OptGetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy from json.
func (o *OptGetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByTelegramIdResponseDtoResponseItemTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseStatus as json.
func (o OptGetUserByUsernameResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUsernameResponseDtoResponseStatus from json.
func (o *OptGetUserByUsernameResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUsernameResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUsernameResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUsernameResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy as json.
func (o OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUsernameResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUsernameResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseStatus as json.
func (o OptGetUserByUuidResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUuidResponseDtoResponseStatus from json.
func (o *OptGetUserByUuidResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUuidResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUuidResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUuidResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy as json.
func (o OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes GetUserByUuidResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptGetUserByUuidResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoAlpn as json.
func (o OptNilCreateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoAlpn from json.
func (o *OptNilCreateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateHostRequestDtoFingerprint as json.
func (o OptNilCreateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes CreateHostRequestDtoFingerprint from json.
func (o *OptNilCreateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilCreateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v CreateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilCreateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilCreateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float64 as json.
func (o OptNilFloat64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes float64 from json.
func (o *OptNilFloat64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat64 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float64
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float64()
	if err != nil {
		return err
	}
	o.Value = float64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs as json.
func (o OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs from json.
func (o *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptNilInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptNilInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptNilURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptNilURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilURI to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v url.URL
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptNilUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptNilUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUUID to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v uuid.UUID
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (o OptNilUpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (o *OptNilUpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoAlpn to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoAlpn
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (o OptNilUpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (o *OptNilUpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilUpdateHostRequestDtoFingerprint to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v UpdateHostRequestDtoFingerprint
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilUpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilUpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (o OptResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (o *OptResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (o OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (o OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptRevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (o OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (o *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes url.URL as json.
func (o OptURI) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeURI(e, o.Value)
}

// Decode decodes url.URL from json.
func (o *OptURI) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptURI to nil")
	}
	o.Set = true
	v, err := json.DecodeURI(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptURI) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptURI) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes uuid.UUID as json.
func (o OptUUID) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	json.EncodeUUID(e, o.Value)
}

// Decode decodes uuid.UUID from json.
func (o *OptUUID) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUUID to nil")
	}
	o.Set = true
	v, err := json.DecodeUUID(d)
	if err != nil {
		return err
	}
	o.Value = v
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUUID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUUID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExternalSquadRequestDtoSubscriptionSettings as json.
func (o OptUpdateExternalSquadRequestDtoSubscriptionSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateExternalSquadRequestDtoSubscriptionSettings from json.
func (o *OptUpdateExternalSquadRequestDtoSubscriptionSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateExternalSquadRequestDtoSubscriptionSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateExternalSquadRequestDtoSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateExternalSquadRequestDtoSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoInbound as json.
func (o OptUpdateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateHostRequestDtoInbound from json.
func (o *OptUpdateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostRequestDtoInbound to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (o OptUpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (o *OptUpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostRequestDtoSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (o OptUpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (o *OptUpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateNodeRequestDtoConfigProfile as json.
func (o OptUpdateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateNodeRequestDtoConfigProfile from json.
func (o *OptUpdateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateNodeRequestDtoConfigProfile to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsRequestDtoBrandingSettings as json.
func (o OptUpdateRemnawaveSettingsRequestDtoBrandingSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoBrandingSettings from json.
func (o *OptUpdateRemnawaveSettingsRequestDtoBrandingSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRemnawaveSettingsRequestDtoBrandingSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRemnawaveSettingsRequestDtoBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRemnawaveSettingsRequestDtoBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsRequestDtoOauth2Settings as json.
func (o OptUpdateRemnawaveSettingsRequestDtoOauth2Settings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoOauth2Settings from json.
func (o *OptUpdateRemnawaveSettingsRequestDtoOauth2Settings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRemnawaveSettingsRequestDtoOauth2Settings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRemnawaveSettingsRequestDtoOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRemnawaveSettingsRequestDtoOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsRequestDtoPasskeySettings as json.
func (o OptUpdateRemnawaveSettingsRequestDtoPasskeySettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoPasskeySettings from json.
func (o *OptUpdateRemnawaveSettingsRequestDtoPasskeySettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRemnawaveSettingsRequestDtoPasskeySettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRemnawaveSettingsRequestDtoPasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRemnawaveSettingsRequestDtoPasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsRequestDtoPasswordSettings as json.
func (o OptUpdateRemnawaveSettingsRequestDtoPasswordSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoPasswordSettings from json.
func (o *OptUpdateRemnawaveSettingsRequestDtoPasswordSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRemnawaveSettingsRequestDtoPasswordSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRemnawaveSettingsRequestDtoPasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRemnawaveSettingsRequestDtoPasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateRemnawaveSettingsRequestDtoTgAuthSettings as json.
func (o OptUpdateRemnawaveSettingsRequestDtoTgAuthSettings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoTgAuthSettings from json.
func (o *OptUpdateRemnawaveSettingsRequestDtoTgAuthSettings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateRemnawaveSettingsRequestDtoTgAuthSettings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateRemnawaveSettingsRequestDtoTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateRemnawaveSettingsRequestDtoTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders as json.
func (o OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (o *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	o.Set = true
	o.Value = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRules as json.
func (o OptUpdateSubscriptionSettingsRequestDtoResponseRules) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRules from json.
func (o *OptUpdateSubscriptionSettingsRequestDtoResponseRules) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsRequestDtoResponseRules to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsRequestDtoResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsRequestDtoResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications as json.
func (o OptUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications from json.
func (o *OptUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications as json.
func (o OptUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications from json.
func (o *OptUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (o OptUpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (o *OptUpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (o OptUpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (o *OptUpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserResponseDtoResponseStatus as json.
func (o OptUpdateUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserResponseDtoResponseStatus from json.
func (o *OptUpdateUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserResponseDtoResponseStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserResponseDtoResponseTrafficLimitStrategy as json.
func (o OptUpdateUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UpdateUserResponseDtoResponseTrafficLimitStrategy from json.
func (o *OptUpdateUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerDeletePasskeyBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerDeletePasskeyBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPasskeyControllerDeletePasskeyBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes PasskeyControllerDeletePasskeyBadRequest from json.
func (s *PasskeyControllerDeletePasskeyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerDeletePasskeyBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]PasskeyControllerDeletePasskeyBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PasskeyControllerDeletePasskeyBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerDeletePasskeyBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerDeletePasskeyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerDeletePasskeyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerDeletePasskeyBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerDeletePasskeyBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPasskeyControllerDeletePasskeyBadRequestErrorsItem = [0]string{}

// Decode decodes PasskeyControllerDeletePasskeyBadRequestErrorsItem from json.
func (s *PasskeyControllerDeletePasskeyBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerDeletePasskeyBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerDeletePasskeyBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerDeletePasskeyBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerDeletePasskeyBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerDeletePasskeyInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerDeletePasskeyInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPasskeyControllerDeletePasskeyInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes PasskeyControllerDeletePasskeyInternalServerError from json.
func (s *PasskeyControllerDeletePasskeyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerDeletePasskeyInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerDeletePasskeyInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerDeletePasskeyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerDeletePasskeyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerGetActivePasskeysBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPasskeyControllerGetActivePasskeysBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes PasskeyControllerGetActivePasskeysBadRequest from json.
func (s *PasskeyControllerGetActivePasskeysBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerGetActivePasskeysBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]PasskeyControllerGetActivePasskeysBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PasskeyControllerGetActivePasskeysBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerGetActivePasskeysBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerGetActivePasskeysBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPasskeyControllerGetActivePasskeysBadRequestErrorsItem = [0]string{}

// Decode decodes PasskeyControllerGetActivePasskeysBadRequestErrorsItem from json.
func (s *PasskeyControllerGetActivePasskeysBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerGetActivePasskeysBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerGetActivePasskeysBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerGetActivePasskeysBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerGetActivePasskeysInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerGetActivePasskeysInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPasskeyControllerGetActivePasskeysInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes PasskeyControllerGetActivePasskeysInternalServerError from json.
func (s *PasskeyControllerGetActivePasskeysInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerGetActivePasskeysInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerGetActivePasskeysInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerGetActivePasskeysInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerGetActivePasskeysInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationOptionsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes PasskeyControllerPasskeyRegistrationOptionsBadRequest from json.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationOptionsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationOptionsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem = [0]string{}

// Decode decodes PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem from json.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationOptionsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationOptionsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes PasskeyControllerPasskeyRegistrationOptionsInternalServerError from json.
func (s *PasskeyControllerPasskeyRegistrationOptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationOptionsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationOptionsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationOptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationVerifyBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes PasskeyControllerPasskeyRegistrationVerifyBadRequest from json.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationVerifyBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationVerifyBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem = [0]string{}

// Decode decodes PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem from json.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *PasskeyControllerPasskeyRegistrationVerifyInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfPasskeyControllerPasskeyRegistrationVerifyInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes PasskeyControllerPasskeyRegistrationVerifyInternalServerError from json.
func (s *PasskeyControllerPasskeyRegistrationVerifyInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode PasskeyControllerPasskeyRegistrationVerifyInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode PasskeyControllerPasskeyRegistrationVerifyInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *PasskeyControllerPasskeyRegistrationVerifyInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RegisterRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RegisterRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		e.FieldStart("password")
		e.Str(s.Password)
	}
}

var jsonFieldsNameOfRegisterRequestDto = [2]string{
	0: "username",
	1: "password",
}

// Decode decodes RegisterRequestDto from json.
func (s *RegisterRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RegisterRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "password":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Password = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RegisterRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRegisterRequestDto) {
					name = jsonFieldsNameOfRegisterRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RegisterRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RegisterRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerGetSettingsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRemnawaveSettingsControllerGetSettingsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes RemnawaveSettingsControllerGetSettingsBadRequest from json.
func (s *RemnawaveSettingsControllerGetSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerGetSettingsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerGetSettingsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemnawaveSettingsControllerGetSettingsBadRequestErrorsItem = [0]string{}

// Decode decodes RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem from json.
func (s *RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerGetSettingsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerGetSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemnawaveSettingsControllerGetSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes RemnawaveSettingsControllerGetSettingsInternalServerError from json.
func (s *RemnawaveSettingsControllerGetSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerGetSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerGetSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerGetSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerGetSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfRemnawaveSettingsControllerUpdateSettingsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes RemnawaveSettingsControllerUpdateSettingsBadRequest from json.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerUpdateSettingsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerUpdateSettingsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfRemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem = [0]string{}

// Decode decodes RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem from json.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemnawaveSettingsControllerUpdateSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfRemnawaveSettingsControllerUpdateSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes RemnawaveSettingsControllerUpdateSettingsInternalServerError from json.
func (s *RemnawaveSettingsControllerUpdateSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemnawaveSettingsControllerUpdateSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemnawaveSettingsControllerUpdateSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemnawaveSettingsControllerUpdateSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromExternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromExternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes RemoveUsersFromExternalSquadResponseDto from json.
func (s *RemoveUsersFromExternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromExternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromExternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDto) {
					name = jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromExternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromExternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromExternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromExternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RemoveUsersFromExternalSquadResponseDtoResponse from json.
func (s *RemoveUsersFromExternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromExternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromExternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfRemoveUsersFromExternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromExternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromExternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes RemoveUsersFromInternalSquadResponseDto from json.
func (s *RemoveUsersFromInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto) {
					name = jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RemoveUsersFromInternalSquadResponseDtoResponse from json.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RemoveUsersFromInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RemoveUsersFromInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfRemoveUsersFromInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RemoveUsersFromInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("hosts")
		e.ArrStart()
		for _, elem := range s.Hosts {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderHostRequestDto = [1]string{
	0: "hosts",
}

// Decode decodes ReorderHostRequestDto from json.
func (s *ReorderHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "hosts":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Hosts = make([]ReorderHostRequestDtoHostsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderHostRequestDtoHostsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Hosts = append(s.Hosts, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDto) {
					name = jsonFieldsNameOfReorderHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostRequestDtoHostsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderHostRequestDtoHostsItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderHostRequestDtoHostsItem from json.
func (s *ReorderHostRequestDtoHostsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostRequestDtoHostsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostRequestDtoHostsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostRequestDtoHostsItem) {
					name = jsonFieldsNameOfReorderHostRequestDtoHostsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostRequestDtoHostsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostRequestDtoHostsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfReorderHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderHostResponseDto from json.
func (s *ReorderHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDto) {
					name = jsonFieldsNameOfReorderHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("isUpdated")
		e.Bool(s.IsUpdated)
	}
}

var jsonFieldsNameOfReorderHostResponseDtoResponse = [1]string{
	0: "isUpdated",
}

// Decode decodes ReorderHostResponseDtoResponse from json.
func (s *ReorderHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderHostResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "isUpdated":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsUpdated = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isUpdated\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderHostResponseDtoResponse) {
					name = jsonFieldsNameOfReorderHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeRequestDto = [1]string{
	0: "nodes",
}

// Decode decodes ReorderNodeRequestDto from json.
func (s *ReorderNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]ReorderNodeRequestDtoNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeRequestDtoNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDto) {
					name = jsonFieldsNameOfReorderNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeRequestDtoNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
}

var jsonFieldsNameOfReorderNodeRequestDtoNodesItem = [2]string{
	0: "viewPosition",
	1: "uuid",
}

// Decode decodes ReorderNodeRequestDtoNodesItem from json.
func (s *ReorderNodeRequestDtoNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeRequestDtoNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "viewPosition":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "uuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeRequestDtoNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeRequestDtoNodesItem) {
					name = jsonFieldsNameOfReorderNodeRequestDtoNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeRequestDtoNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeRequestDtoNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes ReorderNodeResponseDto from json.
func (s *ReorderNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]ReorderNodeResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDto) {
					name = jsonFieldsNameOfReorderNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItem = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes ReorderNodeResponseDtoResponseItem from json.
func (s *ReorderNodeResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes ReorderNodeResponseDtoResponseItemConfigProfile from json.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem from json.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ReorderNodeResponseDtoResponseItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes ReorderNodeResponseDtoResponseItemProvider from json.
func (s *ReorderNodeResponseDtoResponseItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ReorderNodeResponseDtoResponseItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ReorderNodeResponseDtoResponseItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider) {
					name = jsonFieldsNameOfReorderNodeResponseDtoResponseItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ReorderNodeResponseDtoResponseItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDto = [1]string{
	0: "response",
}

// Decode decodes ResetUserTrafficResponseDto from json.
func (s *ResetUserTrafficResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDto) {
					name = jsonFieldsNameOfResetUserTrafficResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes ResetUserTrafficResponseDtoResponse from json.
func (s *ResetUserTrafficResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponse) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem from json.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes ResetUserTrafficResponseDtoResponseHapp from json.
func (s *ResetUserTrafficResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes ResetUserTrafficResponseDtoResponseLastConnectedNode from json.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ResetUserTrafficResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfResetUserTrafficResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseStatus as json.
func (s ResetUserTrafficResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseStatus from json.
func (s *ResetUserTrafficResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseStatus(v) {
	case ResetUserTrafficResponseDtoResponseStatusACTIVE:
		*s = ResetUserTrafficResponseDtoResponseStatusACTIVE
	case ResetUserTrafficResponseDtoResponseStatusDISABLED:
		*s = ResetUserTrafficResponseDtoResponseStatusDISABLED
	case ResetUserTrafficResponseDtoResponseStatusLIMITED:
		*s = ResetUserTrafficResponseDtoResponseStatusLIMITED
	case ResetUserTrafficResponseDtoResponseStatusEXPIRED:
		*s = ResetUserTrafficResponseDtoResponseStatusEXPIRED
	default:
		*s = ResetUserTrafficResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy as json.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ResetUserTrafficResponseDtoResponseTrafficLimitStrategy from json.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ResetUserTrafficResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v) {
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyNORESET
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyDAY
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyWEEK
	case ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = ResetUserTrafficResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ResetUserTrafficResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesRequestBodyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesRequestBodyDto) encodeFields(e *jx.Encoder) {
	{
		if s.ForceRestart.Set {
			e.FieldStart("forceRestart")
			s.ForceRestart.Encode(e)
		}
	}
}

var jsonFieldsNameOfRestartAllNodesRequestBodyDto = [1]string{
	0: "forceRestart",
}

// Decode decodes RestartAllNodesRequestBodyDto from json.
func (s *RestartAllNodesRequestBodyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesRequestBodyDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "forceRestart":
			if err := func() error {
				s.ForceRestart.Reset()
				if err := s.ForceRestart.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"forceRestart\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesRequestBodyDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesRequestBodyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesRequestBodyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartAllNodesResponseDto from json.
func (s *RestartAllNodesResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDto) {
					name = jsonFieldsNameOfRestartAllNodesResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartAllNodesResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartAllNodesResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartAllNodesResponseDtoResponse from json.
func (s *RestartAllNodesResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartAllNodesResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartAllNodesResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartAllNodesResponseDtoResponse) {
					name = jsonFieldsNameOfRestartAllNodesResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartAllNodesResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartAllNodesResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRestartNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes RestartNodeResponseDto from json.
func (s *RestartNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDto) {
					name = jsonFieldsNameOfRestartNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RestartNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RestartNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("eventSent")
		e.Bool(s.EventSent)
	}
}

var jsonFieldsNameOfRestartNodeResponseDtoResponse = [1]string{
	0: "eventSent",
}

// Decode decodes RestartNodeResponseDtoResponse from json.
func (s *RestartNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RestartNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "eventSent":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.EventSent = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"eventSent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RestartNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRestartNodeResponseDtoResponse) {
					name = jsonFieldsNameOfRestartNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RestartNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RestartNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionBodyDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionBodyDto) encodeFields(e *jx.Encoder) {
	{
		if s.ShortUuid.Set {
			e.FieldStart("shortUuid")
			s.ShortUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionBodyDto = [1]string{
	0: "shortUuid",
}

// Decode decodes RevokeUserSubscriptionBodyDto from json.
func (s *RevokeUserSubscriptionBodyDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionBodyDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "shortUuid":
			if err := func() error {
				s.ShortUuid.Reset()
				if err := s.ShortUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionBodyDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionBodyDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionBodyDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDto = [1]string{
	0: "response",
}

// Decode decodes RevokeUserSubscriptionResponseDto from json.
func (s *RevokeUserSubscriptionResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDto) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponse from json.
func (s *RevokeUserSubscriptionResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem from json.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseHapp from json.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseLastConnectedNode from json.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode RevokeUserSubscriptionResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfRevokeUserSubscriptionResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseStatus as json.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseStatus from json.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseStatus(v) {
	case RevokeUserSubscriptionResponseDtoResponseStatusACTIVE:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusACTIVE
	case RevokeUserSubscriptionResponseDtoResponseStatusDISABLED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusDISABLED
	case RevokeUserSubscriptionResponseDtoResponseStatusLIMITED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusLIMITED
	case RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED:
		*s = RevokeUserSubscriptionResponseDtoResponseStatusEXPIRED
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy as json.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy from json.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v) {
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyNORESET
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyDAY
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyWEEK
	case RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *RevokeUserSubscriptionResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsRequestDto = [3]string{
	0: "uuids",
	1: "configProfileUuid",
	2: "configProfileInboundUuid",
}

// Decode decodes SetInboundToManyHostsRequestDto from json.
func (s *SetInboundToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetInboundToManyHostsResponseDto from json.
func (s *SetInboundToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetInboundToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetInboundToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItem from json.
func (s *SetInboundToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemInbound from json.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetInboundToManyHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfSetInboundToManyHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetInboundToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetInboundToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetInboundToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetInboundToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
}

var jsonFieldsNameOfSetPortToManyHostsRequestDto = [2]string{
	0: "uuids",
	1: "port",
}

// Decode decodes SetPortToManyHostsRequestDto from json.
func (s *SetPortToManyHostsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsRequestDto) {
					name = jsonFieldsNameOfSetPortToManyHostsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		e.ArrStart()
		for _, elem := range s.Response {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDto = [1]string{
	0: "response",
}

// Decode decodes SetPortToManyHostsResponseDto from json.
func (s *SetPortToManyHostsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Response = make([]SetPortToManyHostsResponseDtoResponseItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SetPortToManyHostsResponseDtoResponseItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Response = append(s.Response, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDto) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDtoResponseItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItem from json.
func (s *SetPortToManyHostsResponseDtoResponseItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItem to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDtoResponseItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemInbound from json.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItemInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SetPortToManyHostsResponseDtoResponseItemInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound) {
					name = jsonFieldsNameOfSetPortToManyHostsResponseDtoResponseItemInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer as json.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes SetPortToManyHostsResponseDtoResponseItemSecurityLayer from json.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SetPortToManyHostsResponseDtoResponseItemSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v) {
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerDEFAULT
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerTLS
	case SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayerNONE
	default:
		*s = SetPortToManyHostsResponseDtoResponseItemSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SetPortToManyHostsResponseDtoResponseItemSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SetPortToManyHostsResponseDtoResponseItemSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerCreateSnippetBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerCreateSnippetBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSnippetsControllerCreateSnippetBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SnippetsControllerCreateSnippetBadRequest from json.
func (s *SnippetsControllerCreateSnippetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerCreateSnippetBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SnippetsControllerCreateSnippetBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SnippetsControllerCreateSnippetBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerCreateSnippetBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerCreateSnippetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerCreateSnippetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerCreateSnippetBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerCreateSnippetBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSnippetsControllerCreateSnippetBadRequestErrorsItem = [0]string{}

// Decode decodes SnippetsControllerCreateSnippetBadRequestErrorsItem from json.
func (s *SnippetsControllerCreateSnippetBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerCreateSnippetBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerCreateSnippetBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerCreateSnippetBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerCreateSnippetBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerCreateSnippetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerCreateSnippetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnippetsControllerCreateSnippetInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SnippetsControllerCreateSnippetInternalServerError from json.
func (s *SnippetsControllerCreateSnippetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerCreateSnippetInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerCreateSnippetInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerCreateSnippetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerCreateSnippetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerDeleteSnippetByNameBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSnippetsControllerDeleteSnippetByNameBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SnippetsControllerDeleteSnippetByNameBadRequest from json.
func (s *SnippetsControllerDeleteSnippetByNameBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerDeleteSnippetByNameBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerDeleteSnippetByNameBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSnippetsControllerDeleteSnippetByNameBadRequestErrorsItem = [0]string{}

// Decode decodes SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem from json.
func (s *SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerDeleteSnippetByNameBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerDeleteSnippetByNameInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnippetsControllerDeleteSnippetByNameInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SnippetsControllerDeleteSnippetByNameInternalServerError from json.
func (s *SnippetsControllerDeleteSnippetByNameInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerDeleteSnippetByNameInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerDeleteSnippetByNameInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerDeleteSnippetByNameInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerDeleteSnippetByNameInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerGetSnippetsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerGetSnippetsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSnippetsControllerGetSnippetsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SnippetsControllerGetSnippetsBadRequest from json.
func (s *SnippetsControllerGetSnippetsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerGetSnippetsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SnippetsControllerGetSnippetsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SnippetsControllerGetSnippetsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerGetSnippetsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerGetSnippetsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerGetSnippetsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerGetSnippetsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerGetSnippetsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSnippetsControllerGetSnippetsBadRequestErrorsItem = [0]string{}

// Decode decodes SnippetsControllerGetSnippetsBadRequestErrorsItem from json.
func (s *SnippetsControllerGetSnippetsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerGetSnippetsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerGetSnippetsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerGetSnippetsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerGetSnippetsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerGetSnippetsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerGetSnippetsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnippetsControllerGetSnippetsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SnippetsControllerGetSnippetsInternalServerError from json.
func (s *SnippetsControllerGetSnippetsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerGetSnippetsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerGetSnippetsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerGetSnippetsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerGetSnippetsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerUpdateSnippetBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerUpdateSnippetBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSnippetsControllerUpdateSnippetBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SnippetsControllerUpdateSnippetBadRequest from json.
func (s *SnippetsControllerUpdateSnippetBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerUpdateSnippetBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SnippetsControllerUpdateSnippetBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SnippetsControllerUpdateSnippetBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerUpdateSnippetBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerUpdateSnippetBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerUpdateSnippetBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerUpdateSnippetBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerUpdateSnippetBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSnippetsControllerUpdateSnippetBadRequestErrorsItem = [0]string{}

// Decode decodes SnippetsControllerUpdateSnippetBadRequestErrorsItem from json.
func (s *SnippetsControllerUpdateSnippetBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerUpdateSnippetBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerUpdateSnippetBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerUpdateSnippetBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerUpdateSnippetBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SnippetsControllerUpdateSnippetInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SnippetsControllerUpdateSnippetInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSnippetsControllerUpdateSnippetInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SnippetsControllerUpdateSnippetInternalServerError from json.
func (s *SnippetsControllerUpdateSnippetInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SnippetsControllerUpdateSnippetInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SnippetsControllerUpdateSnippetInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SnippetsControllerUpdateSnippetInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SnippetsControllerUpdateSnippetInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest from json.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem from json.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError from json.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionControllerGetSubscriptionInfoByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerGetSettingsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerGetSettingsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionSettingsControllerGetSettingsBadRequest from json.
func (s *SubscriptionSettingsControllerGetSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerGetSettingsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerGetSettingsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionSettingsControllerGetSettingsBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem from json.
func (s *SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerGetSettingsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerGetSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionSettingsControllerGetSettingsInternalServerError from json.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerGetSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerGetSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerGetSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerUpdateSettingsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionSettingsControllerUpdateSettingsBadRequest from json.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerUpdateSettingsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerUpdateSettingsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem from json.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionSettingsControllerUpdateSettingsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionSettingsControllerUpdateSettingsInternalServerError from json.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionSettingsControllerUpdateSettingsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionSettingsControllerUpdateSettingsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionSettingsControllerUpdateSettingsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerCreateTemplateBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionTemplateControllerCreateTemplateBadRequest from json.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerCreateTemplateBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerCreateTemplateBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem from json.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerCreateTemplateBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerCreateTemplateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerCreateTemplateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerCreateTemplateInternalServerError from json.
func (s *SubscriptionTemplateControllerCreateTemplateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerCreateTemplateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerCreateTemplateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerCreateTemplateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerCreateTemplateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerDeleteTemplateBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionTemplateControllerDeleteTemplateBadRequest from json.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerDeleteTemplateBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerDeleteTemplateBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem from json.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerDeleteTemplateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerDeleteTemplateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerDeleteTemplateInternalServerError from json.
func (s *SubscriptionTemplateControllerDeleteTemplateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerDeleteTemplateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerDeleteTemplateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerDeleteTemplateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetAllTemplatesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionTemplateControllerGetAllTemplatesBadRequest from json.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetAllTemplatesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetAllTemplatesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem from json.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetAllTemplatesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetAllTemplatesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerGetAllTemplatesInternalServerError from json.
func (s *SubscriptionTemplateControllerGetAllTemplatesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetAllTemplatesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetAllTemplatesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetAllTemplatesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetTemplateByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionTemplateControllerGetTemplateByUuidBadRequest from json.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetTemplateByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetTemplateByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem from json.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerGetTemplateByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerGetTemplateByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerGetTemplateByUuidInternalServerError from json.
func (s *SubscriptionTemplateControllerGetTemplateByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerGetTemplateByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerGetTemplateByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerGetTemplateByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerUpdateTemplateBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionTemplateControllerUpdateTemplateBadRequest from json.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerUpdateTemplateBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerUpdateTemplateBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem from json.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionTemplateControllerUpdateTemplateInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionTemplateControllerUpdateTemplateInternalServerError from json.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionTemplateControllerUpdateTemplateInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionTemplateControllerUpdateTemplateInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionTemplateControllerUpdateTemplateInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetAllSubscriptionsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionsControllerGetAllSubscriptionsBadRequest from json.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetAllSubscriptionsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetAllSubscriptionsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem from json.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetAllSubscriptionsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetAllSubscriptionsInternalServerError from json.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetAllSubscriptionsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetAllSubscriptionsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetAllSubscriptionsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest from json.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem from json.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError from json.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetRawSubscriptionByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest from json.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem from json.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError from json.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound from json.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByShortUuidProtectedNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameBadRequest from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameInternalServerError from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUsernameNotFound = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUsernameNotFound from json.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUsernameNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUsernameNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUsernameNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUuidBadRequest from json.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem from json.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUuidInternalServerError from json.
func (s *SubscriptionsControllerGetSubscriptionByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SubscriptionsControllerGetSubscriptionByUuidNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSubscriptionsControllerGetSubscriptionByUuidNotFound = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SubscriptionsControllerGetSubscriptionByUuidNotFound from json.
func (s *SubscriptionsControllerGetSubscriptionByUuidNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SubscriptionsControllerGetSubscriptionByUuidNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SubscriptionsControllerGetSubscriptionByUuidNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SubscriptionsControllerGetSubscriptionByUuidNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerDebugSrrMatcherBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerDebugSrrMatcherBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerDebugSrrMatcherBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerDebugSrrMatcherBadRequest from json.
func (s *SystemControllerDebugSrrMatcherBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerDebugSrrMatcherBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerDebugSrrMatcherBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerDebugSrrMatcherBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerDebugSrrMatcherBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerDebugSrrMatcherBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerDebugSrrMatcherBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerDebugSrrMatcherBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerDebugSrrMatcherBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerDebugSrrMatcherBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerDebugSrrMatcherBadRequestErrorsItem from json.
func (s *SystemControllerDebugSrrMatcherBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerDebugSrrMatcherBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerDebugSrrMatcherBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerDebugSrrMatcherBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerDebugSrrMatcherBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerDebugSrrMatcherInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerDebugSrrMatcherInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerDebugSrrMatcherInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerDebugSrrMatcherInternalServerError from json.
func (s *SystemControllerDebugSrrMatcherInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerDebugSrrMatcherInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerDebugSrrMatcherInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerDebugSrrMatcherInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerDebugSrrMatcherInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerEncryptHappCryptoLinkBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerEncryptHappCryptoLinkBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerEncryptHappCryptoLinkBadRequest from json.
func (s *SystemControllerEncryptHappCryptoLinkBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerEncryptHappCryptoLinkBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerEncryptHappCryptoLinkBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerEncryptHappCryptoLinkBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem from json.
func (s *SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerEncryptHappCryptoLinkBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerEncryptHappCryptoLinkInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerEncryptHappCryptoLinkInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerEncryptHappCryptoLinkInternalServerError from json.
func (s *SystemControllerEncryptHappCryptoLinkInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerEncryptHappCryptoLinkInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerEncryptHappCryptoLinkInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerEncryptHappCryptoLinkInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerEncryptHappCryptoLinkInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetBandwidthStatsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetBandwidthStatsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetBandwidthStatsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetBandwidthStatsBadRequest from json.
func (s *SystemControllerGetBandwidthStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetBandwidthStatsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetBandwidthStatsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetBandwidthStatsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetBandwidthStatsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetBandwidthStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetBandwidthStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetBandwidthStatsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetBandwidthStatsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetBandwidthStatsBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetBandwidthStatsBadRequestErrorsItem from json.
func (s *SystemControllerGetBandwidthStatsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetBandwidthStatsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetBandwidthStatsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetBandwidthStatsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetBandwidthStatsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetBandwidthStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetBandwidthStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetBandwidthStatsInternalServerError from json.
func (s *SystemControllerGetBandwidthStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetBandwidthStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetBandwidthStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetBandwidthStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesMetricsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesMetricsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesMetricsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetNodesMetricsBadRequest from json.
func (s *SystemControllerGetNodesMetricsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesMetricsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetNodesMetricsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetNodesMetricsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesMetricsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesMetricsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesMetricsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesMetricsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesMetricsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetNodesMetricsBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetNodesMetricsBadRequestErrorsItem from json.
func (s *SystemControllerGetNodesMetricsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesMetricsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesMetricsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesMetricsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesMetricsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesMetricsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesMetricsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetNodesMetricsInternalServerError from json.
func (s *SystemControllerGetNodesMetricsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesMetricsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesMetricsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesMetricsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesStatisticsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesStatisticsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesStatisticsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetNodesStatisticsBadRequest from json.
func (s *SystemControllerGetNodesStatisticsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesStatisticsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetNodesStatisticsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetNodesStatisticsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesStatisticsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesStatisticsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesStatisticsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesStatisticsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesStatisticsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetNodesStatisticsBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetNodesStatisticsBadRequestErrorsItem from json.
func (s *SystemControllerGetNodesStatisticsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesStatisticsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesStatisticsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesStatisticsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesStatisticsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetNodesStatisticsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetNodesStatisticsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetNodesStatisticsInternalServerError from json.
func (s *SystemControllerGetNodesStatisticsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetNodesStatisticsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetNodesStatisticsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetNodesStatisticsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetRemnawaveHealthBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetRemnawaveHealthBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetRemnawaveHealthBadRequest from json.
func (s *SystemControllerGetRemnawaveHealthBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetRemnawaveHealthBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetRemnawaveHealthBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetRemnawaveHealthBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetRemnawaveHealthBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetRemnawaveHealthBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetRemnawaveHealthBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetRemnawaveHealthBadRequestErrorsItem from json.
func (s *SystemControllerGetRemnawaveHealthBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetRemnawaveHealthBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetRemnawaveHealthBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetRemnawaveHealthBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetRemnawaveHealthInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetRemnawaveHealthInternalServerError from json.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetRemnawaveHealthInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetRemnawaveHealthInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetRemnawaveHealthInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetStatsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetStatsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetStatsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetStatsBadRequest from json.
func (s *SystemControllerGetStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetStatsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetStatsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetStatsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetStatsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetStatsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetStatsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetStatsBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetStatsBadRequestErrorsItem from json.
func (s *SystemControllerGetStatsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetStatsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetStatsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetStatsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetStatsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetStatsInternalServerError from json.
func (s *SystemControllerGetStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetX25519KeypairsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetX25519KeypairsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfSystemControllerGetX25519KeypairsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes SystemControllerGetX25519KeypairsBadRequest from json.
func (s *SystemControllerGetX25519KeypairsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetX25519KeypairsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]SystemControllerGetX25519KeypairsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem SystemControllerGetX25519KeypairsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetX25519KeypairsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetX25519KeypairsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetX25519KeypairsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetX25519KeypairsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetX25519KeypairsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfSystemControllerGetX25519KeypairsBadRequestErrorsItem = [0]string{}

// Decode decodes SystemControllerGetX25519KeypairsBadRequestErrorsItem from json.
func (s *SystemControllerGetX25519KeypairsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetX25519KeypairsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetX25519KeypairsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetX25519KeypairsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetX25519KeypairsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SystemControllerGetX25519KeypairsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SystemControllerGetX25519KeypairsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfSystemControllerGetX25519KeypairsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes SystemControllerGetX25519KeypairsInternalServerError from json.
func (s *SystemControllerGetX25519KeypairsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SystemControllerGetX25519KeypairsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SystemControllerGetX25519KeypairsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SystemControllerGetX25519KeypairsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SystemControllerGetX25519KeypairsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TelegramCallbackRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TelegramCallbackRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Float64(s.ID)
	}
	{
		e.FieldStart("first_name")
		e.Str(s.FirstName)
	}
	{
		if s.LastName.Set {
			e.FieldStart("last_name")
			s.LastName.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.PhotoURL.Set {
			e.FieldStart("photo_url")
			s.PhotoURL.Encode(e)
		}
	}
	{
		e.FieldStart("auth_date")
		e.Float64(s.AuthDate)
	}
	{
		e.FieldStart("hash")
		e.Str(s.Hash)
	}
}

var jsonFieldsNameOfTelegramCallbackRequestDto = [7]string{
	0: "id",
	1: "first_name",
	2: "last_name",
	3: "username",
	4: "photo_url",
	5: "auth_date",
	6: "hash",
}

// Decode decodes TelegramCallbackRequestDto from json.
func (s *TelegramCallbackRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TelegramCallbackRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.ID = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "first_name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.FirstName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"first_name\"")
			}
		case "last_name":
			if err := func() error {
				s.LastName.Reset()
				if err := s.LastName.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"last_name\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "photo_url":
			if err := func() error {
				s.PhotoURL.Reset()
				if err := s.PhotoURL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"photo_url\"")
			}
		case "auth_date":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.AuthDate = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"auth_date\"")
			}
		case "hash":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Hash = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hash\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TelegramCallbackRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01100011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfTelegramCallbackRequestDto) {
					name = jsonFieldsNameOfTelegramCallbackRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TelegramCallbackRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TelegramCallbackRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Config != nil {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateConfigProfileRequestDto = [3]string{
	0: "uuid",
	1: "name",
	2: "config",
}

// Decode decodes UpdateConfigProfileRequestDto from json.
func (s *UpdateConfigProfileRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			if err := func() error {
				s.Config = nil
				var elem UpdateConfigProfileRequestDtoConfig
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Config = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileRequestDto) {
					name = jsonFieldsNameOfUpdateConfigProfileRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileRequestDtoConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileRequestDtoConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateConfigProfileRequestDtoConfig = [0]string{}

// Decode decodes UpdateConfigProfileRequestDtoConfig from json.
func (s *UpdateConfigProfileRequestDtoConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileRequestDtoConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileRequestDtoConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileRequestDtoConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileRequestDtoConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateConfigProfileResponseDto from json.
func (s *UpdateConfigProfileResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDto) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Config) != 0 {
			e.FieldStart("config")
			e.Raw(s.Config)
		}
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "config",
	3: "inbounds",
	4: "nodes",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes UpdateConfigProfileResponseDtoResponse from json.
func (s *UpdateConfigProfileResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "config":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Config = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]UpdateConfigProfileResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateConfigProfileResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "nodes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Nodes = make([]UpdateConfigProfileResponseDtoResponseNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateConfigProfileResponseDtoResponseNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateConfigProfileResponseDtoResponseInboundsItem from json.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateConfigProfileResponseDtoResponseNodesItem from json.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConfigProfileResponseDtoResponseNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConfigProfileResponseDtoResponseNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem) {
					name = jsonFieldsNameOfUpdateConfigProfileResponseDtoResponseNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConfigProfileResponseDtoResponseNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Templates != nil {
			e.FieldStart("templates")
			e.ArrStart()
			for _, elem := range s.Templates {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionSettings.Set {
			e.FieldStart("subscriptionSettings")
			s.SubscriptionSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateExternalSquadRequestDto = [4]string{
	0: "uuid",
	1: "name",
	2: "templates",
	3: "subscriptionSettings",
}

// Decode decodes UpdateExternalSquadRequestDto from json.
func (s *UpdateExternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templates":
			if err := func() error {
				s.Templates = make([]UpdateExternalSquadRequestDtoTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateExternalSquadRequestDtoTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "subscriptionSettings":
			if err := func() error {
				s.SubscriptionSettings.Reset()
				if err := s.SubscriptionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionSettings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadRequestDto) {
					name = jsonFieldsNameOfUpdateExternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadRequestDtoSubscriptionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadRequestDtoSubscriptionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateExternalSquadRequestDtoSubscriptionSettings = [10]string{
	0: "profileTitle",
	1: "supportLink",
	2: "profileUpdateInterval",
	3: "isProfileWebpageUrlEnabled",
	4: "serveJsonAtBaseSubscription",
	5: "addUsernameToBaseSubscription",
	6: "isShowCustomRemarks",
	7: "happAnnounce",
	8: "happRouting",
	9: "randomizeHosts",
}

// Decode decodes UpdateExternalSquadRequestDtoSubscriptionSettings from json.
func (s *UpdateExternalSquadRequestDtoSubscriptionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadRequestDtoSubscriptionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadRequestDtoSubscriptionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadRequestDtoSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadRequestDtoSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadRequestDtoTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadRequestDtoTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateUuid")
		json.EncodeUUID(e, s.TemplateUuid)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfUpdateExternalSquadRequestDtoTemplatesItem = [2]string{
	0: "templateUuid",
	1: "templateType",
}

// Decode decodes UpdateExternalSquadRequestDtoTemplatesItem from json.
func (s *UpdateExternalSquadRequestDtoTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadRequestDtoTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateUuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadRequestDtoTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadRequestDtoTemplatesItem) {
					name = jsonFieldsNameOfUpdateExternalSquadRequestDtoTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadRequestDtoTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadRequestDtoTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExternalSquadRequestDtoTemplatesItemTemplateType as json.
func (s UpdateExternalSquadRequestDtoTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateExternalSquadRequestDtoTemplatesItemTemplateType from json.
func (s *UpdateExternalSquadRequestDtoTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadRequestDtoTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateExternalSquadRequestDtoTemplatesItemTemplateType(v) {
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeXRAYJSON:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeXRAYJSON
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeXRAYBASE64:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeXRAYBASE64
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeMIHOMO:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeMIHOMO
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeSTASH:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeSTASH
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeCLASH:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeCLASH
	case UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeSINGBOX:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateTypeSINGBOX
	default:
		*s = UpdateExternalSquadRequestDtoTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateExternalSquadRequestDtoTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadRequestDtoTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateExternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateExternalSquadResponseDto from json.
func (s *UpdateExternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadResponseDto) {
					name = jsonFieldsNameOfUpdateExternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("templates")
		e.ArrStart()
		for _, elem := range s.Templates {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("subscriptionSettings")
		s.SubscriptionSettings.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateExternalSquadResponseDtoResponse = [7]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "templates",
	4: "subscriptionSettings",
	5: "createdAt",
	6: "updatedAt",
}

// Decode decodes UpdateExternalSquadResponseDtoResponse from json.
func (s *UpdateExternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "templates":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Templates = make([]UpdateExternalSquadResponseDtoResponseTemplatesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateExternalSquadResponseDtoResponseTemplatesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Templates = append(s.Templates, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templates\"")
			}
		case "subscriptionSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.SubscriptionSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionSettings\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateExternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
}

var jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseInfo = [1]string{
	0: "membersCount",
}

// Decode decodes UpdateExternalSquadResponseDtoResponseInfo from json.
func (s *UpdateExternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseSubscriptionSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadResponseDtoResponseSubscriptionSettings) encodeFields(e *jx.Encoder) {
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseSubscriptionSettings = [10]string{
	0: "profileTitle",
	1: "supportLink",
	2: "profileUpdateInterval",
	3: "isProfileWebpageUrlEnabled",
	4: "serveJsonAtBaseSubscription",
	5: "addUsernameToBaseSubscription",
	6: "isShowCustomRemarks",
	7: "happAnnounce",
	8: "happRouting",
	9: "randomizeHosts",
}

// Decode decodes UpdateExternalSquadResponseDtoResponseSubscriptionSettings from json.
func (s *UpdateExternalSquadResponseDtoResponseSubscriptionSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDtoResponseSubscriptionSettings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadResponseDtoResponseSubscriptionSettings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseSubscriptionSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDtoResponseSubscriptionSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("templateUuid")
		json.EncodeUUID(e, s.TemplateUuid)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
}

var jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseTemplatesItem = [2]string{
	0: "templateUuid",
	1: "templateType",
}

// Decode decodes UpdateExternalSquadResponseDtoResponseTemplatesItem from json.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDtoResponseTemplatesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "templateUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.TemplateUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateUuid\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateExternalSquadResponseDtoResponseTemplatesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseTemplatesItem) {
					name = jsonFieldsNameOfUpdateExternalSquadResponseDtoResponseTemplatesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType as json.
func (s UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType from json.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType(v) {
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYJSON
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeXRAYBASE64
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeMIHOMO:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeMIHOMO
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSTASH:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSTASH
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeCLASH:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeCLASH
	case UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSINGBOX:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateTypeSINGBOX
	default:
		*s = UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateExternalSquadResponseDtoResponseTemplatesItemTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Inbound.Set {
			e.FieldStart("inbound")
			s.Inbound.Encode(e)
		}
	}
	{
		if s.Remark.Set {
			e.FieldStart("remark")
			s.Remark.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Sni.Set {
			e.FieldStart("sni")
			s.Sni.Encode(e)
		}
	}
	{
		if s.Host.Set {
			e.FieldStart("host")
			s.Host.Encode(e)
		}
	}
	{
		if s.Alpn.Set {
			e.FieldStart("alpn")
			s.Alpn.Encode(e)
		}
	}
	{
		if s.Fingerprint.Set {
			e.FieldStart("fingerprint")
			s.Fingerprint.Encode(e)
		}
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		if s.ServerDescription.Set {
			e.FieldStart("serverDescription")
			s.ServerDescription.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		if s.VlessRouteId.Set {
			e.FieldStart("vlessRouteId")
			s.VlessRouteId.Encode(e)
		}
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		if s.ShuffleHost.Set {
			e.FieldStart("shuffleHost")
			s.ShuffleHost.Encode(e)
		}
	}
	{
		if s.MihomoX25519.Set {
			e.FieldStart("mihomoX25519")
			s.MihomoX25519.Encode(e)
		}
	}
	{
		if s.Nodes != nil {
			e.FieldStart("nodes")
			e.ArrStart()
			for _, elem := range s.Nodes {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateHostRequestDto = [24]string{
	0:  "uuid",
	1:  "inbound",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "serverDescription",
	16: "tag",
	17: "isHidden",
	18: "overrideSniFromAddress",
	19: "vlessRouteId",
	20: "allowInsecure",
	21: "shuffleHost",
	22: "mihomoX25519",
	23: "nodes",
}

// Decode decodes UpdateHostRequestDto from json.
func (s *UpdateHostRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDto to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "inbound":
			if err := func() error {
				s.Inbound.Reset()
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "remark":
			if err := func() error {
				s.Remark.Reset()
				if err := s.Remark.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			if err := func() error {
				s.Sni.Reset()
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			if err := func() error {
				s.Host.Reset()
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			if err := func() error {
				s.Alpn.Reset()
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			if err := func() error {
				s.Fingerprint.Reset()
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "serverDescription":
			if err := func() error {
				s.ServerDescription.Reset()
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			if err := func() error {
				s.VlessRouteId.Reset()
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			if err := func() error {
				s.ShuffleHost.Reset()
				if err := s.ShuffleHost.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			if err := func() error {
				s.MihomoX25519.Reset()
				if err := s.MihomoX25519.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b00000001,
		0b00000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostRequestDto) {
					name = jsonFieldsNameOfUpdateHostRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoAlpn as json.
func (s UpdateHostRequestDtoAlpn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoAlpn from json.
func (s *UpdateHostRequestDtoAlpn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoAlpn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoAlpn(v) {
	case UpdateHostRequestDtoAlpnH3:
		*s = UpdateHostRequestDtoAlpnH3
	case UpdateHostRequestDtoAlpnH2:
		*s = UpdateHostRequestDtoAlpnH2
	case UpdateHostRequestDtoAlpnHTTP11:
		*s = UpdateHostRequestDtoAlpnHTTP11
	case UpdateHostRequestDtoAlpnH2HTTP11:
		*s = UpdateHostRequestDtoAlpnH2HTTP11
	case UpdateHostRequestDtoAlpnH3H2HTTP11:
		*s = UpdateHostRequestDtoAlpnH3H2HTTP11
	case UpdateHostRequestDtoAlpnH3H2:
		*s = UpdateHostRequestDtoAlpnH3H2
	default:
		*s = UpdateHostRequestDtoAlpn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoAlpn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoAlpn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoFingerprint as json.
func (s UpdateHostRequestDtoFingerprint) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoFingerprint from json.
func (s *UpdateHostRequestDtoFingerprint) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoFingerprint to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoFingerprint(v) {
	case UpdateHostRequestDtoFingerprintChrome:
		*s = UpdateHostRequestDtoFingerprintChrome
	case UpdateHostRequestDtoFingerprintFirefox:
		*s = UpdateHostRequestDtoFingerprintFirefox
	case UpdateHostRequestDtoFingerprintSafari:
		*s = UpdateHostRequestDtoFingerprintSafari
	case UpdateHostRequestDtoFingerprintIos:
		*s = UpdateHostRequestDtoFingerprintIos
	case UpdateHostRequestDtoFingerprintAndroid:
		*s = UpdateHostRequestDtoFingerprintAndroid
	case UpdateHostRequestDtoFingerprintEdge:
		*s = UpdateHostRequestDtoFingerprintEdge
	case UpdateHostRequestDtoFingerprintQq:
		*s = UpdateHostRequestDtoFingerprintQq
	case UpdateHostRequestDtoFingerprintRandom:
		*s = UpdateHostRequestDtoFingerprintRandom
	case UpdateHostRequestDtoFingerprintRandomized:
		*s = UpdateHostRequestDtoFingerprintRandomized
	default:
		*s = UpdateHostRequestDtoFingerprint(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoFingerprint) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoFingerprint) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostRequestDtoInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostRequestDtoInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		json.EncodeUUID(e, s.ConfigProfileUuid)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		json.EncodeUUID(e, s.ConfigProfileInboundUuid)
	}
}

var jsonFieldsNameOfUpdateHostRequestDtoInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes UpdateHostRequestDtoInbound from json.
func (s *UpdateHostRequestDtoInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ConfigProfileInboundUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostRequestDtoInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostRequestDtoInbound) {
					name = jsonFieldsNameOfUpdateHostRequestDtoInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostRequestDtoInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostRequestDtoSecurityLayer as json.
func (s UpdateHostRequestDtoSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostRequestDtoSecurityLayer from json.
func (s *UpdateHostRequestDtoSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostRequestDtoSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostRequestDtoSecurityLayer(v) {
	case UpdateHostRequestDtoSecurityLayerDEFAULT:
		*s = UpdateHostRequestDtoSecurityLayerDEFAULT
	case UpdateHostRequestDtoSecurityLayerTLS:
		*s = UpdateHostRequestDtoSecurityLayerTLS
	case UpdateHostRequestDtoSecurityLayerNONE:
		*s = UpdateHostRequestDtoSecurityLayerNONE
	default:
		*s = UpdateHostRequestDtoSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostRequestDtoSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostRequestDtoSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateHostResponseDto from json.
func (s *UpdateHostResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDto) {
					name = jsonFieldsNameOfUpdateHostResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("remark")
		e.Str(s.Remark)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		e.Int(s.Port)
	}
	{
		e.FieldStart("path")
		s.Path.Encode(e)
	}
	{
		e.FieldStart("sni")
		s.Sni.Encode(e)
	}
	{
		e.FieldStart("host")
		s.Host.Encode(e)
	}
	{
		e.FieldStart("alpn")
		s.Alpn.Encode(e)
	}
	{
		e.FieldStart("fingerprint")
		s.Fingerprint.Encode(e)
	}
	{
		if s.IsDisabled.Set {
			e.FieldStart("isDisabled")
			s.IsDisabled.Encode(e)
		}
	}
	{
		if s.SecurityLayer.Set {
			e.FieldStart("securityLayer")
			s.SecurityLayer.Encode(e)
		}
	}
	{
		if len(s.XHttpExtraParams) != 0 {
			e.FieldStart("xHttpExtraParams")
			e.Raw(s.XHttpExtraParams)
		}
	}
	{
		if len(s.MuxParams) != 0 {
			e.FieldStart("muxParams")
			e.Raw(s.MuxParams)
		}
	}
	{
		if len(s.SockoptParams) != 0 {
			e.FieldStart("sockoptParams")
			e.Raw(s.SockoptParams)
		}
	}
	{
		e.FieldStart("inbound")
		s.Inbound.Encode(e)
	}
	{
		e.FieldStart("serverDescription")
		s.ServerDescription.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		if s.IsHidden.Set {
			e.FieldStart("isHidden")
			s.IsHidden.Encode(e)
		}
	}
	{
		if s.OverrideSniFromAddress.Set {
			e.FieldStart("overrideSniFromAddress")
			s.OverrideSniFromAddress.Encode(e)
		}
	}
	{
		e.FieldStart("vlessRouteId")
		s.VlessRouteId.Encode(e)
	}
	{
		if s.AllowInsecure.Set {
			e.FieldStart("allowInsecure")
			s.AllowInsecure.Encode(e)
		}
	}
	{
		e.FieldStart("shuffleHost")
		e.Bool(s.ShuffleHost)
	}
	{
		e.FieldStart("mihomoX25519")
		e.Bool(s.MihomoX25519)
	}
	{
		e.FieldStart("nodes")
		e.ArrStart()
		for _, elem := range s.Nodes {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateHostResponseDtoResponse = [25]string{
	0:  "uuid",
	1:  "viewPosition",
	2:  "remark",
	3:  "address",
	4:  "port",
	5:  "path",
	6:  "sni",
	7:  "host",
	8:  "alpn",
	9:  "fingerprint",
	10: "isDisabled",
	11: "securityLayer",
	12: "xHttpExtraParams",
	13: "muxParams",
	14: "sockoptParams",
	15: "inbound",
	16: "serverDescription",
	17: "tag",
	18: "isHidden",
	19: "overrideSniFromAddress",
	20: "vlessRouteId",
	21: "allowInsecure",
	22: "shuffleHost",
	23: "mihomoX25519",
	24: "nodes",
}

// Decode decodes UpdateHostResponseDtoResponse from json.
func (s *UpdateHostResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "viewPosition":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "remark":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Remark = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"remark\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.Port = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "path":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "sni":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Sni.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sni\"")
			}
		case "host":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Host.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"host\"")
			}
		case "alpn":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.Alpn.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alpn\"")
			}
		case "fingerprint":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.Fingerprint.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fingerprint\"")
			}
		case "isDisabled":
			if err := func() error {
				s.IsDisabled.Reset()
				if err := s.IsDisabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "securityLayer":
			if err := func() error {
				s.SecurityLayer.Reset()
				if err := s.SecurityLayer.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securityLayer\"")
			}
		case "xHttpExtraParams":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.XHttpExtraParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xHttpExtraParams\"")
			}
		case "muxParams":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.MuxParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"muxParams\"")
			}
		case "sockoptParams":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.SockoptParams = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sockoptParams\"")
			}
		case "inbound":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.Inbound.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbound\"")
			}
		case "serverDescription":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.ServerDescription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serverDescription\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "isHidden":
			if err := func() error {
				s.IsHidden.Reset()
				if err := s.IsHidden.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isHidden\"")
			}
		case "overrideSniFromAddress":
			if err := func() error {
				s.OverrideSniFromAddress.Reset()
				if err := s.OverrideSniFromAddress.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"overrideSniFromAddress\"")
			}
		case "vlessRouteId":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.VlessRouteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessRouteId\"")
			}
		case "allowInsecure":
			if err := func() error {
				s.AllowInsecure.Reset()
				if err := s.AllowInsecure.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowInsecure\"")
			}
		case "shuffleHost":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.ShuffleHost = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shuffleHost\"")
			}
		case "mihomoX25519":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.MihomoX25519 = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mihomoX25519\"")
			}
		case "nodes":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				s.Nodes = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Nodes = append(s.Nodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11110011,
		0b11010011,
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateHostResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateHostResponseDtoResponseInbound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateHostResponseDtoResponseInbound) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("configProfileUuid")
		s.ConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("configProfileInboundUuid")
		s.ConfigProfileInboundUuid.Encode(e)
	}
}

var jsonFieldsNameOfUpdateHostResponseDtoResponseInbound = [2]string{
	0: "configProfileUuid",
	1: "configProfileInboundUuid",
}

// Decode decodes UpdateHostResponseDtoResponseInbound from json.
func (s *UpdateHostResponseDtoResponseInbound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponseInbound to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "configProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileUuid\"")
			}
		case "configProfileInboundUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ConfigProfileInboundUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfileInboundUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateHostResponseDtoResponseInbound")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateHostResponseDtoResponseInbound) {
					name = jsonFieldsNameOfUpdateHostResponseDtoResponseInbound[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateHostResponseDtoResponseInbound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponseInbound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateHostResponseDtoResponseSecurityLayer as json.
func (s UpdateHostResponseDtoResponseSecurityLayer) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateHostResponseDtoResponseSecurityLayer from json.
func (s *UpdateHostResponseDtoResponseSecurityLayer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateHostResponseDtoResponseSecurityLayer to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateHostResponseDtoResponseSecurityLayer(v) {
	case UpdateHostResponseDtoResponseSecurityLayerDEFAULT:
		*s = UpdateHostResponseDtoResponseSecurityLayerDEFAULT
	case UpdateHostResponseDtoResponseSecurityLayerTLS:
		*s = UpdateHostResponseDtoResponseSecurityLayerTLS
	case UpdateHostResponseDtoResponseSecurityLayerNONE:
		*s = UpdateHostResponseDtoResponseSecurityLayerNONE
	default:
		*s = UpdateHostResponseDtoResponseSecurityLayer(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateHostResponseDtoResponseSecurityLayer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateHostResponseDtoResponseSecurityLayer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuids")
		e.ArrStart()
		for _, elem := range s.Uuids {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeRequestDto = [2]string{
	0: "uuids",
	1: "nextBillingAt",
}

// Decode decodes UpdateInfraBillingNodeRequestDto from json.
func (s *UpdateInfraBillingNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuids":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Uuids = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Uuids = append(s.Uuids, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuids\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeRequestDto) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInfraBillingNodeResponseDto from json.
func (s *UpdateInfraBillingNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDto) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalBillingNodes")
		e.Float64(s.TotalBillingNodes)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("availableBillingNodes")
		e.ArrStart()
		for _, elem := range s.AvailableBillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("totalAvailableBillingNodes")
		e.Float64(s.TotalAvailableBillingNodes)
	}
	{
		e.FieldStart("stats")
		s.Stats.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse = [5]string{
	0: "totalBillingNodes",
	1: "billingNodes",
	2: "availableBillingNodes",
	3: "totalAvailableBillingNodes",
	4: "stats",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponse from json.
func (s *UpdateInfraBillingNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalBillingNodes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBillingNodes\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.BillingNodes = make([]UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		case "availableBillingNodes":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AvailableBillingNodes = make([]UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AvailableBillingNodes = append(s.AvailableBillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"availableBillingNodes\"")
			}
		case "totalAvailableBillingNodes":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Float64()
				s.TotalAvailableBillingNodes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAvailableBillingNodes\"")
			}
		case "stats":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Stats.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"stats\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseAvailableBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("providerUuid")
		json.EncodeUUID(e, s.ProviderUuid)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
	{
		e.FieldStart("node")
		s.Node.Encode(e)
	}
	{
		e.FieldStart("nextBillingAt")
		json.EncodeDateTime(e, s.NextBillingAt)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem = [8]string{
	0: "uuid",
	1: "nodeUuid",
	2: "providerUuid",
	3: "provider",
	4: "node",
	5: "nextBillingAt",
	6: "createdAt",
	7: "updatedAt",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "providerUuid":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProviderUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		case "node":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Node.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"node\"")
			}
		case "nextBillingAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.NextBillingAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextBillingAt\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode = [3]string{
	0: "uuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider = [4]string{
	0: "uuid",
	1: "name",
	2: "loginUrl",
	3: "faviconLink",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseBillingNodesItemProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("upcomingNodesCount")
		e.Float64(s.UpcomingNodesCount)
	}
	{
		e.FieldStart("currentMonthPayments")
		e.Float64(s.CurrentMonthPayments)
	}
	{
		e.FieldStart("totalSpent")
		e.Float64(s.TotalSpent)
	}
}

var jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats = [3]string{
	0: "upcomingNodesCount",
	1: "currentMonthPayments",
	2: "totalSpent",
}

// Decode decodes UpdateInfraBillingNodeResponseDtoResponseStats from json.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraBillingNodeResponseDtoResponseStats to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "upcomingNodesCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.UpcomingNodesCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"upcomingNodesCount\"")
			}
		case "currentMonthPayments":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.CurrentMonthPayments = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"currentMonthPayments\"")
			}
		case "totalSpent":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Float64()
				s.TotalSpent = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSpent\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraBillingNodeResponseDtoResponseStats")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats) {
					name = jsonFieldsNameOfUpdateInfraBillingNodeResponseDtoResponseStats[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraBillingNodeResponseDtoResponseStats) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.FaviconLink.Set {
			e.FieldStart("faviconLink")
			s.FaviconLink.Encode(e)
		}
	}
	{
		if s.LoginUrl.Set {
			e.FieldStart("loginUrl")
			s.LoginUrl.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateInfraProviderRequestDto = [4]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
}

// Decode decodes UpdateInfraProviderRequestDto from json.
func (s *UpdateInfraProviderRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			if err := func() error {
				s.FaviconLink.Reset()
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			if err := func() error {
				s.LoginUrl.Reset()
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderRequestDto) {
					name = jsonFieldsNameOfUpdateInfraProviderRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInfraProviderResponseDto from json.
func (s *UpdateInfraProviderResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDto) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("billingHistory")
		s.BillingHistory.Encode(e)
	}
	{
		e.FieldStart("billingNodes")
		e.ArrStart()
		for _, elem := range s.BillingNodes {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse = [8]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
	6: "billingHistory",
	7: "billingNodes",
}

// Decode decodes UpdateInfraProviderResponseDtoResponse from json.
func (s *UpdateInfraProviderResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "billingHistory":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.BillingHistory.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingHistory\"")
			}
		case "billingNodes":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				s.BillingNodes = make([]UpdateInfraProviderResponseDtoResponseBillingNodesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInfraProviderResponseDtoResponseBillingNodesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.BillingNodes = append(s.BillingNodes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"billingNodes\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("totalAmount")
		e.Float64(s.TotalAmount)
	}
	{
		e.FieldStart("totalBills")
		e.Float64(s.TotalBills)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory = [2]string{
	0: "totalAmount",
	1: "totalBills",
}

// Decode decodes UpdateInfraProviderResponseDtoResponseBillingHistory from json.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponseBillingHistory to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "totalAmount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.TotalAmount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalAmount\"")
			}
		case "totalBills":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.TotalBills = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalBills\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponseBillingHistory")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingHistory[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingHistory) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("nodeUuid")
		json.EncodeUUID(e, s.NodeUuid)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem = [3]string{
	0: "nodeUuid",
	1: "name",
	2: "countryCode",
}

// Decode decodes UpdateInfraProviderResponseDtoResponseBillingNodesItem from json.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInfraProviderResponseDtoResponseBillingNodesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nodeUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.NodeUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeUuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInfraProviderResponseDtoResponseBillingNodesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem) {
					name = jsonFieldsNameOfUpdateInfraProviderResponseDtoResponseBillingNodesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInfraProviderResponseDtoResponseBillingNodesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Inbounds != nil {
			e.FieldStart("inbounds")
			e.ArrStart()
			for _, elem := range s.Inbounds {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUpdateInternalSquadRequestDto = [3]string{
	0: "uuid",
	1: "name",
	2: "inbounds",
}

// Decode decodes UpdateInternalSquadRequestDto from json.
func (s *UpdateInternalSquadRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "inbounds":
			if err := func() error {
				s.Inbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadRequestDto) {
					name = jsonFieldsNameOfUpdateInternalSquadRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateInternalSquadResponseDto from json.
func (s *UpdateInternalSquadResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDto) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		e.FieldStart("inbounds")
		e.ArrStart()
		for _, elem := range s.Inbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse = [6]string{
	0: "uuid",
	1: "name",
	2: "info",
	3: "inbounds",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes UpdateInternalSquadResponseDtoResponse from json.
func (s *UpdateInternalSquadResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "inbounds":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.Inbounds = make([]UpdateInternalSquadResponseDtoResponseInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateInternalSquadResponseDtoResponseInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Inbounds = append(s.Inbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inbounds\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateInternalSquadResponseDtoResponseInboundsItem from json.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponseInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponseInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponseInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateInternalSquadResponseDtoResponseInfo) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("membersCount")
		e.Float64(s.MembersCount)
	}
	{
		e.FieldStart("inboundsCount")
		e.Float64(s.InboundsCount)
	}
}

var jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo = [2]string{
	0: "membersCount",
	1: "inboundsCount",
}

// Decode decodes UpdateInternalSquadResponseDtoResponseInfo from json.
func (s *UpdateInternalSquadResponseDtoResponseInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateInternalSquadResponseDtoResponseInfo to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "membersCount":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.MembersCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"membersCount\"")
			}
		case "inboundsCount":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Float64()
				s.InboundsCount = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"inboundsCount\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateInternalSquadResponseDtoResponseInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo) {
					name = jsonFieldsNameOfUpdateInternalSquadResponseDtoResponseInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateInternalSquadResponseDtoResponseInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Address.Set {
			e.FieldStart("address")
			s.Address.Encode(e)
		}
	}
	{
		if s.Port.Set {
			e.FieldStart("port")
			s.Port.Encode(e)
		}
	}
	{
		if s.IsTrafficTrackingActive.Set {
			e.FieldStart("isTrafficTrackingActive")
			s.IsTrafficTrackingActive.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.NotifyPercent.Set {
			e.FieldStart("notifyPercent")
			s.NotifyPercent.Encode(e)
		}
	}
	{
		if s.TrafficResetDay.Set {
			e.FieldStart("trafficResetDay")
			s.TrafficResetDay.Encode(e)
		}
	}
	{
		if s.CountryCode.Set {
			e.FieldStart("countryCode")
			s.CountryCode.Encode(e)
		}
	}
	{
		if s.ConsumptionMultiplier.Set {
			e.FieldStart("consumptionMultiplier")
			s.ConsumptionMultiplier.Encode(e)
		}
	}
	{
		if s.ConfigProfile.Set {
			e.FieldStart("configProfile")
			s.ConfigProfile.Encode(e)
		}
	}
	{
		if s.ProviderUuid.Set {
			e.FieldStart("providerUuid")
			s.ProviderUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateNodeRequestDto = [12]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isTrafficTrackingActive",
	5:  "trafficLimitBytes",
	6:  "notifyPercent",
	7:  "trafficResetDay",
	8:  "countryCode",
	9:  "consumptionMultiplier",
	10: "configProfile",
	11: "providerUuid",
}

// Decode decodes UpdateNodeRequestDto from json.
func (s *UpdateNodeRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			if err := func() error {
				s.Address.Reset()
				if err := s.Address.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			if err := func() error {
				s.Port.Reset()
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isTrafficTrackingActive":
			if err := func() error {
				s.IsTrafficTrackingActive.Reset()
				if err := s.IsTrafficTrackingActive.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "notifyPercent":
			if err := func() error {
				s.NotifyPercent.Reset()
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "trafficResetDay":
			if err := func() error {
				s.TrafficResetDay.Reset()
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "countryCode":
			if err := func() error {
				s.CountryCode.Reset()
				if err := s.CountryCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			if err := func() error {
				s.ConsumptionMultiplier.Reset()
				if err := s.ConsumptionMultiplier.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "configProfile":
			if err := func() error {
				s.ConfigProfile.Reset()
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			if err := func() error {
				s.ProviderUuid.Reset()
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeRequestDto) {
					name = jsonFieldsNameOfUpdateNodeRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeRequestDtoConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeRequestDtoConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		json.EncodeUUID(e, s.ActiveConfigProfileUuid)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			json.EncodeUUID(e, elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes UpdateNodeRequestDtoConfigProfile from json.
func (s *UpdateNodeRequestDtoConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeRequestDtoConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ActiveConfigProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeRequestDtoConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile) {
					name = jsonFieldsNameOfUpdateNodeRequestDtoConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeRequestDtoConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeRequestDtoConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateNodeResponseDto from json.
func (s *UpdateNodeResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDto) {
					name = jsonFieldsNameOfUpdateNodeResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("address")
		e.Str(s.Address)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		e.FieldStart("isConnected")
		e.Bool(s.IsConnected)
	}
	{
		e.FieldStart("isDisabled")
		e.Bool(s.IsDisabled)
	}
	{
		e.FieldStart("isConnecting")
		e.Bool(s.IsConnecting)
	}
	{
		e.FieldStart("isNodeOnline")
		e.Bool(s.IsNodeOnline)
	}
	{
		e.FieldStart("isXrayRunning")
		e.Bool(s.IsXrayRunning)
	}
	{
		e.FieldStart("lastStatusChange")
		s.LastStatusChange.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastStatusMessage")
		s.LastStatusMessage.Encode(e)
	}
	{
		e.FieldStart("xrayVersion")
		s.XrayVersion.Encode(e)
	}
	{
		e.FieldStart("nodeVersion")
		s.NodeVersion.Encode(e)
	}
	{
		e.FieldStart("xrayUptime")
		e.Str(s.XrayUptime)
	}
	{
		e.FieldStart("isTrafficTrackingActive")
		e.Bool(s.IsTrafficTrackingActive)
	}
	{
		e.FieldStart("trafficResetDay")
		s.TrafficResetDay.Encode(e)
	}
	{
		e.FieldStart("trafficLimitBytes")
		s.TrafficLimitBytes.Encode(e)
	}
	{
		e.FieldStart("trafficUsedBytes")
		s.TrafficUsedBytes.Encode(e)
	}
	{
		e.FieldStart("notifyPercent")
		s.NotifyPercent.Encode(e)
	}
	{
		e.FieldStart("usersOnline")
		s.UsersOnline.Encode(e)
	}
	{
		e.FieldStart("viewPosition")
		e.Int(s.ViewPosition)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
	{
		e.FieldStart("consumptionMultiplier")
		e.Float64(s.ConsumptionMultiplier)
	}
	{
		e.FieldStart("cpuCount")
		s.CpuCount.Encode(e)
	}
	{
		e.FieldStart("cpuModel")
		s.CpuModel.Encode(e)
	}
	{
		e.FieldStart("totalRam")
		s.TotalRam.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("configProfile")
		s.ConfigProfile.Encode(e)
	}
	{
		e.FieldStart("providerUuid")
		s.ProviderUuid.Encode(e)
	}
	{
		e.FieldStart("provider")
		s.Provider.Encode(e)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "name",
	2:  "address",
	3:  "port",
	4:  "isConnected",
	5:  "isDisabled",
	6:  "isConnecting",
	7:  "isNodeOnline",
	8:  "isXrayRunning",
	9:  "lastStatusChange",
	10: "lastStatusMessage",
	11: "xrayVersion",
	12: "nodeVersion",
	13: "xrayUptime",
	14: "isTrafficTrackingActive",
	15: "trafficResetDay",
	16: "trafficLimitBytes",
	17: "trafficUsedBytes",
	18: "notifyPercent",
	19: "usersOnline",
	20: "viewPosition",
	21: "countryCode",
	22: "consumptionMultiplier",
	23: "cpuCount",
	24: "cpuModel",
	25: "totalRam",
	26: "createdAt",
	27: "updatedAt",
	28: "configProfile",
	29: "providerUuid",
	30: "provider",
}

// Decode decodes UpdateNodeResponseDtoResponse from json.
func (s *UpdateNodeResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "address":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Address = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"address\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "isConnected":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsConnected = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnected\"")
			}
		case "isDisabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsDisabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDisabled\"")
			}
		case "isConnecting":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsConnecting = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isConnecting\"")
			}
		case "isNodeOnline":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsNodeOnline = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isNodeOnline\"")
			}
		case "isXrayRunning":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.IsXrayRunning = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isXrayRunning\"")
			}
		case "lastStatusChange":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.LastStatusChange.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusChange\"")
			}
		case "lastStatusMessage":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				if err := s.LastStatusMessage.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastStatusMessage\"")
			}
		case "xrayVersion":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.XrayVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayVersion\"")
			}
		case "nodeVersion":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.NodeVersion.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeVersion\"")
			}
		case "xrayUptime":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.XrayUptime = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xrayUptime\"")
			}
		case "isTrafficTrackingActive":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.IsTrafficTrackingActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isTrafficTrackingActive\"")
			}
		case "trafficResetDay":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.TrafficResetDay.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficResetDay\"")
			}
		case "trafficLimitBytes":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficUsedBytes":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.TrafficUsedBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficUsedBytes\"")
			}
		case "notifyPercent":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.NotifyPercent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notifyPercent\"")
			}
		case "usersOnline":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.UsersOnline.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usersOnline\"")
			}
		case "viewPosition":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				v, err := d.Int()
				s.ViewPosition = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewPosition\"")
			}
		case "countryCode":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		case "consumptionMultiplier":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				v, err := d.Float64()
				s.ConsumptionMultiplier = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"consumptionMultiplier\"")
			}
		case "cpuCount":
			requiredBitSet[2] |= 1 << 7
			if err := func() error {
				if err := s.CpuCount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuCount\"")
			}
		case "cpuModel":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				if err := s.CpuModel.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cpuModel\"")
			}
		case "totalRam":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				if err := s.TotalRam.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalRam\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "configProfile":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				if err := s.ConfigProfile.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"configProfile\"")
			}
		case "providerUuid":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.ProviderUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"providerUuid\"")
			}
		case "provider":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Provider.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"provider\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b11111111,
		0b11111111,
		0b11111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseConfigProfile) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("activeConfigProfileUuid")
		s.ActiveConfigProfileUuid.Encode(e)
	}
	{
		e.FieldStart("activeInbounds")
		e.ArrStart()
		for _, elem := range s.ActiveInbounds {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile = [2]string{
	0: "activeConfigProfileUuid",
	1: "activeInbounds",
}

// Decode decodes UpdateNodeResponseDtoResponseConfigProfile from json.
func (s *UpdateNodeResponseDtoResponseConfigProfile) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseConfigProfile to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "activeConfigProfileUuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActiveConfigProfileUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeConfigProfileUuid\"")
			}
		case "activeInbounds":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.ActiveInbounds = make([]UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInbounds = append(s.ActiveInbounds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInbounds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseConfigProfile")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfile[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfile) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileUuid")
		json.EncodeUUID(e, s.ProfileUuid)
	}
	{
		e.FieldStart("tag")
		e.Str(s.Tag)
	}
	{
		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		e.FieldStart("network")
		s.Network.Encode(e)
	}
	{
		e.FieldStart("security")
		s.Security.Encode(e)
	}
	{
		e.FieldStart("port")
		s.Port.Encode(e)
	}
	{
		if len(s.RawInbound) != 0 {
			e.FieldStart("rawInbound")
			e.Raw(s.RawInbound)
		}
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem = [8]string{
	0: "uuid",
	1: "profileUuid",
	2: "tag",
	3: "type",
	4: "network",
	5: "security",
	6: "port",
	7: "rawInbound",
}

// Decode decodes UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem from json.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.ProfileUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUuid\"")
			}
		case "tag":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Tag = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "type":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "network":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.Network.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"network\"")
			}
		case "security":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.Security.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "port":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				if err := s.Port.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"port\"")
			}
		case "rawInbound":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RawInbound = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rawInbound\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseConfigProfileActiveInboundsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateNodeResponseDtoResponseProvider) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateNodeResponseDtoResponseProvider) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("faviconLink")
		s.FaviconLink.Encode(e)
	}
	{
		e.FieldStart("loginUrl")
		s.LoginUrl.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider = [6]string{
	0: "uuid",
	1: "name",
	2: "faviconLink",
	3: "loginUrl",
	4: "createdAt",
	5: "updatedAt",
}

// Decode decodes UpdateNodeResponseDtoResponseProvider from json.
func (s *UpdateNodeResponseDtoResponseProvider) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateNodeResponseDtoResponseProvider to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "faviconLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.FaviconLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"faviconLink\"")
			}
		case "loginUrl":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.LoginUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"loginUrl\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateNodeResponseDtoResponseProvider")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider) {
					name = jsonFieldsNameOfUpdateNodeResponseDtoResponseProvider[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateNodeResponseDtoResponseProvider) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateNodeResponseDtoResponseProvider) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.PasskeySettings.Set {
			e.FieldStart("passkeySettings")
			s.PasskeySettings.Encode(e)
		}
	}
	{
		if s.Oauth2Settings.Set {
			e.FieldStart("oauth2Settings")
			s.Oauth2Settings.Encode(e)
		}
	}
	{
		if s.TgAuthSettings.Set {
			e.FieldStart("tgAuthSettings")
			s.TgAuthSettings.Encode(e)
		}
	}
	{
		if s.PasswordSettings.Set {
			e.FieldStart("passwordSettings")
			s.PasswordSettings.Encode(e)
		}
	}
	{
		if s.BrandingSettings.Set {
			e.FieldStart("brandingSettings")
			s.BrandingSettings.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDto = [5]string{
	0: "passkeySettings",
	1: "oauth2Settings",
	2: "tgAuthSettings",
	3: "passwordSettings",
	4: "brandingSettings",
}

// Decode decodes UpdateRemnawaveSettingsRequestDto from json.
func (s *UpdateRemnawaveSettingsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDto to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "passkeySettings":
			if err := func() error {
				s.PasskeySettings.Reset()
				if err := s.PasskeySettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passkeySettings\"")
			}
		case "oauth2Settings":
			if err := func() error {
				s.Oauth2Settings.Reset()
				if err := s.Oauth2Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2Settings\"")
			}
		case "tgAuthSettings":
			if err := func() error {
				s.TgAuthSettings.Reset()
				if err := s.TgAuthSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgAuthSettings\"")
			}
		case "passwordSettings":
			if err := func() error {
				s.PasswordSettings.Reset()
				if err := s.PasswordSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordSettings\"")
			}
		case "brandingSettings":
			if err := func() error {
				s.BrandingSettings.Reset()
				if err := s.BrandingSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brandingSettings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoBrandingSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoBrandingSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("logoUrl")
		s.LogoUrl.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoBrandingSettings = [2]string{
	0: "title",
	1: "logoUrl",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoBrandingSettings from json.
func (s *UpdateRemnawaveSettingsRequestDtoBrandingSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoBrandingSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "logoUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LogoUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logoUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoBrandingSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoBrandingSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoBrandingSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2Settings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2Settings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("github")
		s.Github.Encode(e)
	}
	{
		e.FieldStart("pocketid")
		s.Pocketid.Encode(e)
	}
	{
		e.FieldStart("yandex")
		s.Yandex.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2Settings = [3]string{
	0: "github",
	1: "pocketid",
	2: "yandex",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoOauth2Settings from json.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2Settings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoOauth2Settings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Github.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github\"")
			}
		case "pocketid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pocketid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pocketid\"")
			}
		case "yandex":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Yandex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yandex\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoOauth2Settings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2Settings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2Settings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub from json.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("plainDomain")
		s.PlainDomain.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid = [5]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "plainDomain",
	4: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid from json.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "plainDomain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PlainDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plainDomain\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex from json.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasskeySettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoPasskeySettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("rpId")
		s.RpId.Encode(e)
	}
	{
		e.FieldStart("origin")
		s.Origin.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasskeySettings = [3]string{
	0: "enabled",
	1: "rpId",
	2: "origin",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoPasskeySettings from json.
func (s *UpdateRemnawaveSettingsRequestDtoPasskeySettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoPasskeySettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "rpId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RpId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rpId\"")
			}
		case "origin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Origin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoPasskeySettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasskeySettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasskeySettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasswordSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoPasswordSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasswordSettings = [1]string{
	0: "enabled",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoPasswordSettings from json.
func (s *UpdateRemnawaveSettingsRequestDtoPasswordSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoPasswordSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoPasswordSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasswordSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoPasswordSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoPasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoTgAuthSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsRequestDtoTgAuthSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("botToken")
		s.BotToken.Encode(e)
	}
	{
		e.FieldStart("adminIds")
		e.ArrStart()
		for _, elem := range s.AdminIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoTgAuthSettings = [3]string{
	0: "enabled",
	1: "botToken",
	2: "adminIds",
}

// Decode decodes UpdateRemnawaveSettingsRequestDtoTgAuthSettings from json.
func (s *UpdateRemnawaveSettingsRequestDtoTgAuthSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsRequestDtoTgAuthSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "botToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BotToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"botToken\"")
			}
		case "adminIds":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AdminIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdminIds = append(s.AdminIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsRequestDtoTgAuthSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoTgAuthSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsRequestDtoTgAuthSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsRequestDtoTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsRequestDtoTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateRemnawaveSettingsResponseDto from json.
func (s *UpdateRemnawaveSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDto) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("passkeySettings")
		s.PasskeySettings.Encode(e)
	}
	{
		e.FieldStart("oauth2Settings")
		s.Oauth2Settings.Encode(e)
	}
	{
		e.FieldStart("tgAuthSettings")
		s.TgAuthSettings.Encode(e)
	}
	{
		e.FieldStart("passwordSettings")
		s.PasswordSettings.Encode(e)
	}
	{
		e.FieldStart("brandingSettings")
		s.BrandingSettings.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponse = [5]string{
	0: "passkeySettings",
	1: "oauth2Settings",
	2: "tgAuthSettings",
	3: "passwordSettings",
	4: "brandingSettings",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponse from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "passkeySettings":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.PasskeySettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passkeySettings\"")
			}
		case "oauth2Settings":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Oauth2Settings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oauth2Settings\"")
			}
		case "tgAuthSettings":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TgAuthSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tgAuthSettings\"")
			}
		case "passwordSettings":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PasswordSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"passwordSettings\"")
			}
		case "brandingSettings":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.BrandingSettings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"brandingSettings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("title")
		s.Title.Encode(e)
	}
	{
		e.FieldStart("logoUrl")
		s.LogoUrl.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings = [2]string{
	0: "title",
	1: "logoUrl",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "logoUrl":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.LogoUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"logoUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseBrandingSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseBrandingSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("github")
		s.Github.Encode(e)
	}
	{
		e.FieldStart("pocketid")
		s.Pocketid.Encode(e)
	}
	{
		e.FieldStart("yandex")
		s.Yandex.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings = [3]string{
	0: "github",
	1: "pocketid",
	2: "yandex",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "github":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Github.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"github\"")
			}
		case "pocketid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Pocketid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pocketid\"")
			}
		case "yandex":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Yandex.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"yandex\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2Settings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2Settings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsGithub) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("plainDomain")
		s.PlainDomain.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid = [5]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "plainDomain",
	4: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "plainDomain":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.PlainDomain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"plainDomain\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsPocketid) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("clientId")
		s.ClientId.Encode(e)
	}
	{
		e.FieldStart("clientSecret")
		s.ClientSecret.Encode(e)
	}
	{
		e.FieldStart("allowedEmails")
		e.ArrStart()
		for _, elem := range s.AllowedEmails {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex = [4]string{
	0: "enabled",
	1: "clientId",
	2: "clientSecret",
	3: "allowedEmails",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "clientId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "clientSecret":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "allowedEmails":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				s.AllowedEmails = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AllowedEmails = append(s.AllowedEmails, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowedEmails\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseOauth2SettingsYandex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("rpId")
		s.RpId.Encode(e)
	}
	{
		e.FieldStart("origin")
		s.Origin.Encode(e)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings = [3]string{
	0: "enabled",
	1: "rpId",
	2: "origin",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "rpId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.RpId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rpId\"")
			}
		case "origin":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Origin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"origin\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasskeySettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasskeySettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings = [1]string{
	0: "enabled",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponsePasswordSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponsePasswordSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("botToken")
		s.BotToken.Encode(e)
	}
	{
		e.FieldStart("adminIds")
		e.ArrStart()
		for _, elem := range s.AdminIds {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings = [3]string{
	0: "enabled",
	1: "botToken",
	2: "adminIds",
}

// Decode decodes UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings from json.
func (s *UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "botToken":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.BotToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"botToken\"")
			}
		case "adminIds":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.AdminIds = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.AdminIds = append(s.AdminIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"adminIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) {
					name = jsonFieldsNameOfUpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateRemnawaveSettingsResponseDtoResponseTgAuthSettings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSnippetRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSnippetRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("snippet")
		e.ArrStart()
		for _, elem := range s.Snippet {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateSnippetRequestDto = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes UpdateSnippetRequestDto from json.
func (s *UpdateSnippetRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSnippetRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippet = make([]UpdateSnippetRequestDtoSnippetItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSnippetRequestDtoSnippetItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippet = append(s.Snippet, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSnippetRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSnippetRequestDto) {
					name = jsonFieldsNameOfUpdateSnippetRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSnippetRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSnippetRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSnippetRequestDtoSnippetItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSnippetRequestDtoSnippetItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateSnippetRequestDtoSnippetItem = [0]string{}

// Decode decodes UpdateSnippetRequestDtoSnippetItem from json.
func (s *UpdateSnippetRequestDtoSnippetItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSnippetRequestDtoSnippetItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSnippetRequestDtoSnippetItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSnippetRequestDtoSnippetItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSnippetRequestDtoSnippetItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSnippetResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSnippetResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateSnippetResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateSnippetResponseDto from json.
func (s *UpdateSnippetResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSnippetResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSnippetResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSnippetResponseDto) {
					name = jsonFieldsNameOfUpdateSnippetResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSnippetResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSnippetResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSnippetResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSnippetResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("total")
		e.Float64(s.Total)
	}
	{
		e.FieldStart("snippets")
		e.ArrStart()
		for _, elem := range s.Snippets {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateSnippetResponseDtoResponse = [2]string{
	0: "total",
	1: "snippets",
}

// Decode decodes UpdateSnippetResponseDtoResponse from json.
func (s *UpdateSnippetResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSnippetResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "total":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Float64()
				s.Total = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"total\"")
			}
		case "snippets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Snippets = make([]UpdateSnippetResponseDtoResponseSnippetsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSnippetResponseDtoResponseSnippetsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Snippets = append(s.Snippets, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSnippetResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSnippetResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateSnippetResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSnippetResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSnippetResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSnippetResponseDtoResponseSnippetsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSnippetResponseDtoResponseSnippetsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if len(s.Snippet) != 0 {
			e.FieldStart("snippet")
			e.Raw(s.Snippet)
		}
	}
}

var jsonFieldsNameOfUpdateSnippetResponseDtoResponseSnippetsItem = [2]string{
	0: "name",
	1: "snippet",
}

// Decode decodes UpdateSnippetResponseDtoResponseSnippetsItem from json.
func (s *UpdateSnippetResponseDtoResponseSnippetsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSnippetResponseDtoResponseSnippetsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "snippet":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Snippet = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"snippet\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSnippetResponseDtoResponseSnippetsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSnippetResponseDtoResponseSnippetsItem) {
					name = jsonFieldsNameOfUpdateSnippetResponseDtoResponseSnippetsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSnippetResponseDtoResponseSnippetsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSnippetResponseDtoResponseSnippetsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.ProfileTitle.Set {
			e.FieldStart("profileTitle")
			s.ProfileTitle.Encode(e)
		}
	}
	{
		if s.SupportLink.Set {
			e.FieldStart("supportLink")
			s.SupportLink.Encode(e)
		}
	}
	{
		if s.ProfileUpdateInterval.Set {
			e.FieldStart("profileUpdateInterval")
			s.ProfileUpdateInterval.Encode(e)
		}
	}
	{
		if s.IsProfileWebpageUrlEnabled.Set {
			e.FieldStart("isProfileWebpageUrlEnabled")
			s.IsProfileWebpageUrlEnabled.Encode(e)
		}
	}
	{
		if s.ServeJsonAtBaseSubscription.Set {
			e.FieldStart("serveJsonAtBaseSubscription")
			s.ServeJsonAtBaseSubscription.Encode(e)
		}
	}
	{
		if s.AddUsernameToBaseSubscription.Set {
			e.FieldStart("addUsernameToBaseSubscription")
			s.AddUsernameToBaseSubscription.Encode(e)
		}
	}
	{
		if s.IsShowCustomRemarks.Set {
			e.FieldStart("isShowCustomRemarks")
			s.IsShowCustomRemarks.Encode(e)
		}
	}
	{
		if s.HappAnnounce.Set {
			e.FieldStart("happAnnounce")
			s.HappAnnounce.Encode(e)
		}
	}
	{
		if s.HappRouting.Set {
			e.FieldStart("happRouting")
			s.HappRouting.Encode(e)
		}
	}
	{
		if s.ExpiredUsersRemarks != nil {
			e.FieldStart("expiredUsersRemarks")
			e.ArrStart()
			for _, elem := range s.ExpiredUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.LimitedUsersRemarks != nil {
			e.FieldStart("limitedUsersRemarks")
			e.ArrStart()
			for _, elem := range s.LimitedUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.DisabledUsersRemarks != nil {
			e.FieldStart("disabledUsersRemarks")
			e.ArrStart()
			for _, elem := range s.DisabledUsersRemarks {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CustomResponseHeaders.Set {
			e.FieldStart("customResponseHeaders")
			s.CustomResponseHeaders.Encode(e)
		}
	}
	{
		if s.RandomizeHosts.Set {
			e.FieldStart("randomizeHosts")
			s.RandomizeHosts.Encode(e)
		}
	}
	{
		if s.ResponseRules.Set {
			e.FieldStart("responseRules")
			s.ResponseRules.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto = [16]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
	15: "responseRules",
}

// Decode decodes UpdateSubscriptionSettingsRequestDto from json.
func (s *UpdateSubscriptionSettingsRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDto to nil")
	}
	var requiredBitSet [2]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			if err := func() error {
				s.ProfileTitle.Reset()
				if err := s.ProfileTitle.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			if err := func() error {
				s.SupportLink.Reset()
				if err := s.SupportLink.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			if err := func() error {
				s.ProfileUpdateInterval.Reset()
				if err := s.ProfileUpdateInterval.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			if err := func() error {
				s.IsProfileWebpageUrlEnabled.Reset()
				if err := s.IsProfileWebpageUrlEnabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			if err := func() error {
				s.ServeJsonAtBaseSubscription.Reset()
				if err := s.ServeJsonAtBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			if err := func() error {
				s.AddUsernameToBaseSubscription.Reset()
				if err := s.AddUsernameToBaseSubscription.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			if err := func() error {
				s.IsShowCustomRemarks.Reset()
				if err := s.IsShowCustomRemarks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			if err := func() error {
				s.HappAnnounce.Reset()
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			if err := func() error {
				s.HappRouting.Reset()
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			if err := func() error {
				s.CustomResponseHeaders.Reset()
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			if err := func() error {
				s.RandomizeHosts.Reset()
				if err := s.RandomizeHosts.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		case "responseRules":
			if err := func() error {
				s.ResponseRules.Reset()
				if err := s.ResponseRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseRules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000001,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRules = [2]string{
	0: "version",
	1: "rules",
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRules from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Rules = make([]UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoResponseRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRules) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		if s.ResponseModifications.Set {
			e.FieldStart("responseModifications")
			s.ResponseModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem = [7]string{
	0: "name",
	1: "description",
	2: "enabled",
	3: "operator",
	4: "conditions",
	5: "responseType",
	6: "responseModifications",
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "conditions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Conditions = make([]UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "responseModifications":
			if err := func() error {
				s.ResponseModifications.Reset()
				if err := s.ResponseModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseModifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headerName")
		e.Str(s.HeaderName)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("caseSensitive")
		e.Bool(s.CaseSensitive)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem = [4]string{
	0: "headerName",
	1: "operator",
	2: "value",
	3: "caseSensitive",
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeaderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerName\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "caseSensitive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CaseSensitive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseSensitive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator as json.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator(v) {
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorEQUALS:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorEQUALS
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTEQUALS:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTEQUALS
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorCONTAINS:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorCONTAINS
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorSTARTSWITH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorSTARTSWITH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorENDSWITH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorENDSWITH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorREGEX:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorREGEX
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTREGEX:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperatorNOTREGEX
	default:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator as json.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator(v) {
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperatorAND:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperatorAND
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperatorOR:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperatorOR
	default:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionTemplate.Set {
			e.FieldStart("subscriptionTemplate")
			s.SubscriptionTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications = [2]string{
	0: "headers",
	1: "subscriptionTemplate",
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "subscriptionTemplate":
			if err := func() error {
				s.SubscriptionTemplate.Reset()
				if err := s.SubscriptionTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType as json.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType(v) {
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeXRAYJSON:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeXRAYJSON
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeXRAYBASE64:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeXRAYBASE64
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeMIHOMO:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeMIHOMO
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTASH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTASH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeCLASH:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeCLASH
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSINGBOX:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSINGBOX
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeBROWSER:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeBROWSER
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeBLOCK:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeBLOCK
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE404:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE404
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE451:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSTATUSCODE451
	case UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSOCKETDROP:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseTypeSOCKETDROP
	default:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsRequestDtoResponseRulesVersion as json.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsRequestDtoResponseRulesVersion from json.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsRequestDtoResponseRulesVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsRequestDtoResponseRulesVersion(v) {
	case UpdateSubscriptionSettingsRequestDtoResponseRulesVersion1:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesVersion1
	default:
		*s = UpdateSubscriptionSettingsRequestDtoResponseRulesVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsRequestDtoResponseRulesVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsRequestDtoResponseRulesVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateSubscriptionSettingsResponseDto from json.
func (s *UpdateSubscriptionSettingsResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("profileTitle")
		e.Str(s.ProfileTitle)
	}
	{
		e.FieldStart("supportLink")
		e.Str(s.SupportLink)
	}
	{
		e.FieldStart("profileUpdateInterval")
		e.Int(s.ProfileUpdateInterval)
	}
	{
		e.FieldStart("isProfileWebpageUrlEnabled")
		e.Bool(s.IsProfileWebpageUrlEnabled)
	}
	{
		e.FieldStart("serveJsonAtBaseSubscription")
		e.Bool(s.ServeJsonAtBaseSubscription)
	}
	{
		e.FieldStart("addUsernameToBaseSubscription")
		e.Bool(s.AddUsernameToBaseSubscription)
	}
	{
		e.FieldStart("isShowCustomRemarks")
		e.Bool(s.IsShowCustomRemarks)
	}
	{
		e.FieldStart("happAnnounce")
		s.HappAnnounce.Encode(e)
	}
	{
		e.FieldStart("happRouting")
		s.HappRouting.Encode(e)
	}
	{
		e.FieldStart("expiredUsersRemarks")
		e.ArrStart()
		for _, elem := range s.ExpiredUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("limitedUsersRemarks")
		e.ArrStart()
		for _, elem := range s.LimitedUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("disabledUsersRemarks")
		e.ArrStart()
		for _, elem := range s.DisabledUsersRemarks {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("customResponseHeaders")
		s.CustomResponseHeaders.Encode(e)
	}
	{
		e.FieldStart("randomizeHosts")
		e.Bool(s.RandomizeHosts)
	}
	{
		e.FieldStart("responseRules")
		s.ResponseRules.Encode(e)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse = [18]string{
	0:  "uuid",
	1:  "profileTitle",
	2:  "supportLink",
	3:  "profileUpdateInterval",
	4:  "isProfileWebpageUrlEnabled",
	5:  "serveJsonAtBaseSubscription",
	6:  "addUsernameToBaseSubscription",
	7:  "isShowCustomRemarks",
	8:  "happAnnounce",
	9:  "happRouting",
	10: "expiredUsersRemarks",
	11: "limitedUsersRemarks",
	12: "disabledUsersRemarks",
	13: "customResponseHeaders",
	14: "randomizeHosts",
	15: "responseRules",
	16: "createdAt",
	17: "updatedAt",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponse from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponse to nil")
	}
	var requiredBitSet [3]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "profileTitle":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProfileTitle = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileTitle\"")
			}
		case "supportLink":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.SupportLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supportLink\"")
			}
		case "profileUpdateInterval":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.ProfileUpdateInterval = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"profileUpdateInterval\"")
			}
		case "isProfileWebpageUrlEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsProfileWebpageUrlEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isProfileWebpageUrlEnabled\"")
			}
		case "serveJsonAtBaseSubscription":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.ServeJsonAtBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"serveJsonAtBaseSubscription\"")
			}
		case "addUsernameToBaseSubscription":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.AddUsernameToBaseSubscription = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"addUsernameToBaseSubscription\"")
			}
		case "isShowCustomRemarks":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Bool()
				s.IsShowCustomRemarks = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isShowCustomRemarks\"")
			}
		case "happAnnounce":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.HappAnnounce.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happAnnounce\"")
			}
		case "happRouting":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.HappRouting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happRouting\"")
			}
		case "expiredUsersRemarks":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				s.ExpiredUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.ExpiredUsersRemarks = append(s.ExpiredUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expiredUsersRemarks\"")
			}
		case "limitedUsersRemarks":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				s.LimitedUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.LimitedUsersRemarks = append(s.LimitedUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"limitedUsersRemarks\"")
			}
		case "disabledUsersRemarks":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				s.DisabledUsersRemarks = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.DisabledUsersRemarks = append(s.DisabledUsersRemarks, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"disabledUsersRemarks\"")
			}
		case "customResponseHeaders":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.CustomResponseHeaders.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"customResponseHeaders\"")
			}
		case "randomizeHosts":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Bool()
				s.RandomizeHosts = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"randomizeHosts\"")
			}
		case "responseRules":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				if err := s.ResponseRules.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseRules\"")
			}
		case "createdAt":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [3]uint8{
		0b11111111,
		0b11111111,
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseCustomResponseHeaders) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRules) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRules) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("version")
		s.Version.Encode(e)
	}
	{
		e.FieldStart("rules")
		e.ArrStart()
		for _, elem := range s.Rules {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRules = [2]string{
	0: "version",
	1: "rules",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRules from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRules) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRules to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "version":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Version.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		case "rules":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				s.Rules = make([]UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Rules = append(s.Rules, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rules\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseResponseRules")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRules) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRules[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRules) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRules) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("enabled")
		e.Bool(s.Enabled)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("conditions")
		e.ArrStart()
		for _, elem := range s.Conditions {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("responseType")
		s.ResponseType.Encode(e)
	}
	{
		if s.ResponseModifications.Set {
			e.FieldStart("responseModifications")
			s.ResponseModifications.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem = [7]string{
	0: "name",
	1: "description",
	2: "enabled",
	3: "operator",
	4: "conditions",
	5: "responseType",
	6: "responseModifications",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "enabled":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Bool()
				s.Enabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "conditions":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				s.Conditions = make([]UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Conditions = append(s.Conditions, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"conditions\"")
			}
		case "responseType":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.ResponseType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseType\"")
			}
		case "responseModifications":
			if err := func() error {
				s.ResponseModifications.Reset()
				if err := s.ResponseModifications.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responseModifications\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00111101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("headerName")
		e.Str(s.HeaderName)
	}
	{
		e.FieldStart("operator")
		s.Operator.Encode(e)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
	{
		e.FieldStart("caseSensitive")
		e.Bool(s.CaseSensitive)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem = [4]string{
	0: "headerName",
	1: "operator",
	2: "value",
	3: "caseSensitive",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headerName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.HeaderName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headerName\"")
			}
		case "operator":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Operator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operator\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "caseSensitive":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.CaseSensitive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseSensitive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator as json.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator(v) {
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorEQUALS:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorEQUALS
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTEQUALS:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTEQUALS
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorCONTAINS:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorCONTAINS
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTCONTAINS
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorSTARTSWITH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorSTARTSWITH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTSTARTSWITH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorENDSWITH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorENDSWITH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTENDSWITH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorREGEX:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorREGEX
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTREGEX:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperatorNOTREGEX
	default:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemConditionsItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator as json.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator(v) {
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorAND:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorAND
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorOR:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperatorOR
	default:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemOperator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) encodeFields(e *jx.Encoder) {
	{
		if s.Headers != nil {
			e.FieldStart("headers")
			e.ArrStart()
			for _, elem := range s.Headers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.SubscriptionTemplate.Set {
			e.FieldStart("subscriptionTemplate")
			s.SubscriptionTemplate.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications = [2]string{
	0: "headers",
	1: "subscriptionTemplate",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "headers":
			if err := func() error {
				s.Headers = make([]UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Headers = append(s.Headers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "subscriptionTemplate":
			if err := func() error {
				s.SubscriptionTemplate.Reset()
				if err := s.SubscriptionTemplate.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionTemplate\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModifications) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("value")
		e.Str(s.Value)
	}
}

var jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem = [2]string{
	0: "key",
	1: "value",
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "key":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "value":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Value = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) {
					name = jsonFieldsNameOfUpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseModificationsHeadersItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType as json.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType(v) {
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYJSON:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYJSON
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYBASE64:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeXRAYBASE64
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeMIHOMO:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeMIHOMO
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTASH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTASH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeCLASH:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeCLASH
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSINGBOX:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSINGBOX
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBROWSER:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBROWSER
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBLOCK:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeBLOCK
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE404:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE404
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE451:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSTATUSCODE451
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSOCKETDROP:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseTypeSOCKETDROP
	default:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesRulesItemResponseType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion as json.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion from json.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion(v) {
	case UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion1:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion1
	default:
		*s = UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSubscriptionSettingsResponseDtoResponseResponseRulesVersion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.TemplateJson != nil {
			e.FieldStart("templateJson")
			s.TemplateJson.Encode(e)
		}
	}
	{
		if s.EncodedTemplateYaml.Set {
			e.FieldStart("encodedTemplateYaml")
			s.EncodedTemplateYaml.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateTemplateRequestDto = [4]string{
	0: "uuid",
	1: "name",
	2: "templateJson",
	3: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateRequestDto from json.
func (s *UpdateTemplateRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateJson":
			if err := func() error {
				s.TemplateJson = nil
				var elem UpdateTemplateRequestDtoTemplateJson
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.TemplateJson = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			if err := func() error {
				s.EncodedTemplateYaml.Reset()
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateRequestDto) {
					name = jsonFieldsNameOfUpdateTemplateRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateRequestDtoTemplateJson) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUpdateTemplateRequestDtoTemplateJson = [0]string{}

// Decode decodes UpdateTemplateRequestDtoTemplateJson from json.
func (s *UpdateTemplateRequestDtoTemplateJson) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateRequestDtoTemplateJson to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateRequestDtoTemplateJson")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateRequestDtoTemplateJson) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateTemplateResponseDto from json.
func (s *UpdateTemplateResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDto) {
					name = jsonFieldsNameOfUpdateTemplateResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateTemplateResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("templateType")
		s.TemplateType.Encode(e)
	}
	{
		if len(s.TemplateJson) != 0 {
			e.FieldStart("templateJson")
			e.Raw(s.TemplateJson)
		}
	}
	{
		e.FieldStart("encodedTemplateYaml")
		s.EncodedTemplateYaml.Encode(e)
	}
}

var jsonFieldsNameOfUpdateTemplateResponseDtoResponse = [5]string{
	0: "uuid",
	1: "name",
	2: "templateType",
	3: "templateJson",
	4: "encodedTemplateYaml",
}

// Decode decodes UpdateTemplateResponseDtoResponse from json.
func (s *UpdateTemplateResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponse to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "templateType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.TemplateType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateType\"")
			}
		case "templateJson":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.TemplateJson = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"templateJson\"")
			}
		case "encodedTemplateYaml":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.EncodedTemplateYaml.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encodedTemplateYaml\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateTemplateResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateTemplateResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateTemplateResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateTemplateResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateTemplateResponseDtoResponseTemplateType as json.
func (s UpdateTemplateResponseDtoResponseTemplateType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateTemplateResponseDtoResponseTemplateType from json.
func (s *UpdateTemplateResponseDtoResponseTemplateType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateTemplateResponseDtoResponseTemplateType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateTemplateResponseDtoResponseTemplateType(v) {
	case UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeXRAYJSON
	case UpdateTemplateResponseDtoResponseTemplateTypeXRAYBASE64:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeXRAYBASE64
	case UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeMIHOMO
	case UpdateTemplateResponseDtoResponseTemplateTypeSTASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSTASH
	case UpdateTemplateResponseDtoResponseTemplateTypeCLASH:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeCLASH
	case UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX:
		*s = UpdateTemplateResponseDtoResponseTemplateTypeSINGBOX
	default:
		*s = UpdateTemplateResponseDtoResponseTemplateType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateTemplateResponseDtoResponseTemplateType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateTemplateResponseDtoResponseTemplateType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserRequestDto) encodeFields(e *jx.Encoder) {
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
	{
		if s.UUID.Set {
			e.FieldStart("uuid")
			s.UUID.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		if s.ExpireAt.Set {
			e.FieldStart("expireAt")
			s.ExpireAt.Encode(e, json.EncodeDateTime)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Tag.Set {
			e.FieldStart("tag")
			s.Tag.Encode(e)
		}
	}
	{
		if s.TelegramId.Set {
			e.FieldStart("telegramId")
			s.TelegramId.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	{
		if s.HwidDeviceLimit.Set {
			e.FieldStart("hwidDeviceLimit")
			s.HwidDeviceLimit.Encode(e)
		}
	}
	{
		if s.ActiveInternalSquads != nil {
			e.FieldStart("activeInternalSquads")
			e.ArrStart()
			for _, elem := range s.ActiveInternalSquads {
				json.EncodeUUID(e, elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalSquadUuid.Set {
			e.FieldStart("externalSquadUuid")
			s.ExternalSquadUuid.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateUserRequestDto = [13]string{
	0:  "username",
	1:  "uuid",
	2:  "status",
	3:  "trafficLimitBytes",
	4:  "trafficLimitStrategy",
	5:  "expireAt",
	6:  "description",
	7:  "tag",
	8:  "telegramId",
	9:  "email",
	10: "hwidDeviceLimit",
	11: "activeInternalSquads",
	12: "externalSquadUuid",
}

// Decode decodes UpdateUserRequestDto from json.
func (s *UpdateUserRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDto to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "uuid":
			if err := func() error {
				s.UUID.Reset()
				if err := s.UUID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "expireAt":
			if err := func() error {
				s.ExpireAt.Reset()
				if err := s.ExpireAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			if err := func() error {
				s.Tag.Reset()
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			if err := func() error {
				s.TelegramId.Reset()
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			if err := func() error {
				s.HwidDeviceLimit.Reset()
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "activeInternalSquads":
			if err := func() error {
				s.ActiveInternalSquads = make([]uuid.UUID, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem uuid.UUID
					v, err := json.DecodeUUID(d)
					elem = v
					if err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			if err := func() error {
				s.ExternalSquadUuid.Reset()
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserRequestDto")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoStatus as json.
func (s UpdateUserRequestDtoStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoStatus from json.
func (s *UpdateUserRequestDtoStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoStatus(v) {
	case UpdateUserRequestDtoStatusACTIVE:
		*s = UpdateUserRequestDtoStatusACTIVE
	case UpdateUserRequestDtoStatusDISABLED:
		*s = UpdateUserRequestDtoStatusDISABLED
	default:
		*s = UpdateUserRequestDtoStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserRequestDtoTrafficLimitStrategy as json.
func (s UpdateUserRequestDtoTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserRequestDtoTrafficLimitStrategy from json.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserRequestDtoTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserRequestDtoTrafficLimitStrategy(v) {
	case UpdateUserRequestDtoTrafficLimitStrategyNORESET:
		*s = UpdateUserRequestDtoTrafficLimitStrategyNORESET
	case UpdateUserRequestDtoTrafficLimitStrategyDAY:
		*s = UpdateUserRequestDtoTrafficLimitStrategyDAY
	case UpdateUserRequestDtoTrafficLimitStrategyWEEK:
		*s = UpdateUserRequestDtoTrafficLimitStrategyWEEK
	case UpdateUserRequestDtoTrafficLimitStrategyMONTH:
		*s = UpdateUserRequestDtoTrafficLimitStrategyMONTH
	default:
		*s = UpdateUserRequestDtoTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserRequestDtoTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserRequestDtoTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserResponseDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserResponseDto) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("response")
		s.Response.Encode(e)
	}
}

var jsonFieldsNameOfUpdateUserResponseDto = [1]string{
	0: "response",
}

// Decode decodes UpdateUserResponseDto from json.
func (s *UpdateUserResponseDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Response.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserResponseDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserResponseDto) {
					name = jsonFieldsNameOfUpdateUserResponseDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserResponseDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserResponseDtoResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserResponseDtoResponse) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("shortUuid")
		e.Str(s.ShortUuid)
	}
	{
		e.FieldStart("username")
		e.Str(s.Username)
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		e.FieldStart("usedTrafficBytes")
		e.Float64(s.UsedTrafficBytes)
	}
	{
		e.FieldStart("lifetimeUsedTrafficBytes")
		e.Float64(s.LifetimeUsedTrafficBytes)
	}
	{
		if s.TrafficLimitBytes.Set {
			e.FieldStart("trafficLimitBytes")
			s.TrafficLimitBytes.Encode(e)
		}
	}
	{
		if s.TrafficLimitStrategy.Set {
			e.FieldStart("trafficLimitStrategy")
			s.TrafficLimitStrategy.Encode(e)
		}
	}
	{
		e.FieldStart("subLastUserAgent")
		s.SubLastUserAgent.Encode(e)
	}
	{
		e.FieldStart("subLastOpenedAt")
		s.SubLastOpenedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("expireAt")
		json.EncodeDateTime(e, s.ExpireAt)
	}
	{
		e.FieldStart("onlineAt")
		s.OnlineAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("subRevokedAt")
		s.SubRevokedAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("lastTrafficResetAt")
		s.LastTrafficResetAt.Encode(e, json.EncodeDateTime)
	}
	{
		e.FieldStart("trojanPassword")
		e.Str(s.TrojanPassword)
	}
	{
		e.FieldStart("vlessUuid")
		json.EncodeUUID(e, s.VlessUuid)
	}
	{
		e.FieldStart("ssPassword")
		e.Str(s.SsPassword)
	}
	{
		e.FieldStart("description")
		s.Description.Encode(e)
	}
	{
		e.FieldStart("tag")
		s.Tag.Encode(e)
	}
	{
		e.FieldStart("telegramId")
		s.TelegramId.Encode(e)
	}
	{
		e.FieldStart("email")
		s.Email.Encode(e)
	}
	{
		e.FieldStart("hwidDeviceLimit")
		s.HwidDeviceLimit.Encode(e)
	}
	{
		e.FieldStart("firstConnectedAt")
		s.FirstConnectedAt.Encode(e, json.EncodeDateTime)
	}
	{
		if s.LastTriggeredThreshold.Set {
			e.FieldStart("lastTriggeredThreshold")
			s.LastTriggeredThreshold.Encode(e)
		}
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
	{
		e.FieldStart("updatedAt")
		json.EncodeDateTime(e, s.UpdatedAt)
	}
	{
		e.FieldStart("activeInternalSquads")
		e.ArrStart()
		for _, elem := range s.ActiveInternalSquads {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("externalSquadUuid")
		s.ExternalSquadUuid.Encode(e)
	}
	{
		e.FieldStart("subscriptionUrl")
		e.Str(s.SubscriptionUrl)
	}
	{
		e.FieldStart("lastConnectedNode")
		s.LastConnectedNode.Encode(e)
	}
	{
		e.FieldStart("happ")
		s.Happ.Encode(e)
	}
}

var jsonFieldsNameOfUpdateUserResponseDtoResponse = [31]string{
	0:  "uuid",
	1:  "shortUuid",
	2:  "username",
	3:  "status",
	4:  "usedTrafficBytes",
	5:  "lifetimeUsedTrafficBytes",
	6:  "trafficLimitBytes",
	7:  "trafficLimitStrategy",
	8:  "subLastUserAgent",
	9:  "subLastOpenedAt",
	10: "expireAt",
	11: "onlineAt",
	12: "subRevokedAt",
	13: "lastTrafficResetAt",
	14: "trojanPassword",
	15: "vlessUuid",
	16: "ssPassword",
	17: "description",
	18: "tag",
	19: "telegramId",
	20: "email",
	21: "hwidDeviceLimit",
	22: "firstConnectedAt",
	23: "lastTriggeredThreshold",
	24: "createdAt",
	25: "updatedAt",
	26: "activeInternalSquads",
	27: "externalSquadUuid",
	28: "subscriptionUrl",
	29: "lastConnectedNode",
	30: "happ",
}

// Decode decodes UpdateUserResponseDtoResponse from json.
func (s *UpdateUserResponseDtoResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponse to nil")
	}
	var requiredBitSet [4]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "shortUuid":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ShortUuid = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"shortUuid\"")
			}
		case "username":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Username = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "usedTrafficBytes":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Float64()
				s.UsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usedTrafficBytes\"")
			}
		case "lifetimeUsedTrafficBytes":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Float64()
				s.LifetimeUsedTrafficBytes = float64(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lifetimeUsedTrafficBytes\"")
			}
		case "trafficLimitBytes":
			if err := func() error {
				s.TrafficLimitBytes.Reset()
				if err := s.TrafficLimitBytes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitBytes\"")
			}
		case "trafficLimitStrategy":
			if err := func() error {
				s.TrafficLimitStrategy.Reset()
				if err := s.TrafficLimitStrategy.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trafficLimitStrategy\"")
			}
		case "subLastUserAgent":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				if err := s.SubLastUserAgent.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastUserAgent\"")
			}
		case "subLastOpenedAt":
			requiredBitSet[1] |= 1 << 1
			if err := func() error {
				if err := s.SubLastOpenedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subLastOpenedAt\"")
			}
		case "expireAt":
			requiredBitSet[1] |= 1 << 2
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ExpireAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"expireAt\"")
			}
		case "onlineAt":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				if err := s.OnlineAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"onlineAt\"")
			}
		case "subRevokedAt":
			requiredBitSet[1] |= 1 << 4
			if err := func() error {
				if err := s.SubRevokedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subRevokedAt\"")
			}
		case "lastTrafficResetAt":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				if err := s.LastTrafficResetAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTrafficResetAt\"")
			}
		case "trojanPassword":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.TrojanPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trojanPassword\"")
			}
		case "vlessUuid":
			requiredBitSet[1] |= 1 << 7
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.VlessUuid = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"vlessUuid\"")
			}
		case "ssPassword":
			requiredBitSet[2] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.SsPassword = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ssPassword\"")
			}
		case "description":
			requiredBitSet[2] |= 1 << 1
			if err := func() error {
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "tag":
			requiredBitSet[2] |= 1 << 2
			if err := func() error {
				if err := s.Tag.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tag\"")
			}
		case "telegramId":
			requiredBitSet[2] |= 1 << 3
			if err := func() error {
				if err := s.TelegramId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"telegramId\"")
			}
		case "email":
			requiredBitSet[2] |= 1 << 4
			if err := func() error {
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		case "hwidDeviceLimit":
			requiredBitSet[2] |= 1 << 5
			if err := func() error {
				if err := s.HwidDeviceLimit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hwidDeviceLimit\"")
			}
		case "firstConnectedAt":
			requiredBitSet[2] |= 1 << 6
			if err := func() error {
				if err := s.FirstConnectedAt.Decode(d, json.DecodeDateTime); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"firstConnectedAt\"")
			}
		case "lastTriggeredThreshold":
			if err := func() error {
				s.LastTriggeredThreshold.Reset()
				if err := s.LastTriggeredThreshold.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastTriggeredThreshold\"")
			}
		case "createdAt":
			requiredBitSet[3] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		case "updatedAt":
			requiredBitSet[3] |= 1 << 1
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.UpdatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updatedAt\"")
			}
		case "activeInternalSquads":
			requiredBitSet[3] |= 1 << 2
			if err := func() error {
				s.ActiveInternalSquads = make([]UpdateUserResponseDtoResponseActiveInternalSquadsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UpdateUserResponseDtoResponseActiveInternalSquadsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.ActiveInternalSquads = append(s.ActiveInternalSquads, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"activeInternalSquads\"")
			}
		case "externalSquadUuid":
			requiredBitSet[3] |= 1 << 3
			if err := func() error {
				if err := s.ExternalSquadUuid.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalSquadUuid\"")
			}
		case "subscriptionUrl":
			requiredBitSet[3] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.SubscriptionUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"subscriptionUrl\"")
			}
		case "lastConnectedNode":
			requiredBitSet[3] |= 1 << 5
			if err := func() error {
				if err := s.LastConnectedNode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"lastConnectedNode\"")
			}
		case "happ":
			requiredBitSet[3] |= 1 << 6
			if err := func() error {
				if err := s.Happ.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"happ\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserResponseDtoResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [4]uint8{
		0b00110111,
		0b11111111,
		0b01111111,
		0b01111111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserResponseDtoResponse) {
					name = jsonFieldsNameOfUpdateUserResponseDtoResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserResponseDtoResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserResponseDtoResponseActiveInternalSquadsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserResponseDtoResponseActiveInternalSquadsItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("uuid")
		json.EncodeUUID(e, s.UUID)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfUpdateUserResponseDtoResponseActiveInternalSquadsItem = [2]string{
	0: "uuid",
	1: "name",
}

// Decode decodes UpdateUserResponseDtoResponseActiveInternalSquadsItem from json.
func (s *UpdateUserResponseDtoResponseActiveInternalSquadsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponseActiveInternalSquadsItem to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "uuid":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeUUID(d)
				s.UUID = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uuid\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserResponseDtoResponseActiveInternalSquadsItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserResponseDtoResponseActiveInternalSquadsItem) {
					name = jsonFieldsNameOfUpdateUserResponseDtoResponseActiveInternalSquadsItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserResponseDtoResponseActiveInternalSquadsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponseActiveInternalSquadsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserResponseDtoResponseHapp) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserResponseDtoResponseHapp) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("cryptoLink")
		e.Str(s.CryptoLink)
	}
}

var jsonFieldsNameOfUpdateUserResponseDtoResponseHapp = [1]string{
	0: "cryptoLink",
}

// Decode decodes UpdateUserResponseDtoResponseHapp from json.
func (s *UpdateUserResponseDtoResponseHapp) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponseHapp to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "cryptoLink":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.CryptoLink = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"cryptoLink\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserResponseDtoResponseHapp")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserResponseDtoResponseHapp) {
					name = jsonFieldsNameOfUpdateUserResponseDtoResponseHapp[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserResponseDtoResponseHapp) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponseHapp) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateUserResponseDtoResponseLastConnectedNode) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateUserResponseDtoResponseLastConnectedNode) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connectedAt")
		json.EncodeDateTime(e, s.ConnectedAt)
	}
	{
		e.FieldStart("nodeName")
		e.Str(s.NodeName)
	}
	{
		e.FieldStart("countryCode")
		e.Str(s.CountryCode)
	}
}

var jsonFieldsNameOfUpdateUserResponseDtoResponseLastConnectedNode = [3]string{
	0: "connectedAt",
	1: "nodeName",
	2: "countryCode",
}

// Decode decodes UpdateUserResponseDtoResponseLastConnectedNode from json.
func (s *UpdateUserResponseDtoResponseLastConnectedNode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponseLastConnectedNode to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connectedAt":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.ConnectedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectedAt\"")
			}
		case "nodeName":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NodeName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nodeName\"")
			}
		case "countryCode":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.CountryCode = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"countryCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateUserResponseDtoResponseLastConnectedNode")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateUserResponseDtoResponseLastConnectedNode) {
					name = jsonFieldsNameOfUpdateUserResponseDtoResponseLastConnectedNode[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateUserResponseDtoResponseLastConnectedNode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponseLastConnectedNode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserResponseDtoResponseStatus as json.
func (s UpdateUserResponseDtoResponseStatus) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserResponseDtoResponseStatus from json.
func (s *UpdateUserResponseDtoResponseStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponseStatus to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserResponseDtoResponseStatus(v) {
	case UpdateUserResponseDtoResponseStatusACTIVE:
		*s = UpdateUserResponseDtoResponseStatusACTIVE
	case UpdateUserResponseDtoResponseStatusDISABLED:
		*s = UpdateUserResponseDtoResponseStatusDISABLED
	case UpdateUserResponseDtoResponseStatusLIMITED:
		*s = UpdateUserResponseDtoResponseStatusLIMITED
	case UpdateUserResponseDtoResponseStatusEXPIRED:
		*s = UpdateUserResponseDtoResponseStatusEXPIRED
	default:
		*s = UpdateUserResponseDtoResponseStatus(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserResponseDtoResponseStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponseStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateUserResponseDtoResponseTrafficLimitStrategy as json.
func (s UpdateUserResponseDtoResponseTrafficLimitStrategy) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UpdateUserResponseDtoResponseTrafficLimitStrategy from json.
func (s *UpdateUserResponseDtoResponseTrafficLimitStrategy) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateUserResponseDtoResponseTrafficLimitStrategy to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UpdateUserResponseDtoResponseTrafficLimitStrategy(v) {
	case UpdateUserResponseDtoResponseTrafficLimitStrategyNORESET:
		*s = UpdateUserResponseDtoResponseTrafficLimitStrategyNORESET
	case UpdateUserResponseDtoResponseTrafficLimitStrategyDAY:
		*s = UpdateUserResponseDtoResponseTrafficLimitStrategyDAY
	case UpdateUserResponseDtoResponseTrafficLimitStrategyWEEK:
		*s = UpdateUserResponseDtoResponseTrafficLimitStrategyWEEK
	case UpdateUserResponseDtoResponseTrafficLimitStrategyMONTH:
		*s = UpdateUserResponseDtoResponseTrafficLimitStrategyMONTH
	default:
		*s = UpdateUserResponseDtoResponseTrafficLimitStrategy(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateUserResponseDtoResponseTrafficLimitStrategy) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateUserResponseDtoResponseTrafficLimitStrategy) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem = [0]string{}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem = [0]string{}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError from json.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UserSubscriptionRequestHistoryControllerGetSubscriptionRequestHistoryStatsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkAllResetUserTrafficBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest from json.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError from json.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkAllResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersBadRequest from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersByStatusInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkDeleteUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkDeleteUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkDeleteUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkDeleteUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkDeleteUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkResetUserTrafficBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkResetUserTrafficBadRequest from json.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkResetUserTrafficBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkResetUserTrafficBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkResetUserTrafficInternalServerError from json.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest from json.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError from json.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkRevokeUsersSubscriptionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateAllUsersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateAllUsersBadRequest from json.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateAllUsersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateAllUsersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateAllUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateAllUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersBadRequest from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem = [0]string{}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError from json.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersBulkActionsControllerBulkUpdateUsersInternalSquadsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerCreateUserBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerCreateUserBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerCreateUserBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerCreateUserBadRequest from json.
func (s *UsersControllerCreateUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerCreateUserBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerCreateUserBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerCreateUserBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerCreateUserBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerCreateUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerCreateUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerCreateUserBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerCreateUserBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerCreateUserBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerCreateUserBadRequestErrorsItem from json.
func (s *UsersControllerCreateUserBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerCreateUserBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerCreateUserBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerCreateUserBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerCreateUserBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerCreateUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerCreateUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerCreateUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerCreateUserInternalServerError from json.
func (s *UsersControllerCreateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerCreateUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerCreateUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerCreateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerCreateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDeleteUserBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDeleteUserBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerDeleteUserBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerDeleteUserBadRequest from json.
func (s *UsersControllerDeleteUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDeleteUserBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerDeleteUserBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerDeleteUserBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDeleteUserBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDeleteUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDeleteUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDeleteUserBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDeleteUserBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerDeleteUserBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerDeleteUserBadRequestErrorsItem from json.
func (s *UsersControllerDeleteUserBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDeleteUserBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDeleteUserBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDeleteUserBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDeleteUserBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDeleteUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDeleteUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerDeleteUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerDeleteUserInternalServerError from json.
func (s *UsersControllerDeleteUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDeleteUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDeleteUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDeleteUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDeleteUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDisableUserBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDisableUserBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerDisableUserBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerDisableUserBadRequest from json.
func (s *UsersControllerDisableUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDisableUserBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerDisableUserBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerDisableUserBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDisableUserBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDisableUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDisableUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDisableUserBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDisableUserBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerDisableUserBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerDisableUserBadRequestErrorsItem from json.
func (s *UsersControllerDisableUserBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDisableUserBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDisableUserBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDisableUserBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDisableUserBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerDisableUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerDisableUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerDisableUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerDisableUserInternalServerError from json.
func (s *UsersControllerDisableUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerDisableUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerDisableUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerDisableUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerDisableUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerEnableUserBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerEnableUserBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerEnableUserBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerEnableUserBadRequest from json.
func (s *UsersControllerEnableUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerEnableUserBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerEnableUserBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerEnableUserBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerEnableUserBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerEnableUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerEnableUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerEnableUserBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerEnableUserBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerEnableUserBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerEnableUserBadRequestErrorsItem from json.
func (s *UsersControllerEnableUserBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerEnableUserBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerEnableUserBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerEnableUserBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerEnableUserBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerEnableUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerEnableUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerEnableUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerEnableUserInternalServerError from json.
func (s *UsersControllerEnableUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerEnableUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerEnableUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerEnableUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerEnableUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllTagsBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllTagsBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllTagsBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetAllTagsBadRequest from json.
func (s *UsersControllerGetAllTagsBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllTagsBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetAllTagsBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetAllTagsBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllTagsBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllTagsBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllTagsBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllTagsBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllTagsBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetAllTagsBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetAllTagsBadRequestErrorsItem from json.
func (s *UsersControllerGetAllTagsBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllTagsBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllTagsBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllTagsBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllTagsBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllTagsInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllTagsInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllTagsInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetAllTagsInternalServerError from json.
func (s *UsersControllerGetAllTagsInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllTagsInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllTagsInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllTagsInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllTagsInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllUsersBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllUsersBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllUsersBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetAllUsersBadRequest from json.
func (s *UsersControllerGetAllUsersBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllUsersBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetAllUsersBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetAllUsersBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllUsersBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllUsersBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllUsersBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllUsersBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllUsersBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetAllUsersBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetAllUsersBadRequestErrorsItem from json.
func (s *UsersControllerGetAllUsersBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllUsersBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllUsersBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllUsersBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllUsersBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetAllUsersInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetAllUsersInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetAllUsersInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetAllUsersInternalServerError from json.
func (s *UsersControllerGetAllUsersInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetAllUsersInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetAllUsersInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetAllUsersInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetAllUsersInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserAccessibleNodesBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserAccessibleNodesBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserAccessibleNodesBadRequest from json.
func (s *UsersControllerGetUserAccessibleNodesBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserAccessibleNodesBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserAccessibleNodesBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserAccessibleNodesBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserAccessibleNodesBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserAccessibleNodesBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserAccessibleNodesBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserAccessibleNodesBadRequestErrorsItem from json.
func (s *UsersControllerGetUserAccessibleNodesBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserAccessibleNodesBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserAccessibleNodesBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserAccessibleNodesBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserAccessibleNodesInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserAccessibleNodesInternalServerError from json.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserAccessibleNodesInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserAccessibleNodesInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserAccessibleNodesInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByShortUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByShortUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByShortUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserByShortUuidBadRequest from json.
func (s *UsersControllerGetUserByShortUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByShortUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserByShortUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserByShortUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByShortUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByShortUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByShortUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByShortUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByShortUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserByShortUuidBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserByShortUuidBadRequestErrorsItem from json.
func (s *UsersControllerGetUserByShortUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByShortUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByShortUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByShortUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByShortUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByShortUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByShortUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByShortUuidInternalServerError from json.
func (s *UsersControllerGetUserByShortUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByShortUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByShortUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByShortUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByTelegramIdBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByTelegramIdBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserByTelegramIdBadRequest from json.
func (s *UsersControllerGetUserByTelegramIdBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByTelegramIdBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserByTelegramIdBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserByTelegramIdBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByTelegramIdBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByTelegramIdBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserByTelegramIdBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserByTelegramIdBadRequestErrorsItem from json.
func (s *UsersControllerGetUserByTelegramIdBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByTelegramIdBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByTelegramIdBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByTelegramIdBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByTelegramIdInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByTelegramIdInternalServerError from json.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByTelegramIdInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByTelegramIdInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByTelegramIdInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUsernameBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUsernameBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUsernameBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserByUsernameBadRequest from json.
func (s *UsersControllerGetUserByUsernameBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUsernameBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserByUsernameBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserByUsernameBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUsernameBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUsernameBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUsernameBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUsernameBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUsernameBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserByUsernameBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserByUsernameBadRequestErrorsItem from json.
func (s *UsersControllerGetUserByUsernameBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUsernameBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUsernameBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUsernameBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUsernameBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUsernameInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUsernameInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByUsernameInternalServerError from json.
func (s *UsersControllerGetUserByUsernameInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUsernameInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUsernameInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUsernameInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUuidBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUuidBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUuidBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserByUuidBadRequest from json.
func (s *UsersControllerGetUserByUuidBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUuidBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserByUuidBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserByUuidBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUuidBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUuidBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUuidBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUuidBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUuidBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserByUuidBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserByUuidBadRequestErrorsItem from json.
func (s *UsersControllerGetUserByUuidBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUuidBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUuidBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUuidBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUuidBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserByUuidInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserByUuidInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserByUuidInternalServerError from json.
func (s *UsersControllerGetUserByUuidInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserByUuidInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserByUuidInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserByUuidInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserSubscriptionRequestHistoryBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUserSubscriptionRequestHistoryBadRequest from json.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserSubscriptionRequestHistoryBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserSubscriptionRequestHistoryBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem from json.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUserSubscriptionRequestHistoryInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUserSubscriptionRequestHistoryInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUserSubscriptionRequestHistoryInternalServerError from json.
func (s *UsersControllerGetUserSubscriptionRequestHistoryInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUserSubscriptionRequestHistoryInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUserSubscriptionRequestHistoryInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUserSubscriptionRequestHistoryInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByEmailBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByEmailBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByEmailBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUsersByEmailBadRequest from json.
func (s *UsersControllerGetUsersByEmailBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByEmailBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUsersByEmailBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUsersByEmailBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByEmailBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByEmailBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByEmailBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByEmailBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByEmailBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUsersByEmailBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUsersByEmailBadRequestErrorsItem from json.
func (s *UsersControllerGetUsersByEmailBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByEmailBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByEmailBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByEmailBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByEmailBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByEmailInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByEmailInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUsersByEmailInternalServerError from json.
func (s *UsersControllerGetUsersByEmailInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByEmailInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByEmailInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByEmailInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByTagBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByTagBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByTagBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerGetUsersByTagBadRequest from json.
func (s *UsersControllerGetUsersByTagBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByTagBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerGetUsersByTagBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerGetUsersByTagBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByTagBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByTagBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByTagBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByTagBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByTagBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerGetUsersByTagBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerGetUsersByTagBadRequestErrorsItem from json.
func (s *UsersControllerGetUsersByTagBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByTagBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByTagBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByTagBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByTagBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerGetUsersByTagInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerGetUsersByTagInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerGetUsersByTagInternalServerError from json.
func (s *UsersControllerGetUsersByTagInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerGetUsersByTagInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerGetUsersByTagInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerGetUsersByTagInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerResetUserTrafficBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerResetUserTrafficBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerResetUserTrafficBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerResetUserTrafficBadRequest from json.
func (s *UsersControllerResetUserTrafficBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerResetUserTrafficBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerResetUserTrafficBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerResetUserTrafficBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerResetUserTrafficBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerResetUserTrafficBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerResetUserTrafficBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerResetUserTrafficBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerResetUserTrafficBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerResetUserTrafficBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerResetUserTrafficBadRequestErrorsItem from json.
func (s *UsersControllerResetUserTrafficBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerResetUserTrafficBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerResetUserTrafficBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerResetUserTrafficBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerResetUserTrafficBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerResetUserTrafficInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerResetUserTrafficInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerResetUserTrafficInternalServerError from json.
func (s *UsersControllerResetUserTrafficInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerResetUserTrafficInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerResetUserTrafficInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerResetUserTrafficInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerRevokeUserSubscriptionBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerRevokeUserSubscriptionBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerRevokeUserSubscriptionBadRequest from json.
func (s *UsersControllerRevokeUserSubscriptionBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerRevokeUserSubscriptionBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerRevokeUserSubscriptionBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerRevokeUserSubscriptionBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerRevokeUserSubscriptionBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerRevokeUserSubscriptionBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerRevokeUserSubscriptionBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerRevokeUserSubscriptionBadRequestErrorsItem from json.
func (s *UsersControllerRevokeUserSubscriptionBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerRevokeUserSubscriptionBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerRevokeUserSubscriptionBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerRevokeUserSubscriptionBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerRevokeUserSubscriptionInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerRevokeUserSubscriptionInternalServerError from json.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerRevokeUserSubscriptionInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerRevokeUserSubscriptionInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerRevokeUserSubscriptionInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerUpdateUserBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerUpdateUserBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersControllerUpdateUserBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersControllerUpdateUserBadRequest from json.
func (s *UsersControllerUpdateUserBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerUpdateUserBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersControllerUpdateUserBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersControllerUpdateUserBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerUpdateUserBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerUpdateUserBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerUpdateUserBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerUpdateUserBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerUpdateUserBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersControllerUpdateUserBadRequestErrorsItem = [0]string{}

// Decode decodes UsersControllerUpdateUserBadRequestErrorsItem from json.
func (s *UsersControllerUpdateUserBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerUpdateUserBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerUpdateUserBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerUpdateUserBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerUpdateUserBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersControllerUpdateUserInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersControllerUpdateUserInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersControllerUpdateUserInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersControllerUpdateUserInternalServerError from json.
func (s *UsersControllerUpdateUserInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersControllerUpdateUserInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersControllerUpdateUserInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersControllerUpdateUserInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersControllerUpdateUserInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
	{
		if s.Errors != nil {
			e.FieldStart("errors")
			e.ArrStart()
			for _, elem := range s.Errors {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfUsersStatsControllerGetUserUsageByRangeBadRequest = [3]string{
	0: "message",
	1: "statusCode",
	2: "errors",
}

// Decode decodes UsersStatsControllerGetUserUsageByRangeBadRequest from json.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersStatsControllerGetUserUsageByRangeBadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		case "errors":
			if err := func() error {
				s.Errors = make([]UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Errors = append(s.Errors, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errors\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersStatsControllerGetUserUsageByRangeBadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfUsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem = [0]string{}

// Decode decodes UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem from json.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersStatsControllerGetUserUsageByRangeBadRequestErrorsItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) encodeFields(e *jx.Encoder) {
	{
		if s.Timestamp.Set {
			e.FieldStart("timestamp")
			s.Timestamp.Encode(e)
		}
	}
	{
		if s.Path.Set {
			e.FieldStart("path")
			s.Path.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.ErrorCode.Set {
			e.FieldStart("errorCode")
			s.ErrorCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfUsersStatsControllerGetUserUsageByRangeInternalServerError = [4]string{
	0: "timestamp",
	1: "path",
	2: "message",
	3: "errorCode",
}

// Decode decodes UsersStatsControllerGetUserUsageByRangeInternalServerError from json.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UsersStatsControllerGetUserUsageByRangeInternalServerError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "timestamp":
			if err := func() error {
				s.Timestamp.Reset()
				if err := s.Timestamp.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"timestamp\"")
			}
		case "path":
			if err := func() error {
				s.Path.Reset()
				if err := s.Path.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"path\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "errorCode":
			if err := func() error {
				s.ErrorCode.Reset()
				if err := s.ErrorCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"errorCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UsersStatsControllerGetUserUsageByRangeInternalServerError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UsersStatsControllerGetUserUsageByRangeInternalServerError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyPasskeyAuthenticationRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyPasskeyAuthenticationRequestDto) encodeFields(e *jx.Encoder) {
	{
		if len(s.Response) != 0 {
			e.FieldStart("response")
			e.Raw(s.Response)
		}
	}
}

var jsonFieldsNameOfVerifyPasskeyAuthenticationRequestDto = [1]string{
	0: "response",
}

// Decode decodes VerifyPasskeyAuthenticationRequestDto from json.
func (s *VerifyPasskeyAuthenticationRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyPasskeyAuthenticationRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Response = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyPasskeyAuthenticationRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyPasskeyAuthenticationRequestDto) {
					name = jsonFieldsNameOfVerifyPasskeyAuthenticationRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyPasskeyAuthenticationRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyPasskeyAuthenticationRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *VerifyPasskeyRegistrationRequestDto) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *VerifyPasskeyRegistrationRequestDto) encodeFields(e *jx.Encoder) {
	{
		if len(s.Response) != 0 {
			e.FieldStart("response")
			e.Raw(s.Response)
		}
	}
}

var jsonFieldsNameOfVerifyPasskeyRegistrationRequestDto = [1]string{
	0: "response",
}

// Decode decodes VerifyPasskeyRegistrationRequestDto from json.
func (s *VerifyPasskeyRegistrationRequestDto) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode VerifyPasskeyRegistrationRequestDto to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "response":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Response = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"response\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode VerifyPasskeyRegistrationRequestDto")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfVerifyPasskeyRegistrationRequestDto) {
					name = jsonFieldsNameOfVerifyPasskeyRegistrationRequestDto[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *VerifyPasskeyRegistrationRequestDto) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *VerifyPasskeyRegistrationRequestDto) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
