// Code generated by pagination generator. DO NOT EDIT manually.
// This file provides pagination utilities for list endpoints.

package api

// PaginationHelper provides utilities for manually paginating through results.
// Use this for more control when ListAll iterator is not sufficient.
type PaginationHelper struct {
	Offset   int
	Limit    int
	Total    *int
	HasMore  bool
}

// NewPaginationHelper creates a new pagination helper with the given page size.
func NewPaginationHelper(pageSize int) *PaginationHelper {
	if pageSize <= 0 {
		pageSize = 50
	}
	return &PaginationHelper{
		Offset:  0,
		Limit:   pageSize,
		HasMore: true,
	}
}

// NextPage advances to the next page.
// Returns false if there are no more pages.
func (ph *PaginationHelper) NextPage() bool {
	if !ph.HasMore {
		return false
	}
	ph.Offset += ph.Limit
	return true
}

// PreviousPage goes back to the previous page.
// Returns false if we're on the first page.
func (ph *PaginationHelper) PreviousPage() bool {
	if ph.Offset == 0 {
		return false
	}
	ph.Offset -= ph.Limit
	return true
}

// FirstPage resets to the first page.
func (ph *PaginationHelper) FirstPage() {
	ph.Offset = 0
}

// CurrentPage returns the current page number (1-indexed).
func (ph *PaginationHelper) CurrentPage() int {
	return (ph.Offset / ph.Limit) + 1
}

// SetTotal sets the total number of items (if known from API response).
// This can be used to calculate total pages.
func (ph *PaginationHelper) SetTotal(total int) {
	ph.Total = &total
	// If we've fetched less than a full page, we know there are no more pages
}

// TotalPages returns the total number of pages (if Total was set).
// Returns -1 if total is unknown.
func (ph *PaginationHelper) TotalPages() int {
	if ph.Total == nil {
		return -1
	}
	pages := *ph.Total / ph.Limit
	if *ph.Total%ph.Limit > 0 {
		pages++
	}
	if pages == 0 {
		pages = 1
	}
	return pages
}

// CanGoNext returns true if there are potentially more pages.
func (ph *PaginationHelper) CanGoNext() bool {
	return ph.HasMore
}

// CanGoPrevious returns true if we're not on the first page.
func (ph *PaginationHelper) CanGoPrevious() bool {
	return ph.Offset > 0
}

// Example usage:

// Example_ManualPagination shows how to manually paginate using PaginationHelper.
//
// This example demonstrates using the pagination helper for manual control:
//
//   pager := NewPaginationHelper(10) // 10 items per page
//   for {
//       resp, err := client.UsersControllerGetAllUsers(ctx, UsersControllerGetAllUsersParams{
//           Start: NewOptFloat64(float64(pager.Offset)),
//           Size:  NewOptFloat64(float64(pager.Limit)),
//       })
//       if err != nil {
//           log.Fatal(err)
//       }
//
//       if usersResp, ok := resp.(*GetAllUsersResponseDto); ok {
//           fmt.Printf("Page %d\n", pager.CurrentPage())
//           for _, user := range usersResp.Response.Users {
//               fmt.Println("- ", user.Username)
//           }
//           pager.SetTotal(int(usersResp.Response.Total))
//           pager.HasMore = len(usersResp.Response.Users) >= pager.Limit
//       }
//
//       if !pager.CanGoNext() {
//           break
//       }
//       pager.NextPage()
//   }
//
// For simpler iteration without manual control, see the sub-client examples.

// Note: OptFloat64 is already defined in oas_schemas_gen.go
// Use the NewOptFloat64() function from there for creating pagination parameters.

// BatchProcessor helps process paginated results in batches or with callbacks.
type BatchProcessor struct {
	pageSize int
	maxPages int
}

// NewBatchProcessor creates a new batch processor.
func NewBatchProcessor(pageSize int) *BatchProcessor {
	if pageSize <= 0 {
		pageSize = 50
	}
	return &BatchProcessor{
		pageSize: pageSize,
		maxPages: 0, // 0 means unlimited
	}
}

// SetMaxPages sets the maximum number of pages to fetch.
func (bp *BatchProcessor) SetMaxPages(max int) *BatchProcessor {
	bp.maxPages = max
	return bp
}

// Example of batch processing (to be implemented by user):
//
//   processor := NewBatchProcessor(100)
//   processor.SetMaxPages(10)
//
//   pager := NewPaginationHelper(processor.pageSize)
//   pageCount := 0
//
//   for pageCount < processor.maxPages || processor.maxPages == 0 {
//       resp, err := client.GetUsers(ctx, pager.Offset, pager.Limit)
//       if err != nil {
//           break
//       }
//
//       // Process this batch
//       fmt.Printf("Processing page %d with %d items\n", pager.CurrentPage(), len(resp.Items))
//
//       if len(resp.Items) < processor.pageSize {
//           break // No more pages
//       }
//
//       pager.NextPage()
//       pageCount++
//   }
