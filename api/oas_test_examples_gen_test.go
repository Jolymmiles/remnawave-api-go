// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestBadRequestError_EncodeDecode(t *testing.T) {
	var typ BadRequestError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponse_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponse_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponseRecordsItem_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponseRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponseRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponseRecordsItemProvider_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponseRecordsItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponseRecordsItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponse_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponse_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseAvailableBillingNodesItem_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseAvailableBillingNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseAvailableBillingNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseBillingNodesItem_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseBillingNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseBillingNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseBillingNodesItemNode_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseBillingNodesItemNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseBillingNodesItemNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseBillingNodesItemProvider_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseBillingNodesItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseBillingNodesItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseStats_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkActionResponse_EncodeDecode(t *testing.T) {
	var typ BulkActionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkActionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkActionResponseResponse_EncodeDecode(t *testing.T) {
	var typ BulkActionResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkActionResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkDeleteUsersByStatusRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkDeleteUsersByStatusRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkDeleteUsersByStatusRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkDeleteUsersByStatusRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ BulkDeleteUsersByStatusRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkDeleteUsersByStatusRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFields_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFields
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFields
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFieldsStatus_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFieldsStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFieldsStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersSquadsRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersSquadsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersSquadsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUuidsRequest_EncodeDecode(t *testing.T) {
	var typ BulkUuidsRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUuidsRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileResponse_EncodeDecode(t *testing.T) {
	var typ ConfigProfileResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileResponseResponse_EncodeDecode(t *testing.T) {
	var typ ConfigProfileResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileResponseResponseInboundsItem_EncodeDecode(t *testing.T) {
	var typ ConfigProfileResponseResponseInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileResponseResponseInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileResponseResponseNodesItem_EncodeDecode(t *testing.T) {
	var typ ConfigProfileResponseResponseNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileResponseResponseNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenResponseDto_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateConfigProfileRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateConfigProfileRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateConfigProfileRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateConfigProfileRequestDtoConfig_EncodeDecode(t *testing.T) {
	var typ CreateConfigProfileRequestDtoConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateConfigProfileRequestDtoConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateExternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoAlpn_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoAlpn
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoAlpn
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoFingerprint_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoFingerprint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoFingerprint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoInbound_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoSecurityLayer_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraBillingHistoryRecordRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraBillingHistoryRecordRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraBillingHistoryRecordRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraBillingNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraBillingNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraBillingNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraProviderRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraProviderRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraProviderRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateNodeRequestDtoConfigProfile_EncodeDecode(t *testing.T) {
	var typ CreateNodeRequestDtoConfigProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateNodeRequestDtoConfigProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateSubscriptionTemplateRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionTemplateRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionTemplateRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateSubscriptionTemplateRequestDtoTemplateType_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionTemplateRequestDtoTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionTemplateRequestDtoTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserHwidDeviceRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateUserHwidDeviceRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserHwidDeviceRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDto_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRules_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItem_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemConditionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemOperator_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModifications
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesRulesItemResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDtoResponseRulesVersion_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDtoResponseRulesVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDtoResponseRulesVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDto_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseInputHeaders_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseInputHeaders
	typ = make(DebugSrrMatcherResponseDtoResponseInputHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseInputHeaders
	typ2 = make(DebugSrrMatcherResponseDtoResponseInputHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRule_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleConditionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleOperator_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModifications
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleResponseModificationsHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseMatchedRuleResponseType_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseMatchedRuleResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseOutputHeaders_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseOutputHeaders
	typ = make(DebugSrrMatcherResponseDtoResponseOutputHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseOutputHeaders
	typ2 = make(DebugSrrMatcherResponseDtoResponseOutputHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseResponseType_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteAllUserHwidDevicesRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteAllUserHwidDevicesRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteAllUserHwidDevicesRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiTokenResponseDto_EncodeDecode(t *testing.T) {
	var typ DeleteApiTokenResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiTokenResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePasskeyRequestDto_EncodeDecode(t *testing.T) {
	var typ DeletePasskeyRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePasskeyRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteResponse_EncodeDecode(t *testing.T) {
	var typ DeleteResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteResponseResponse_EncodeDecode(t *testing.T) {
	var typ DeleteResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSnippetRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteSnippetRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSnippetRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUserHwidDeviceRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteUserHwidDeviceRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUserHwidDeviceRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkRequestDto_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkResponseDto_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventResponse_EncodeDecode(t *testing.T) {
	var typ EventResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventResponseResponse_EncodeDecode(t *testing.T) {
	var typ EventResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponse_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponse_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseHostOverrides_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseHostOverrides
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseHostOverrides
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseInfo_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseResponseHeaders_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseResponseHeaders
	typ = make(ExternalSquadResponseResponseResponseResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseResponseHeaders
	typ2 = make(ExternalSquadResponseResponseResponseResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseSubscriptionSettings_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseSubscriptionSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseSubscriptionSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseTemplatesItem_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseTemplatesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseTemplatesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponseResponseTemplatesItemTemplateType_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponseResponseTemplatesItemTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponseResponseTemplatesItemTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDto_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponseApiKeysItem_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponseApiKeysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponseApiKeysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponseDocs_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponseDocs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponseDocs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenError_EncodeDecode(t *testing.T) {
	var typ ForbiddenError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDto_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDtoResponseKeypairsItem_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDtoResponseKeypairsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDtoResponseKeypairsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllHwidDevicesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllHwidDevicesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllHwidDevicesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllHwidDevicesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetAllHwidDevicesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllHwidDevicesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllHwidDevicesResponseDtoResponseDevicesItem_EncodeDecode(t *testing.T) {
	var typ GetAllHwidDevicesResponseDtoResponseDevicesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllHwidDevicesResponseDtoResponseDevicesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItem_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks
	typ = make(GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks
	typ2 = make(GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItem_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItemActiveInternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItemHapp_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItemHapp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItemHapp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItemLastConnectedNode_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItemLastConnectedNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItemLastConnectedNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItemStatus_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItemStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItemStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponseUsersItemTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponseBandwidthCalendarMonth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponseBandwidthCurrentYear_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponseBandwidthCurrentYear
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponseBandwidthLast30Days_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponseBandwidthLast30Days
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponseBandwidthLast30Days
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponseBandwidthLastSevenDays
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponseBandwidthLastTwoDays
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDtoResponseConfigProfilesItem_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDtoResponseConfigProfilesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDtoResponseConfigProfilesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDtoResponseConfigProfilesItemInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDtoResponseConfigProfilesItemNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemHostOverrides_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemHostOverrides
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemHostOverrides
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemInfo_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemResponseHeaders_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemResponseHeaders
	typ = make(GetExternalSquadsResponseDtoResponseExternalSquadsItemResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemResponseHeaders
	typ2 = make(GetExternalSquadsResponseDtoResponseExternalSquadsItemResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemSubscriptionSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponseExternalSquadsItemTemplatesItemTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponseByAppItem_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponseByAppItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponseByAppItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponseByPlatformItem_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponseByPlatformItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponseByPlatformItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponseStats_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponseStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponseStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDtoResponseProvidersItem_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDtoResponseProvidersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDtoResponseProvidersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDtoResponseProvidersItemBillingHistory_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDtoResponseProvidersItemBillingHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDtoResponseProvidersItemBillingNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDtoResponseInternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDtoResponseInternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDtoResponseInternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDtoResponseInternalSquadsItemInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDtoResponseInternalSquadsItemInfo_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDtoResponseInternalSquadsItemInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodeUserUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodeUserUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodeUserUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodeUserUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodeUserUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodeUserUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponseNodesItem_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponseNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponseNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponseNodesItemInboundsStatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponseNodesItemOutboundsStatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesRealtimeUsageResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesRealtimeUsageResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesRealtimeUsageResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesRealtimeUsageResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodesRealtimeUsageResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesRealtimeUsageResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDtoResponseLastSevenDaysItem_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodesUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPubKeyResponseDto_EncodeDecode(t *testing.T) {
	var typ GetPubKeyResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPubKeyResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPubKeyResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetPubKeyResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPubKeyResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDto_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseHeaders_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseHeaders
	typ = make(GetRawSubscriptionByShortUuidResponseDtoResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseHeaders
	typ2 = make(GetRawSubscriptionByShortUuidResponseDtoResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUser_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUserActiveInternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUserHapp_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUserHapp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUserLastConnectedNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUserStatus_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseUserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDto_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDtoResponsePm2StatsItem_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDtoResponsePm2StatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDtoResponsePm2StatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseCPU_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseCPU
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseCPU
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseMemory_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseNodes_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseOnlineStats_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseOnlineStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseOnlineStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseUsers_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseUsers
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseUsers
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseUsersStatusCounts_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseUsersStatusCounts
	typ = make(GetStatsResponseDtoResponseUsersStatusCounts)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseUsersStatusCounts
	typ2 = make(GetStatsResponseDtoResponseUsersStatusCounts)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDto_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthentication_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthentication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthentication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationOAuth2_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationOAuth2
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationOAuth2
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationOAuth2Providers_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationOAuth2Providers
	typ = make(GetStatusResponseDtoResponseAuthenticationOAuth2Providers)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationOAuth2Providers
	typ2 = make(GetStatusResponseDtoResponseAuthenticationOAuth2Providers)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationPasskey_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationPasskey
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationPasskey
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationPassword_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationPassword
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationPassword
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationTgAuth_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationTgAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationTgAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseBranding_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseBranding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseBranding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryResponseDto_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryResponseDtoResponseRecordsItem_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryResponseDtoResponseRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDtoResponseByParsedAppItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDtoResponseTemplatesItem_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDtoResponseTemplatesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDtoResponseTemplatesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDtoResponseTemplatesItemTemplateType_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDtoResponseTemplatesItemTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDtoResponseTemplatesItemTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponseActiveNodesItem_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserSubscriptionRequestHistoryResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserSubscriptionRequestHistoryResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserSubscriptionRequestHistoryResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserSubscriptionRequestHistoryResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetUserSubscriptionRequestHistoryResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserSubscriptionRequestHistoryResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem_EncodeDecode(t *testing.T) {
	var typ GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserSubscriptionRequestHistoryResponseDtoResponseRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetUserUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostListResponse_EncodeDecode(t *testing.T) {
	var typ HostListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostListResponseResponseItem_EncodeDecode(t *testing.T) {
	var typ HostListResponseResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostListResponseResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostListResponseResponseItemInbound_EncodeDecode(t *testing.T) {
	var typ HostListResponseResponseItemInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostListResponseResponseItemInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostListResponseResponseItemSecurityLayer_EncodeDecode(t *testing.T) {
	var typ HostListResponseResponseItemSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostListResponseResponseItemSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostResponse_EncodeDecode(t *testing.T) {
	var typ HostResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostResponseResponse_EncodeDecode(t *testing.T) {
	var typ HostResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostResponseResponseInbound_EncodeDecode(t *testing.T) {
	var typ HostResponseResponseInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostResponseResponseInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostResponseResponseSecurityLayer_EncodeDecode(t *testing.T) {
	var typ HostResponseResponseSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostResponseResponseSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHwidDevicesResponse_EncodeDecode(t *testing.T) {
	var typ HwidDevicesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HwidDevicesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHwidDevicesResponseResponse_EncodeDecode(t *testing.T) {
	var typ HwidDevicesResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HwidDevicesResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHwidDevicesResponseResponseDevicesItem_EncodeDecode(t *testing.T) {
	var typ HwidDevicesResponseResponseDevicesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HwidDevicesResponseResponseDevicesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponse_EncodeDecode(t *testing.T) {
	var typ InboundsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponseResponse_EncodeDecode(t *testing.T) {
	var typ InboundsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponseResponseInboundsItem_EncodeDecode(t *testing.T) {
	var typ InboundsResponseResponseInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponseResponseInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInfraProviderResponseResponse_EncodeDecode(t *testing.T) {
	var typ InfraProviderResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InfraProviderResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInfraProviderResponseResponseResponse_EncodeDecode(t *testing.T) {
	var typ InfraProviderResponseResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InfraProviderResponseResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInfraProviderResponseResponseResponseBillingHistory_EncodeDecode(t *testing.T) {
	var typ InfraProviderResponseResponseResponseBillingHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InfraProviderResponseResponseResponseBillingHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInfraProviderResponseResponseResponseBillingNodesItem_EncodeDecode(t *testing.T) {
	var typ InfraProviderResponseResponseResponseBillingNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InfraProviderResponseResponseResponseBillingNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalServerError_EncodeDecode(t *testing.T) {
	var typ InternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadResponseResponse_EncodeDecode(t *testing.T) {
	var typ InternalSquadResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadResponseResponseResponse_EncodeDecode(t *testing.T) {
	var typ InternalSquadResponseResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadResponseResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadResponseResponseResponseInboundsItem_EncodeDecode(t *testing.T) {
	var typ InternalSquadResponseResponseResponseInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadResponseResponseResponseInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadResponseResponseResponseInfo_EncodeDecode(t *testing.T) {
	var typ InternalSquadResponseResponseResponseInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadResponseResponseResponseInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginRequestDto_EncodeDecode(t *testing.T) {
	var typ LoginRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponse_EncodeDecode(t *testing.T) {
	var typ NodeResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponseResponse_EncodeDecode(t *testing.T) {
	var typ NodeResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponseResponseConfigProfile_EncodeDecode(t *testing.T) {
	var typ NodeResponseResponseConfigProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponseResponseConfigProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponseResponseConfigProfileActiveInboundsItem_EncodeDecode(t *testing.T) {
	var typ NodeResponseResponseConfigProfileActiveInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponseResponseConfigProfileActiveInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponseResponseProvider_EncodeDecode(t *testing.T) {
	var typ NodeResponseResponseProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponseResponseProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponse_EncodeDecode(t *testing.T) {
	var typ NodesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponseResponseItem_EncodeDecode(t *testing.T) {
	var typ NodesResponseResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponseResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponseResponseItemConfigProfile_EncodeDecode(t *testing.T) {
	var typ NodesResponseResponseItemConfigProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponseResponseItemConfigProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponseResponseItemConfigProfileActiveInboundsItem_EncodeDecode(t *testing.T) {
	var typ NodesResponseResponseItemConfigProfileActiveInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponseResponseItemConfigProfileActiveInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponseResponseItemProvider_EncodeDecode(t *testing.T) {
	var typ NodesResponseResponseItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponseResponseItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFoundError_EncodeDecode(t *testing.T) {
	var typ NotFoundError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeRequestDto_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeRequestDtoProvider_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeRequestDtoProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeRequestDtoProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeResponseDto_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2CallbackRequestDto_EncodeDecode(t *testing.T) {
	var typ OAuth2CallbackRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2CallbackRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2CallbackRequestDtoProvider_EncodeDecode(t *testing.T) {
	var typ OAuth2CallbackRequestDtoProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2CallbackRequestDtoProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeyOptions_EncodeDecode(t *testing.T) {
	var typ PasskeyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponse_EncodeDecode(t *testing.T) {
	var typ PasskeysResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponseResponse_EncodeDecode(t *testing.T) {
	var typ PasskeysResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponseResponsePasskeysItem_EncodeDecode(t *testing.T) {
	var typ PasskeysResponseResponsePasskeysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponseResponsePasskeysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRegisterRequestDto_EncodeDecode(t *testing.T) {
	var typ RegisterRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegisterRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostRequestDto_EncodeDecode(t *testing.T) {
	var typ ReorderHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostRequestDtoHostsItem_EncodeDecode(t *testing.T) {
	var typ ReorderHostRequestDtoHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostRequestDtoHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostResponseDto_EncodeDecode(t *testing.T) {
	var typ ReorderHostResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ ReorderHostResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ ReorderNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderNodeRequestDtoNodesItem_EncodeDecode(t *testing.T) {
	var typ ReorderNodeRequestDtoNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderNodeRequestDtoNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRestartAllNodesRequestBodyDto_EncodeDecode(t *testing.T) {
	var typ RestartAllNodesRequestBodyDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RestartAllNodesRequestBodyDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRevokeUserSubscriptionBodyDto_EncodeDecode(t *testing.T) {
	var typ RevokeUserSubscriptionBodyDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevokeUserSubscriptionBodyDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetInboundToManyHostsRequestDto_EncodeDecode(t *testing.T) {
	var typ SetInboundToManyHostsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetInboundToManyHostsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetPortToManyHostsRequestDto_EncodeDecode(t *testing.T) {
	var typ SetPortToManyHostsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetPortToManyHostsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponse_EncodeDecode(t *testing.T) {
	var typ SettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseBrandingSettings_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseBrandingSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseBrandingSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseOauth2Settings_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseOauth2Settings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseOauth2Settings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseOauth2SettingsGithub_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseOauth2SettingsGithub
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseOauth2SettingsGithub
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseOauth2SettingsPocketid_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseOauth2SettingsPocketid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseOauth2SettingsPocketid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseOauth2SettingsYandex_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseOauth2SettingsYandex
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseOauth2SettingsYandex
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponsePasskeySettings_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponsePasskeySettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponsePasskeySettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponsePasswordSettings_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponsePasswordSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponsePasswordSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponseTgAuthSettings_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponseTgAuthSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponseTgAuthSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetRequest_EncodeDecode(t *testing.T) {
	var typ SnippetRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetRequestSnippetItem_EncodeDecode(t *testing.T) {
	var typ SnippetRequestSnippetItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetRequestSnippetItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponse_EncodeDecode(t *testing.T) {
	var typ SnippetsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SnippetsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponseResponseSnippetsItem_EncodeDecode(t *testing.T) {
	var typ SnippetsResponseResponseSnippetsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponseResponseSnippetsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseHapp_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseHapp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseHapp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseSsConfLinks_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseSsConfLinks
	typ = make(SubscriptionResponseResponseSsConfLinks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseSsConfLinks
	typ2 = make(SubscriptionResponseResponseSsConfLinks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUser_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUserUserStatus_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUserUserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUserUserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseCustomResponseHeaders_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseCustomResponseHeaders
	typ = make(SubscriptionSettingsResponseResponseCustomResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseCustomResponseHeaders
	typ2 = make(SubscriptionSettingsResponseResponseCustomResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRules_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItem_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItem_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItemOperator_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemConditionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemOperator_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModifications_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModifications
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModifications
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModificationsHeadersItem_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModificationsHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseModificationsHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesRulesItemResponseType_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesRulesItemResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseResponseRulesVersion_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseResponseRulesVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseResponseRulesVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagsResponse_EncodeDecode(t *testing.T) {
	var typ TagsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagsResponseResponse_EncodeDecode(t *testing.T) {
	var typ TagsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTelegramCallbackRequestDto_EncodeDecode(t *testing.T) {
	var typ TelegramCallbackRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TelegramCallbackRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateResponse_EncodeDecode(t *testing.T) {
	var typ TemplateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateResponseResponse_EncodeDecode(t *testing.T) {
	var typ TemplateResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateResponseResponseTemplateType_EncodeDecode(t *testing.T) {
	var typ TemplateResponseResponseTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateResponseResponseTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponseResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedError_EncodeDecode(t *testing.T) {
	var typ UnauthorizedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateConfigProfileRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateConfigProfileRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateConfigProfileRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateConfigProfileRequestDtoConfig_EncodeDecode(t *testing.T) {
	var typ UpdateConfigProfileRequestDtoConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateConfigProfileRequestDtoConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoHostOverrides_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoHostOverrides
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoHostOverrides
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoResponseHeaders_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoResponseHeaders
	typ = make(UpdateExternalSquadRequestDtoResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoResponseHeaders
	typ2 = make(UpdateExternalSquadRequestDtoResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoSubscriptionSettings_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoSubscriptionSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoSubscriptionSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoTemplatesItem_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoTemplatesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoTemplatesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoTemplatesItemTemplateType_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoTemplatesItemTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoTemplatesItemTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoAlpn_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoAlpn
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoAlpn
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoFingerprint_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoFingerprint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoFingerprint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoInbound_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoSecurityLayer_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInfraBillingNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInfraBillingNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInfraBillingNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInfraProviderRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInfraProviderRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInfraProviderRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateNodeRequestDtoConfigProfile_EncodeDecode(t *testing.T) {
	var typ UpdateNodeRequestDtoConfigProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateNodeRequestDtoConfigProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoBrandingSettings_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoBrandingSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoBrandingSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoOauth2Settings_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoOauth2Settings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoOauth2Settings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoOauth2SettingsGithub
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoOauth2SettingsPocketid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoOauth2SettingsYandex
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoPasskeySettings_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoPasskeySettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoPasskeySettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoPasswordSettings_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoPasswordSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoPasswordSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDtoTgAuthSettings_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDtoTgAuthSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDtoTgAuthSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders
	typ = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders
	typ2 = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRules_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemConditionsItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModifications
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseModificationsHeadersItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesRulesItemResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoResponseRulesVersion_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoResponseRulesVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoResponseRulesVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateTemplateRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateTemplateRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateTemplateRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateTemplateRequestDtoTemplateJson_EncodeDecode(t *testing.T) {
	var typ UpdateTemplateRequestDtoTemplateJson
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateTemplateRequestDtoTemplateJson
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponse_EncodeDecode(t *testing.T) {
	var typ UserResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponse_EncodeDecode(t *testing.T) {
	var typ UserResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponseActiveInternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ UserResponseResponseActiveInternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponseActiveInternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponseHapp_EncodeDecode(t *testing.T) {
	var typ UserResponseResponseHapp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponseHapp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponseLastConnectedNode_EncodeDecode(t *testing.T) {
	var typ UserResponseResponseLastConnectedNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponseLastConnectedNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponseStatus_EncodeDecode(t *testing.T) {
	var typ UserResponseResponseStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponseStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponseResponseTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ UserResponseResponseTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponseResponseTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponse_EncodeDecode(t *testing.T) {
	var typ UsersResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItem_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItemActiveInternalSquadsItem_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItemActiveInternalSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItemActiveInternalSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItemHapp_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItemHapp
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItemHapp
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItemLastConnectedNode_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItemLastConnectedNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItemLastConnectedNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItemStatus_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItemStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItemStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponseResponseItemTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ UsersResponseResponseItemTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponseResponseItemTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationError_EncodeDecode(t *testing.T) {
	var typ ValidationError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerifyPasskeyRegistrationResponseDto_EncodeDecode(t *testing.T) {
	var typ VerifyPasskeyRegistrationResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerifyPasskeyRegistrationResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerifyPasskeyRegistrationResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ VerifyPasskeyRegistrationResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerifyPasskeyRegistrationResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
