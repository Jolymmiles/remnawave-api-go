// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestActiveInternalSquad_EncodeDecode(t *testing.T) {
	var typ ActiveInternalSquad
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActiveInternalSquad
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAllHwidDevices_EncodeDecode(t *testing.T) {
	var typ AllHwidDevices
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AllHwidDevices
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBadRequestError_EncodeDecode(t *testing.T) {
	var typ BadRequestError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBandwidthLastTwoDays_EncodeDecode(t *testing.T) {
	var typ BandwidthLastTwoDays
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BandwidthLastTwoDays
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryItem_EncodeDecode(t *testing.T) {
	var typ BillingHistoryItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponse_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponse_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponseRecordsItem_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponseRecordsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponseRecordsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingHistoryResponseResponseRecordsItemProvider_EncodeDecode(t *testing.T) {
	var typ BillingHistoryResponseResponseRecordsItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingHistoryResponseResponseRecordsItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNode_EncodeDecode(t *testing.T) {
	var typ BillingNode
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNode
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponse_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponse_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseBillingNodesItem_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseBillingNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseBillingNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseBillingNodesItemProvider_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseBillingNodesItemProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseBillingNodesItemProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBillingNodesResponseResponseStats_EncodeDecode(t *testing.T) {
	var typ BillingNodesResponseResponseStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BillingNodesResponseResponseStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBrandingSettings_EncodeDecode(t *testing.T) {
	var typ BrandingSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BrandingSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkActionResponse_EncodeDecode(t *testing.T) {
	var typ BulkActionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkActionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkActionResponseResponse_EncodeDecode(t *testing.T) {
	var typ BulkActionResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkActionResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkAllUpdateUsersRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ BulkAllUpdateUsersRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkAllUpdateUsersRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkDeleteUsersByStatusRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkDeleteUsersByStatusRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkDeleteUsersByStatusRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkDeleteUsersByStatusRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ BulkDeleteUsersByStatusRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkDeleteUsersByStatusRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFields_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFields
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFields
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFieldsStatus_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFieldsStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFieldsStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersRequestDtoFieldsTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUpdateUsersSquadsRequestDto_EncodeDecode(t *testing.T) {
	var typ BulkUpdateUsersSquadsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUpdateUsersSquadsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBulkUuidsRequest_EncodeDecode(t *testing.T) {
	var typ BulkUuidsRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BulkUuidsRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestByAppItem_EncodeDecode(t *testing.T) {
	var typ ByAppItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ByAppItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCondition_EncodeDecode(t *testing.T) {
	var typ Condition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Condition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConditionOperator_EncodeDecode(t *testing.T) {
	var typ ConditionOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConditionOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfile_EncodeDecode(t *testing.T) {
	var typ ConfigProfile
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfile
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileItem_EncodeDecode(t *testing.T) {
	var typ ConfigProfileItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileRef_EncodeDecode(t *testing.T) {
	var typ ConfigProfileRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConfigProfileResponse_EncodeDecode(t *testing.T) {
	var typ ConfigProfileResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConfigProfileResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenResponseDto_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateApiTokenResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ CreateApiTokenResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateApiTokenResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateConfigProfileRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateConfigProfileRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateConfigProfileRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateConfigProfileRequestDtoConfig_EncodeDecode(t *testing.T) {
	var typ CreateConfigProfileRequestDtoConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateConfigProfileRequestDtoConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateExternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateExternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateExternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoAlpn_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoAlpn
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoAlpn
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoFingerprint_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoFingerprint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoFingerprint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateHostRequestDtoSecurityLayer_EncodeDecode(t *testing.T) {
	var typ CreateHostRequestDtoSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateHostRequestDtoSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraBillingHistoryRecordRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraBillingHistoryRecordRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraBillingHistoryRecordRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraBillingNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraBillingNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraBillingNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInfraProviderRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInfraProviderRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInfraProviderRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateInternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateInternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateInternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateSubscriptionTemplateRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionTemplateRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionTemplateRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateSubscriptionTemplateRequestDtoTemplateType_EncodeDecode(t *testing.T) {
	var typ CreateSubscriptionTemplateRequestDtoTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateSubscriptionTemplateRequestDtoTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserHwidDeviceRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateUserHwidDeviceRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserHwidDeviceRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDto_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreateUserRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ CreateUserRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreateUserRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherRequestDto_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDto_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseInputHeaders_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseInputHeaders
	typ = make(DebugSrrMatcherResponseDtoResponseInputHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseInputHeaders
	typ2 = make(DebugSrrMatcherResponseDtoResponseInputHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseOutputHeaders_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseOutputHeaders
	typ = make(DebugSrrMatcherResponseDtoResponseOutputHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseOutputHeaders
	typ2 = make(DebugSrrMatcherResponseDtoResponseOutputHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDebugSrrMatcherResponseDtoResponseResponseType_EncodeDecode(t *testing.T) {
	var typ DebugSrrMatcherResponseDtoResponseResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DebugSrrMatcherResponseDtoResponseResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteAllUserHwidDevicesRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteAllUserHwidDevicesRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteAllUserHwidDevicesRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteApiTokenResponseDto_EncodeDecode(t *testing.T) {
	var typ DeleteApiTokenResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteApiTokenResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeletePasskeyRequestDto_EncodeDecode(t *testing.T) {
	var typ DeletePasskeyRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeletePasskeyRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteResponse_EncodeDecode(t *testing.T) {
	var typ DeleteResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteResponseResponse_EncodeDecode(t *testing.T) {
	var typ DeleteResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteSnippetRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteSnippetRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteSnippetRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDeleteUserHwidDeviceRequestDto_EncodeDecode(t *testing.T) {
	var typ DeleteUserHwidDeviceRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DeleteUserHwidDeviceRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDevice_EncodeDecode(t *testing.T) {
	var typ Device
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Device
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkRequestDto_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkResponseDto_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEncryptHappCryptoLinkResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ EncryptHappCryptoLinkResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EncryptHappCryptoLinkResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventResponse_EncodeDecode(t *testing.T) {
	var typ EventResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventResponseResponse_EncodeDecode(t *testing.T) {
	var typ EventResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquad_EncodeDecode(t *testing.T) {
	var typ ExternalSquad
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquad
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseHeaders_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseHeaders
	typ = make(ExternalSquadResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseHeaders
	typ2 = make(ExternalSquadResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadResponseResponse_EncodeDecode(t *testing.T) {
	var typ ExternalSquadResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestExternalSquadsInfoItem_EncodeDecode(t *testing.T) {
	var typ ExternalSquadsInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ExternalSquadsInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDto_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponseApiKeysItem_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponseApiKeysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponseApiKeysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestFindAllApiTokensResponseDtoResponseDocs_EncodeDecode(t *testing.T) {
	var typ FindAllApiTokensResponseDtoResponseDocs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 FindAllApiTokensResponseDtoResponseDocs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenError_EncodeDecode(t *testing.T) {
	var typ ForbiddenError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDto_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGenerateX25519ResponseDtoResponseKeypairsItem_EncodeDecode(t *testing.T) {
	var typ GenerateX25519ResponseDtoResponseKeypairsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GenerateX25519ResponseDtoResponseKeypairsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllHwidDevicesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllHwidDevicesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllHwidDevicesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItem_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks
	typ = make(GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks
	typ2 = make(GetAllSubscriptionsResponseDtoResponseSubscriptionsItemSsConfLinks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus_EncodeDecode(t *testing.T) {
	var typ GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllSubscriptionsResponseDtoResponseSubscriptionsItemUserUserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDto_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetAllUsersResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetAllUsersResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetAllUsersResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetBandwidthStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetBandwidthStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetBandwidthStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetConfigProfilesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetConfigProfilesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetConfigProfilesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetExternalSquadsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetExternalSquadsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetExternalSquadsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponseByPlatformItem_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponseByPlatformItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponseByPlatformItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetHwidDevicesStatsResponseDtoResponseStats_EncodeDecode(t *testing.T) {
	var typ GetHwidDevicesStatsResponseDtoResponseStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetHwidDevicesStatsResponseDtoResponseStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInfraProvidersResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInfraProvidersResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInfraProvidersResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadAccessibleNodesResponseDtoResponseAccessibleNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetInternalSquadsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetInternalSquadsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetInternalSquadsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodeUserUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodeUserUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodeUserUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodeUserUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodeUserUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodeUserUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesMetricsResponseDtoResponseNodesItem_EncodeDecode(t *testing.T) {
	var typ GetNodesMetricsResponseDtoResponseNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesMetricsResponseDtoResponseNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesRealtimeUsageResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesRealtimeUsageResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesRealtimeUsageResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesRealtimeUsageResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodesRealtimeUsageResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesRealtimeUsageResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesStatisticsResponseDtoResponseLastSevenDaysItem_EncodeDecode(t *testing.T) {
	var typ GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesStatisticsResponseDtoResponseLastSevenDaysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetNodesUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetNodesUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetNodesUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetNodesUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPubKeyResponseDto_EncodeDecode(t *testing.T) {
	var typ GetPubKeyResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPubKeyResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetPubKeyResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetPubKeyResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetPubKeyResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDto_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseConvertedUserInfo
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseHeaders_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseHeaders
	typ = make(GetRawSubscriptionByShortUuidResponseDtoResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseHeaders
	typ2 = make(GetRawSubscriptionByShortUuidResponseDtoResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemAdditionalParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemDbDataRawInbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemMuxParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemPassword
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemProtocolOptionsSs
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemSockoptParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams_EncodeDecode(t *testing.T) {
	var typ GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRawSubscriptionByShortUuidResponseDtoResponseRawHostsItemXHttpExtraParams
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDto_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetRemnawaveHealthResponseDtoResponsePm2StatsItem_EncodeDecode(t *testing.T) {
	var typ GetRemnawaveHealthResponseDtoResponsePm2StatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetRemnawaveHealthResponseDtoResponsePm2StatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseCPU_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseCPU
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseCPU
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseMemory_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseMemory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseMemory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseNodes_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseNodes
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseNodes
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseOnlineStats_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseOnlineStats
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseOnlineStats
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseUsers_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseUsers
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseUsers
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatsResponseDtoResponseUsersStatusCounts_EncodeDecode(t *testing.T) {
	var typ GetStatsResponseDtoResponseUsersStatusCounts
	typ = make(GetStatsResponseDtoResponseUsersStatusCounts)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatsResponseDtoResponseUsersStatusCounts
	typ2 = make(GetStatsResponseDtoResponseUsersStatusCounts)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDto_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthentication_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthentication
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthentication
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationOAuth2_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationOAuth2
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationOAuth2
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationOAuth2Providers_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationOAuth2Providers
	typ = make(GetStatusResponseDtoResponseAuthenticationOAuth2Providers)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationOAuth2Providers
	typ2 = make(GetStatusResponseDtoResponseAuthenticationOAuth2Providers)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseAuthenticationTgAuth_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseAuthenticationTgAuth
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseAuthenticationTgAuth
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetStatusResponseDtoResponseBranding_EncodeDecode(t *testing.T) {
	var typ GetStatusResponseDtoResponseBranding
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetStatusResponseDtoResponseBranding
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryResponseDto_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDto_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem_EncodeDecode(t *testing.T) {
	var typ GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetSubscriptionRequestHistoryStatsResponseDtoResponseHourlyRequestStatsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetTemplatesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetTemplatesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetTemplatesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponseActiveNodesItem_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponseActiveNodesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem_EncodeDecode(t *testing.T) {
	var typ GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserAccessibleNodesResponseDtoResponseActiveNodesItemActiveSquadsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserSubscriptionRequestHistoryResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserSubscriptionRequestHistoryResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserSubscriptionRequestHistoryResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserUsageByRangeResponseDto_EncodeDecode(t *testing.T) {
	var typ GetUserUsageByRangeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserUsageByRangeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetUserUsageByRangeResponseDtoResponseItem_EncodeDecode(t *testing.T) {
	var typ GetUserUsageByRangeResponseDtoResponseItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetUserUsageByRangeResponseDtoResponseItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGithub_EncodeDecode(t *testing.T) {
	var typ Github
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Github
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHappItem_EncodeDecode(t *testing.T) {
	var typ HappItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HappItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHeader_EncodeDecode(t *testing.T) {
	var typ Header
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Header
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostItem_EncodeDecode(t *testing.T) {
	var typ HostItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostItemSecurityLayer_EncodeDecode(t *testing.T) {
	var typ HostItemSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostItemSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostListResponse_EncodeDecode(t *testing.T) {
	var typ HostListResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostListResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostOverride_EncodeDecode(t *testing.T) {
	var typ HostOverride
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostOverride
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHostResponse_EncodeDecode(t *testing.T) {
	var typ HostResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HostResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestHwidDevicesResponse_EncodeDecode(t *testing.T) {
	var typ HwidDevicesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 HwidDevicesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInbound_EncodeDecode(t *testing.T) {
	var typ Inbound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Inbound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundItem_EncodeDecode(t *testing.T) {
	var typ InboundItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundRef_EncodeDecode(t *testing.T) {
	var typ InboundRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponse_EncodeDecode(t *testing.T) {
	var typ InboundsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponseResponse_EncodeDecode(t *testing.T) {
	var typ InboundsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsResponseResponseInboundsItem_EncodeDecode(t *testing.T) {
	var typ InboundsResponseResponseInboundsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsResponseResponseInboundsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInboundsStat_EncodeDecode(t *testing.T) {
	var typ InboundsStat
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InboundsStat
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInfraProviderResponseResponse_EncodeDecode(t *testing.T) {
	var typ InfraProviderResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InfraProviderResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalServerError_EncodeDecode(t *testing.T) {
	var typ InternalServerError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalServerError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquad_EncodeDecode(t *testing.T) {
	var typ InternalSquad
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquad
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadResponseResponse_EncodeDecode(t *testing.T) {
	var typ InternalSquadResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestInternalSquadsInfoItem_EncodeDecode(t *testing.T) {
	var typ InternalSquadsInfoItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 InternalSquadsInfoItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLastConnectedNodeItem_EncodeDecode(t *testing.T) {
	var typ LastConnectedNodeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LastConnectedNodeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLoginRequestDto_EncodeDecode(t *testing.T) {
	var typ LoginRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LoginRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNode_EncodeDecode(t *testing.T) {
	var typ Node
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Node
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeItem_EncodeDecode(t *testing.T) {
	var typ NodeItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeRef_EncodeDecode(t *testing.T) {
	var typ NodeRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodeResponse_EncodeDecode(t *testing.T) {
	var typ NodeResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodeResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNodesResponse_EncodeDecode(t *testing.T) {
	var typ NodesResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NodesResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFoundError_EncodeDecode(t *testing.T) {
	var typ NotFoundError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeRequestDto_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeRequestDtoProvider_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeRequestDtoProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeRequestDtoProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeResponseDto_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2AuthorizeResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ OAuth2AuthorizeResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2AuthorizeResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2CallbackRequestDto_EncodeDecode(t *testing.T) {
	var typ OAuth2CallbackRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2CallbackRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOAuth2CallbackRequestDtoProvider_EncodeDecode(t *testing.T) {
	var typ OAuth2CallbackRequestDtoProvider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 OAuth2CallbackRequestDtoProvider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestOauth2Settings_EncodeDecode(t *testing.T) {
	var typ Oauth2Settings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Oauth2Settings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeyOptions_EncodeDecode(t *testing.T) {
	var typ PasskeyOptions
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeyOptions
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeySettings_EncodeDecode(t *testing.T) {
	var typ PasskeySettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeySettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponse_EncodeDecode(t *testing.T) {
	var typ PasskeysResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponseResponse_EncodeDecode(t *testing.T) {
	var typ PasskeysResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasskeysResponseResponsePasskeysItem_EncodeDecode(t *testing.T) {
	var typ PasskeysResponseResponsePasskeysItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasskeysResponseResponsePasskeysItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPasswordSettings_EncodeDecode(t *testing.T) {
	var typ PasswordSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PasswordSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPocketid_EncodeDecode(t *testing.T) {
	var typ Pocketid
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Pocketid
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProvider_EncodeDecode(t *testing.T) {
	var typ Provider
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Provider
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProviderItem_EncodeDecode(t *testing.T) {
	var typ ProviderItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProviderItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRecord_EncodeDecode(t *testing.T) {
	var typ Record
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Record
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRegisterRequestDto_EncodeDecode(t *testing.T) {
	var typ RegisterRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RegisterRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostRequestDto_EncodeDecode(t *testing.T) {
	var typ ReorderHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostResponseDto_EncodeDecode(t *testing.T) {
	var typ ReorderHostResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderHostResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ ReorderHostResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderHostResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestReorderNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ ReorderNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ReorderNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseModification_EncodeDecode(t *testing.T) {
	var typ ResponseModification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseModification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRules_EncodeDecode(t *testing.T) {
	var typ ResponseRules
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRules
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestResponseRulesVersion_EncodeDecode(t *testing.T) {
	var typ ResponseRulesVersion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ResponseRulesVersion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRestartAllNodesRequestBodyDto_EncodeDecode(t *testing.T) {
	var typ RestartAllNodesRequestBodyDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RestartAllNodesRequestBodyDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRevokeUserSubscriptionBodyDto_EncodeDecode(t *testing.T) {
	var typ RevokeUserSubscriptionBodyDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RevokeUserSubscriptionBodyDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRule_EncodeDecode(t *testing.T) {
	var typ Rule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Rule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleOperator_EncodeDecode(t *testing.T) {
	var typ RuleOperator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleOperator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestRuleResponseType_EncodeDecode(t *testing.T) {
	var typ RuleResponseType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 RuleResponseType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetInboundToManyHostsRequestDto_EncodeDecode(t *testing.T) {
	var typ SetInboundToManyHostsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetInboundToManyHostsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSetPortToManyHostsRequestDto_EncodeDecode(t *testing.T) {
	var typ SetPortToManyHostsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SetPortToManyHostsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponse_EncodeDecode(t *testing.T) {
	var typ SettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSettingsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SettingsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SettingsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetRequest_EncodeDecode(t *testing.T) {
	var typ SnippetRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetRequestSnippetItem_EncodeDecode(t *testing.T) {
	var typ SnippetRequestSnippetItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetRequestSnippetItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponse_EncodeDecode(t *testing.T) {
	var typ SnippetsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SnippetsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSnippetsResponseResponseSnippetsItem_EncodeDecode(t *testing.T) {
	var typ SnippetsResponseResponseSnippetsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SnippetsResponseResponseSnippetsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseSsConfLinks_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseSsConfLinks
	typ = make(SubscriptionResponseResponseSsConfLinks)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseSsConfLinks
	typ2 = make(SubscriptionResponseResponseSsConfLinks)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUser_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUser
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUser
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionResponseResponseUserUserStatus_EncodeDecode(t *testing.T) {
	var typ SubscriptionResponseResponseUserUserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionResponseResponseUserUserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettings_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponse_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSubscriptionSettingsResponseResponseCustomResponseHeaders_EncodeDecode(t *testing.T) {
	var typ SubscriptionSettingsResponseResponseCustomResponseHeaders
	typ = make(SubscriptionSettingsResponseResponseCustomResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SubscriptionSettingsResponseResponseCustomResponseHeaders
	typ2 = make(SubscriptionSettingsResponseResponseCustomResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagsResponse_EncodeDecode(t *testing.T) {
	var typ TagsResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagsResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTagsResponseResponse_EncodeDecode(t *testing.T) {
	var typ TagsResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TagsResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTelegramCallbackRequestDto_EncodeDecode(t *testing.T) {
	var typ TelegramCallbackRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TelegramCallbackRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplate_EncodeDecode(t *testing.T) {
	var typ Template
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Template
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateRef_EncodeDecode(t *testing.T) {
	var typ TemplateRef
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateRef
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateRefTemplateType_EncodeDecode(t *testing.T) {
	var typ TemplateRefTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateRefTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateResponse_EncodeDecode(t *testing.T) {
	var typ TemplateResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTemplateTemplateType_EncodeDecode(t *testing.T) {
	var typ TemplateTemplateType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TemplateTemplateType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTgAuthSettings_EncodeDecode(t *testing.T) {
	var typ TgAuthSettings
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TgAuthSettings
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTokenResponseResponse_EncodeDecode(t *testing.T) {
	var typ TokenResponseResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TokenResponseResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedError_EncodeDecode(t *testing.T) {
	var typ UnauthorizedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateConfigProfileRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateConfigProfileRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateConfigProfileRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateConfigProfileRequestDtoConfig_EncodeDecode(t *testing.T) {
	var typ UpdateConfigProfileRequestDtoConfig
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateConfigProfileRequestDtoConfig
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateExternalSquadRequestDtoResponseHeaders_EncodeDecode(t *testing.T) {
	var typ UpdateExternalSquadRequestDtoResponseHeaders
	typ = make(UpdateExternalSquadRequestDtoResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateExternalSquadRequestDtoResponseHeaders
	typ2 = make(UpdateExternalSquadRequestDtoResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoAlpn_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoAlpn
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoAlpn
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoFingerprint_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoFingerprint
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoFingerprint
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateHostRequestDtoSecurityLayer_EncodeDecode(t *testing.T) {
	var typ UpdateHostRequestDtoSecurityLayer
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateHostRequestDtoSecurityLayer
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInfraBillingNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInfraBillingNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInfraBillingNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInfraProviderRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInfraProviderRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInfraProviderRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateInternalSquadRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateInternalSquadRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateInternalSquadRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateNodeRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateNodeRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateNodeRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateRemnawaveSettingsRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateRemnawaveSettingsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateRemnawaveSettingsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateSubscriptionSettingsRequestDtoCustomResponseHeaders_EncodeDecode(t *testing.T) {
	var typ UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders
	typ = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders
	typ2 = make(UpdateSubscriptionSettingsRequestDtoCustomResponseHeaders)
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateTemplateRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateTemplateRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateTemplateRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateTemplateRequestDtoTemplateJson_EncodeDecode(t *testing.T) {
	var typ UpdateTemplateRequestDtoTemplateJson
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateTemplateRequestDtoTemplateJson
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDto_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDtoStatus_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDtoStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDtoStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdateUserRequestDtoTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ UpdateUserRequestDtoTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdateUserRequestDtoTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUser_EncodeDecode(t *testing.T) {
	var typ User
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 User
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserResponse_EncodeDecode(t *testing.T) {
	var typ UserResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserStatus_EncodeDecode(t *testing.T) {
	var typ UserStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserSubscriptionHistory_EncodeDecode(t *testing.T) {
	var typ UserSubscriptionHistory
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserSubscriptionHistory
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUserTrafficLimitStrategy_EncodeDecode(t *testing.T) {
	var typ UserTrafficLimitStrategy
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UserTrafficLimitStrategy
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUsersResponse_EncodeDecode(t *testing.T) {
	var typ UsersResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UsersResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestValidationError_EncodeDecode(t *testing.T) {
	var typ ValidationError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ValidationError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerifyPasskeyRegistrationResponseDto_EncodeDecode(t *testing.T) {
	var typ VerifyPasskeyRegistrationResponseDto
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerifyPasskeyRegistrationResponseDto
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestVerifyPasskeyRegistrationResponseDtoResponse_EncodeDecode(t *testing.T) {
	var typ VerifyPasskeyRegistrationResponseDtoResponse
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 VerifyPasskeyRegistrationResponseDtoResponse
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
