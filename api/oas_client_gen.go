// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.37.0"
	"go.opentelemetry.io/otel/trace"
)

type requestConfig struct {
	Client       ht.Client
	ServerURL    *url.URL
	EditRequest  func(req *http.Request) error
	EditResponse func(resp *http.Response) error
}

func (cfg *requestConfig) setDefaults(c baseClient) {
	if cfg.Client == nil {
		cfg.Client = c.cfg.Client
	}
}

func (cfg *requestConfig) onRequest(req *http.Request) error {
	if fn := cfg.EditRequest; fn != nil {
		return fn(req)
	}
	return nil
}

func (cfg *requestConfig) onResponse(resp *http.Response) error {
	if fn := cfg.EditResponse; fn != nil {
		return fn(resp)
	}
	return nil
}

// RequestOption defines options for request.
type RequestOption func(cfg *requestConfig)

// WithRequestClient sets client for request.
func WithRequestClient(client ht.Client) RequestOption {
	return func(cfg *requestConfig) {
		cfg.Client = client
	}
}

// WithServerURL sets client for request.
func WithServerURL(u *url.URL) RequestOption {
	return func(cfg *requestConfig) {
		cfg.ServerURL = u
	}
}

// WithEditRequest sets function to edit request.
func WithEditRequest(fn func(req *http.Request) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditRequest = fn
	}
}

// WithEditResponse sets function to edit response.
func WithEditResponse(fn func(resp *http.Response) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditResponse = fn
	}
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ApiTokensCreate invokes ApiTokens_create operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
	//
	// POST /api/tokens
	ApiTokensCreate(ctx context.Context, request *CreateApiTokenRequest, options ...RequestOption) (ApiTokensCreateRes, error)
	// ApiTokensDelete invokes ApiTokens_delete operation.
	//
	// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
	//
	// DELETE /api/tokens/{uuid}
	ApiTokensDelete(ctx context.Context, params ApiTokensDeleteParams, options ...RequestOption) (ApiTokensDeleteRes, error)
	// ApiTokensFindAll invokes ApiTokens_findAll operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
	//
	// GET /api/tokens
	ApiTokensFindAll(ctx context.Context, options ...RequestOption) (ApiTokensFindAllRes, error)
	// AuthGetStatus invokes Auth_getStatus operation.
	//
	// Get the status of the authentication.
	//
	// GET /api/auth/status
	AuthGetStatus(ctx context.Context, options ...RequestOption) (AuthGetStatusRes, error)
	// AuthLogin invokes Auth_login operation.
	//
	// Login as superadmin.
	//
	// POST /api/auth/login
	AuthLogin(ctx context.Context, request *LoginRequest, options ...RequestOption) (AuthLoginRes, error)
	// AuthOauth2Authorize invokes Auth_oauth2Authorize operation.
	//
	// Initiate OAuth2 authorization.
	//
	// POST /api/auth/oauth2/authorize
	AuthOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequest, options ...RequestOption) (AuthOauth2AuthorizeRes, error)
	// AuthOauth2Callback invokes Auth_oauth2Callback operation.
	//
	// Callback from OAuth2.
	//
	// POST /api/auth/oauth2/callback
	AuthOauth2Callback(ctx context.Context, request *OAuth2CallbackRequest, options ...RequestOption) (AuthOauth2CallbackRes, error)
	// AuthPasskeyAuthenticationOptions invokes Auth_passkeyAuthenticationOptions operation.
	//
	// Get the authentication options for passkey.
	//
	// GET /api/auth/passkey/authentication/options
	AuthPasskeyAuthenticationOptions(ctx context.Context, options ...RequestOption) (AuthPasskeyAuthenticationOptionsRes, error)
	// AuthPasskeyAuthenticationVerify invokes Auth_passkeyAuthenticationVerify operation.
	//
	// Verify the authentication for passkey.
	//
	// POST /api/auth/passkey/authentication/verify
	AuthPasskeyAuthenticationVerify(ctx context.Context, request *PasskeyOptions, options ...RequestOption) (AuthPasskeyAuthenticationVerifyRes, error)
	// AuthRegister invokes Auth_register operation.
	//
	// Register as superadmin.
	//
	// POST /api/auth/register
	AuthRegister(ctx context.Context, request *RegisterRequest, options ...RequestOption) (AuthRegisterRes, error)
	// AuthTelegramCallback invokes Auth_telegramCallback operation.
	//
	// Callback from Telegram OAuth2.
	//
	// POST /api/auth/oauth2/tg/callback
	AuthTelegramCallback(ctx context.Context, request *TelegramCallbackRequest, options ...RequestOption) (AuthTelegramCallbackRes, error)
	// BandwidthStatsNodesGetNodeUserUsage invokes BandwidthStatsNodes_getNodeUserUsage operation.
	//
	// Get Node User Usage by Range and Node UUID (Legacy).
	//
	// GET /api/bandwidth-stats/nodes/{uuid}/users/legacy
	BandwidthStatsNodesGetNodeUserUsage(ctx context.Context, params BandwidthStatsNodesGetNodeUserUsageParams, options ...RequestOption) (BandwidthStatsNodesGetNodeUserUsageRes, error)
	// BandwidthStatsNodesGetNodesRealtimeUsage invokes BandwidthStatsNodes_getNodesRealtimeUsage operation.
	//
	// Get Nodes Realtime Usage.
	//
	// GET /api/bandwidth-stats/nodes/realtime
	BandwidthStatsNodesGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (BandwidthStatsNodesGetNodesRealtimeUsageRes, error)
	// BandwidthStatsNodesGetStatsNodeUsersUsage invokes BandwidthStatsNodes_getStatsNodeUsersUsage operation.
	//
	// Get Node Users Usage by Node UUID.
	//
	// GET /api/bandwidth-stats/nodes/{uuid}/users
	BandwidthStatsNodesGetStatsNodeUsersUsage(ctx context.Context, params BandwidthStatsNodesGetStatsNodeUsersUsageParams, options ...RequestOption) (BandwidthStatsNodesGetStatsNodeUsersUsageRes, error)
	// BandwidthStatsUsersGetStatsNodesUsage invokes BandwidthStatsUsers_getStatsNodesUsage operation.
	//
	// Get User Usage by Range.
	//
	// GET /api/bandwidth-stats/users/{uuid}
	BandwidthStatsUsersGetStatsNodesUsage(ctx context.Context, params BandwidthStatsUsersGetStatsNodesUsageParams, options ...RequestOption) (BandwidthStatsUsersGetStatsNodesUsageRes, error)
	// BandwidthStatsUsersGetUserUsageByRange invokes BandwidthStatsUsers_getUserUsageByRange operation.
	//
	// Get User Usage by Range (Legacy).
	//
	// GET /api/bandwidth-stats/users/{uuid}/legacy
	BandwidthStatsUsersGetUserUsageByRange(ctx context.Context, params BandwidthStatsUsersGetUserUsageByRangeParams, options ...RequestOption) (BandwidthStatsUsersGetUserUsageByRangeRes, error)
	// ConfigProfileCreateConfigProfile invokes ConfigProfile_createConfigProfile operation.
	//
	// Create config profile.
	//
	// POST /api/config-profiles
	ConfigProfileCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequest, options ...RequestOption) (ConfigProfileCreateConfigProfileRes, error)
	// ConfigProfileDeleteConfigProfileByUuid invokes ConfigProfile_deleteConfigProfileByUuid operation.
	//
	// Delete config profile.
	//
	// DELETE /api/config-profiles/{uuid}
	ConfigProfileDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileDeleteConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileDeleteConfigProfileByUuidRes, error)
	// ConfigProfileGetAllInbounds invokes ConfigProfile_getAllInbounds operation.
	//
	// Get all inbounds from all config profiles.
	//
	// GET /api/config-profiles/inbounds
	ConfigProfileGetAllInbounds(ctx context.Context, options ...RequestOption) (ConfigProfileGetAllInboundsRes, error)
	// ConfigProfileGetComputedConfigProfileByUuid invokes ConfigProfile_getComputedConfigProfileByUuid operation.
	//
	// Get computed config profile by uuid.
	//
	// GET /api/config-profiles/{uuid}/computed-config
	ConfigProfileGetComputedConfigProfileByUuid(ctx context.Context, params ConfigProfileGetComputedConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileGetComputedConfigProfileByUuidRes, error)
	// ConfigProfileGetConfigProfileByUuid invokes ConfigProfile_getConfigProfileByUuid operation.
	//
	// Get config profile by uuid.
	//
	// GET /api/config-profiles/{uuid}
	ConfigProfileGetConfigProfileByUuid(ctx context.Context, params ConfigProfileGetConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileGetConfigProfileByUuidRes, error)
	// ConfigProfileGetConfigProfiles invokes ConfigProfile_getConfigProfiles operation.
	//
	// Get config profiles.
	//
	// GET /api/config-profiles
	ConfigProfileGetConfigProfiles(ctx context.Context, options ...RequestOption) (ConfigProfileGetConfigProfilesRes, error)
	// ConfigProfileGetInboundsByProfileUuid invokes ConfigProfile_getInboundsByProfileUuid operation.
	//
	// Get inbounds by profile uuid.
	//
	// GET /api/config-profiles/{uuid}/inbounds
	ConfigProfileGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileGetInboundsByProfileUuidParams, options ...RequestOption) (ConfigProfileGetInboundsByProfileUuidRes, error)
	// ConfigProfileReorderConfigProfiles invokes ConfigProfile_reorderConfigProfiles operation.
	//
	// Reorder config profiles.
	//
	// POST /api/config-profiles/actions/reorder
	ConfigProfileReorderConfigProfiles(ctx context.Context, request *ReorderRequest, options ...RequestOption) (ConfigProfileReorderConfigProfilesRes, error)
	// ConfigProfileUpdateConfigProfile invokes ConfigProfile_updateConfigProfile operation.
	//
	// Update Core Config in specific config profile.
	//
	// PATCH /api/config-profiles
	ConfigProfileUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequest, options ...RequestOption) (ConfigProfileUpdateConfigProfileRes, error)
	// ExternalSquadAddUsersToExternalSquad invokes ExternalSquad_addUsersToExternalSquad operation.
	//
	// Add all users to external squad.
	//
	// POST /api/external-squads/{uuid}/bulk-actions/add-users
	ExternalSquadAddUsersToExternalSquad(ctx context.Context, params ExternalSquadAddUsersToExternalSquadParams, options ...RequestOption) (ExternalSquadAddUsersToExternalSquadRes, error)
	// ExternalSquadCreateExternalSquad invokes ExternalSquad_createExternalSquad operation.
	//
	// Create external squad.
	//
	// POST /api/external-squads
	ExternalSquadCreateExternalSquad(ctx context.Context, request *CreateExternalSquadRequest, options ...RequestOption) (ExternalSquadCreateExternalSquadRes, error)
	// ExternalSquadDeleteExternalSquad invokes ExternalSquad_deleteExternalSquad operation.
	//
	// Delete external squad.
	//
	// DELETE /api/external-squads/{uuid}
	ExternalSquadDeleteExternalSquad(ctx context.Context, params ExternalSquadDeleteExternalSquadParams, options ...RequestOption) (ExternalSquadDeleteExternalSquadRes, error)
	// ExternalSquadGetExternalSquadByUuid invokes ExternalSquad_getExternalSquadByUuid operation.
	//
	// Get external squad by uuid.
	//
	// GET /api/external-squads/{uuid}
	ExternalSquadGetExternalSquadByUuid(ctx context.Context, params ExternalSquadGetExternalSquadByUuidParams, options ...RequestOption) (ExternalSquadGetExternalSquadByUuidRes, error)
	// ExternalSquadGetExternalSquads invokes ExternalSquad_getExternalSquads operation.
	//
	// Get all external squads.
	//
	// GET /api/external-squads
	ExternalSquadGetExternalSquads(ctx context.Context, options ...RequestOption) (ExternalSquadGetExternalSquadsRes, error)
	// ExternalSquadRemoveUsersFromExternalSquad invokes ExternalSquad_removeUsersFromExternalSquad operation.
	//
	// Delete users from external squad.
	//
	// DELETE /api/external-squads/{uuid}/bulk-actions/remove-users
	ExternalSquadRemoveUsersFromExternalSquad(ctx context.Context, params ExternalSquadRemoveUsersFromExternalSquadParams, options ...RequestOption) (ExternalSquadRemoveUsersFromExternalSquadRes, error)
	// ExternalSquadReorderExternalSquads invokes ExternalSquad_reorderExternalSquads operation.
	//
	// Reorder external squads.
	//
	// POST /api/external-squads/actions/reorder
	ExternalSquadReorderExternalSquads(ctx context.Context, request *ReorderRequest, options ...RequestOption) (ExternalSquadReorderExternalSquadsRes, error)
	// ExternalSquadUpdateExternalSquad invokes ExternalSquad_updateExternalSquad operation.
	//
	// Update external squad.
	//
	// PATCH /api/external-squads
	ExternalSquadUpdateExternalSquad(ctx context.Context, request *UpdateExternalSquadRequest, options ...RequestOption) (ExternalSquadUpdateExternalSquadRes, error)
	// HostsBulkActionsDeleteHosts invokes HostsBulkActions_deleteHosts operation.
	//
	// Delete hosts by UUIDs.
	//
	// POST /api/hosts/bulk/delete
	HostsBulkActionsDeleteHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsDeleteHostsRes, error)
	// HostsBulkActionsDisableHosts invokes HostsBulkActions_disableHosts operation.
	//
	// Disable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/disable
	HostsBulkActionsDisableHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsDisableHostsRes, error)
	// HostsBulkActionsEnableHosts invokes HostsBulkActions_enableHosts operation.
	//
	// Enable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/enable
	HostsBulkActionsEnableHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsEnableHostsRes, error)
	// HostsBulkActionsSetInboundToHosts invokes HostsBulkActions_setInboundToHosts operation.
	//
	// Set inbound to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-inbound
	HostsBulkActionsSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequest, options ...RequestOption) (HostsBulkActionsSetInboundToHostsRes, error)
	// HostsBulkActionsSetPortToHosts invokes HostsBulkActions_setPortToHosts operation.
	//
	// Set port to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-port
	HostsBulkActionsSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequest, options ...RequestOption) (HostsBulkActionsSetPortToHostsRes, error)
	// HostsCreateHost invokes Hosts_createHost operation.
	//
	// Create a new host.
	//
	// POST /api/hosts
	HostsCreateHost(ctx context.Context, request *CreateHostRequest, options ...RequestOption) (HostsCreateHostRes, error)
	// HostsDeleteHost invokes Hosts_deleteHost operation.
	//
	// Delete a host by UUID.
	//
	// DELETE /api/hosts/{uuid}
	HostsDeleteHost(ctx context.Context, params HostsDeleteHostParams, options ...RequestOption) (HostsDeleteHostRes, error)
	// HostsGetAllHostTags invokes Hosts_getAllHostTags operation.
	//
	// Get all existing host tags.
	//
	// GET /api/hosts/tags
	HostsGetAllHostTags(ctx context.Context, options ...RequestOption) (HostsGetAllHostTagsRes, error)
	// HostsGetAllHosts invokes Hosts_getAllHosts operation.
	//
	// Get all hosts.
	//
	// GET /api/hosts
	HostsGetAllHosts(ctx context.Context, options ...RequestOption) (HostsGetAllHostsRes, error)
	// HostsGetOneHost invokes Hosts_getOneHost operation.
	//
	// Get a host by UUID.
	//
	// GET /api/hosts/{uuid}
	HostsGetOneHost(ctx context.Context, params HostsGetOneHostParams, options ...RequestOption) (HostsGetOneHostRes, error)
	// HostsReorderHosts invokes Hosts_reorderHosts operation.
	//
	// Reorder hosts.
	//
	// POST /api/hosts/actions/reorder
	HostsReorderHosts(ctx context.Context, request *ReorderHostRequest, options ...RequestOption) (HostsReorderHostsRes, error)
	// HostsUpdateHost invokes Hosts_updateHost operation.
	//
	// Update a host.
	//
	// PATCH /api/hosts
	HostsUpdateHost(ctx context.Context, request *UpdateHostRequest, options ...RequestOption) (HostsUpdateHostRes, error)
	// HwidUserDevicesCreateUserHwidDevice invokes HwidUserDevices_createUserHwidDevice operation.
	//
	// Create a user HWID device.
	//
	// POST /api/hwid/devices
	HwidUserDevicesCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequest, options ...RequestOption) (HwidUserDevicesCreateUserHwidDeviceRes, error)
	// HwidUserDevicesDeleteAllUserHwidDevices invokes HwidUserDevices_deleteAllUserHwidDevices operation.
	//
	// Delete all user HWID devices.
	//
	// POST /api/hwid/devices/delete-all
	HwidUserDevicesDeleteAllUserHwidDevices(ctx context.Context, request *DeleteAllUserHwidDevicesRequest, options ...RequestOption) (HwidUserDevicesDeleteAllUserHwidDevicesRes, error)
	// HwidUserDevicesDeleteUserHwidDevice invokes HwidUserDevices_deleteUserHwidDevice operation.
	//
	// Delete a user HWID device.
	//
	// POST /api/hwid/devices/delete
	HwidUserDevicesDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequest, options ...RequestOption) (HwidUserDevicesDeleteUserHwidDeviceRes, error)
	// HwidUserDevicesGetAllUsers invokes HwidUserDevices_getAllUsers operation.
	//
	// Get all HWID devices.
	//
	// GET /api/hwid/devices
	HwidUserDevicesGetAllUsers(ctx context.Context, params HwidUserDevicesGetAllUsersParams, options ...RequestOption) (HwidUserDevicesGetAllUsersRes, error)
	// HwidUserDevicesGetHwidDevicesStats invokes HwidUserDevices_getHwidDevicesStats operation.
	//
	// Get HWID devices stats.
	//
	// GET /api/hwid/devices/stats
	HwidUserDevicesGetHwidDevicesStats(ctx context.Context, options ...RequestOption) (HwidUserDevicesGetHwidDevicesStatsRes, error)
	// HwidUserDevicesGetTopUsersByHwidDevices invokes HwidUserDevices_getTopUsersByHwidDevices operation.
	//
	// Get top users by HWID devices.
	//
	// GET /api/hwid/devices/top-users
	HwidUserDevicesGetTopUsersByHwidDevices(ctx context.Context, params HwidUserDevicesGetTopUsersByHwidDevicesParams, options ...RequestOption) (HwidUserDevicesGetTopUsersByHwidDevicesRes, error)
	// HwidUserDevicesGetUserHwidDevices invokes HwidUserDevices_getUserHwidDevices operation.
	//
	// Get user HWID devices.
	//
	// GET /api/hwid/devices/{userUuid}
	HwidUserDevicesGetUserHwidDevices(ctx context.Context, params HwidUserDevicesGetUserHwidDevicesParams, options ...RequestOption) (HwidUserDevicesGetUserHwidDevicesRes, error)
	// InfraBillingCreateInfraBillingHistoryRecord invokes InfraBilling_createInfraBillingHistoryRecord operation.
	//
	// Create infra billing history.
	//
	// POST /api/infra-billing/history
	InfraBillingCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequest, options ...RequestOption) (InfraBillingCreateInfraBillingHistoryRecordRes, error)
	// InfraBillingCreateInfraBillingNode invokes InfraBilling_createInfraBillingNode operation.
	//
	// Create infra billing node.
	//
	// POST /api/infra-billing/nodes
	InfraBillingCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequest, options ...RequestOption) (InfraBillingCreateInfraBillingNodeRes, error)
	// InfraBillingCreateInfraProvider invokes InfraBilling_createInfraProvider operation.
	//
	// Create infra provider.
	//
	// POST /api/infra-billing/providers
	InfraBillingCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequest, options ...RequestOption) (InfraBillingCreateInfraProviderRes, error)
	// InfraBillingDeleteInfraBillingHistoryRecordByUuid invokes InfraBilling_deleteInfraBillingHistoryRecordByUuid operation.
	//
	// Delete infra billing history.
	//
	// DELETE /api/infra-billing/history/{uuid}
	InfraBillingDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingHistoryRecordByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraBillingHistoryRecordByUuidRes, error)
	// InfraBillingDeleteInfraBillingNodeByUuid invokes InfraBilling_deleteInfraBillingNodeByUuid operation.
	//
	// Delete infra billing node.
	//
	// DELETE /api/infra-billing/nodes/{uuid}
	InfraBillingDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingNodeByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraBillingNodeByUuidRes, error)
	// InfraBillingDeleteInfraProviderByUuid invokes InfraBilling_deleteInfraProviderByUuid operation.
	//
	// Delete infra provider by uuid.
	//
	// DELETE /api/infra-billing/providers/{uuid}
	InfraBillingDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingDeleteInfraProviderByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraProviderByUuidRes, error)
	// InfraBillingGetBillingNodes invokes InfraBilling_getBillingNodes operation.
	//
	// Get infra billing nodes.
	//
	// GET /api/infra-billing/nodes
	InfraBillingGetBillingNodes(ctx context.Context, options ...RequestOption) (InfraBillingGetBillingNodesRes, error)
	// InfraBillingGetInfraBillingHistoryRecords invokes InfraBilling_getInfraBillingHistoryRecords operation.
	//
	// Get infra billing history.
	//
	// GET /api/infra-billing/history
	InfraBillingGetInfraBillingHistoryRecords(ctx context.Context, options ...RequestOption) (InfraBillingGetInfraBillingHistoryRecordsRes, error)
	// InfraBillingGetInfraProviderByUuid invokes InfraBilling_getInfraProviderByUuid operation.
	//
	// Get infra provider by uuid.
	//
	// GET /api/infra-billing/providers/{uuid}
	InfraBillingGetInfraProviderByUuid(ctx context.Context, params InfraBillingGetInfraProviderByUuidParams, options ...RequestOption) (InfraBillingGetInfraProviderByUuidRes, error)
	// InfraBillingGetInfraProviders invokes InfraBilling_getInfraProviders operation.
	//
	// Get all infra providers.
	//
	// GET /api/infra-billing/providers
	InfraBillingGetInfraProviders(ctx context.Context, options ...RequestOption) (InfraBillingGetInfraProvidersRes, error)
	// InfraBillingUpdateInfraBillingNode invokes InfraBilling_updateInfraBillingNode operation.
	//
	// Update infra billing nodes.
	//
	// PATCH /api/infra-billing/nodes
	InfraBillingUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequest, options ...RequestOption) (InfraBillingUpdateInfraBillingNodeRes, error)
	// InfraBillingUpdateInfraProvider invokes InfraBilling_updateInfraProvider operation.
	//
	// Update infra provider.
	//
	// PATCH /api/infra-billing/providers
	InfraBillingUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequest, options ...RequestOption) (InfraBillingUpdateInfraProviderRes, error)
	// InternalSquadAddUsersToInternalSquad invokes InternalSquad_addUsersToInternalSquad operation.
	//
	// Add all users to internal squad.
	//
	// POST /api/internal-squads/{uuid}/bulk-actions/add-users
	InternalSquadAddUsersToInternalSquad(ctx context.Context, params InternalSquadAddUsersToInternalSquadParams, options ...RequestOption) (InternalSquadAddUsersToInternalSquadRes, error)
	// InternalSquadCreateInternalSquad invokes InternalSquad_createInternalSquad operation.
	//
	// Create internal squad.
	//
	// POST /api/internal-squads
	InternalSquadCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequest, options ...RequestOption) (InternalSquadCreateInternalSquadRes, error)
	// InternalSquadDeleteInternalSquad invokes InternalSquad_deleteInternalSquad operation.
	//
	// Delete internal squad.
	//
	// DELETE /api/internal-squads/{uuid}
	InternalSquadDeleteInternalSquad(ctx context.Context, params InternalSquadDeleteInternalSquadParams, options ...RequestOption) (InternalSquadDeleteInternalSquadRes, error)
	// InternalSquadGetInternalSquadAccessibleNodes invokes InternalSquad_getInternalSquadAccessibleNodes operation.
	//
	// Get internal squad accessible nodes.
	//
	// GET /api/internal-squads/{uuid}/accessible-nodes
	InternalSquadGetInternalSquadAccessibleNodes(ctx context.Context, params InternalSquadGetInternalSquadAccessibleNodesParams, options ...RequestOption) (InternalSquadGetInternalSquadAccessibleNodesRes, error)
	// InternalSquadGetInternalSquadByUuid invokes InternalSquad_getInternalSquadByUuid operation.
	//
	// Get internal squad by uuid.
	//
	// GET /api/internal-squads/{uuid}
	InternalSquadGetInternalSquadByUuid(ctx context.Context, params InternalSquadGetInternalSquadByUuidParams, options ...RequestOption) (InternalSquadGetInternalSquadByUuidRes, error)
	// InternalSquadGetInternalSquads invokes InternalSquad_getInternalSquads operation.
	//
	// Get all internal squads.
	//
	// GET /api/internal-squads
	InternalSquadGetInternalSquads(ctx context.Context, options ...RequestOption) (InternalSquadGetInternalSquadsRes, error)
	// InternalSquadRemoveUsersFromInternalSquad invokes InternalSquad_removeUsersFromInternalSquad operation.
	//
	// Delete users from internal squad.
	//
	// DELETE /api/internal-squads/{uuid}/bulk-actions/remove-users
	InternalSquadRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadRemoveUsersFromInternalSquadParams, options ...RequestOption) (InternalSquadRemoveUsersFromInternalSquadRes, error)
	// InternalSquadReorderInternalSquads invokes InternalSquad_reorderInternalSquads operation.
	//
	// Reorder internal squads.
	//
	// POST /api/internal-squads/actions/reorder
	InternalSquadReorderInternalSquads(ctx context.Context, request *ReorderRequest, options ...RequestOption) (InternalSquadReorderInternalSquadsRes, error)
	// InternalSquadUpdateInternalSquad invokes InternalSquad_updateInternalSquad operation.
	//
	// Update internal squad.
	//
	// PATCH /api/internal-squads
	InternalSquadUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequest, options ...RequestOption) (InternalSquadUpdateInternalSquadRes, error)
	// KeygenGenerateKey invokes Keygen_generateKey operation.
	//
	// Get SSL_CERT for Remnawave Node.
	//
	// GET /api/keygen
	KeygenGenerateKey(ctx context.Context, options ...RequestOption) (KeygenGenerateKeyRes, error)
	// NodesBulkNodesActions invokes Nodes_bulkNodesActions operation.
	//
	// Perform actions for many nodes.
	//
	// POST /api/nodes/bulk-actions
	NodesBulkNodesActions(ctx context.Context, request *BulkNodesActionsRequest, options ...RequestOption) (NodesBulkNodesActionsRes, error)
	// NodesCreateNode invokes Nodes_createNode operation.
	//
	// Create a new node.
	//
	// POST /api/nodes
	NodesCreateNode(ctx context.Context, request *CreateNodeRequest, options ...RequestOption) (NodesCreateNodeRes, error)
	// NodesDeleteNode invokes Nodes_deleteNode operation.
	//
	// Delete a node.
	//
	// DELETE /api/nodes/{uuid}
	NodesDeleteNode(ctx context.Context, params NodesDeleteNodeParams, options ...RequestOption) (NodesDeleteNodeRes, error)
	// NodesDisableNode invokes Nodes_disableNode operation.
	//
	// Disable a node.
	//
	// POST /api/nodes/{uuid}/actions/disable
	NodesDisableNode(ctx context.Context, params NodesDisableNodeParams, options ...RequestOption) (NodesDisableNodeRes, error)
	// NodesEnableNode invokes Nodes_enableNode operation.
	//
	// Enable a node.
	//
	// POST /api/nodes/{uuid}/actions/enable
	NodesEnableNode(ctx context.Context, params NodesEnableNodeParams, options ...RequestOption) (NodesEnableNodeRes, error)
	// NodesGetAllNodes invokes Nodes_getAllNodes operation.
	//
	// Get all nodes.
	//
	// GET /api/nodes
	NodesGetAllNodes(ctx context.Context, options ...RequestOption) (NodesGetAllNodesRes, error)
	// NodesGetAllNodesTags invokes Nodes_getAllNodesTags operation.
	//
	// Get all existing nodes tags.
	//
	// GET /api/nodes/tags
	NodesGetAllNodesTags(ctx context.Context, options ...RequestOption) (NodesGetAllNodesTagsRes, error)
	// NodesGetOneNode invokes Nodes_getOneNode operation.
	//
	// Get node by UUID.
	//
	// GET /api/nodes/{uuid}
	NodesGetOneNode(ctx context.Context, params NodesGetOneNodeParams, options ...RequestOption) (NodesGetOneNodeRes, error)
	// NodesProfileModification invokes Nodes_profileModification operation.
	//
	// Modify Inbounds & Profile for many nodes.
	//
	// POST /api/nodes/bulk-actions/profile-modification
	NodesProfileModification(ctx context.Context, request *ProfileModificationRequest, options ...RequestOption) (NodesProfileModificationRes, error)
	// NodesReorderNodes invokes Nodes_reorderNodes operation.
	//
	// Reorder nodes.
	//
	// POST /api/nodes/actions/reorder
	NodesReorderNodes(ctx context.Context, request *ReorderNodeRequest, options ...RequestOption) (NodesReorderNodesRes, error)
	// NodesResetNodeTraffic invokes Nodes_resetNodeTraffic operation.
	//
	// Reset Node Traffic.
	//
	// POST /api/nodes/{uuid}/actions/reset-traffic
	NodesResetNodeTraffic(ctx context.Context, params NodesResetNodeTrafficParams, options ...RequestOption) (NodesResetNodeTrafficRes, error)
	// NodesRestartAllNodes invokes Nodes_restartAllNodes operation.
	//
	// Restart all nodes.
	//
	// POST /api/nodes/actions/restart-all
	NodesRestartAllNodes(ctx context.Context, request *RestartAllNodesRequestBody, options ...RequestOption) (NodesRestartAllNodesRes, error)
	// NodesRestartNode invokes Nodes_restartNode operation.
	//
	// Restart node.
	//
	// POST /api/nodes/{uuid}/actions/restart
	NodesRestartNode(ctx context.Context, params NodesRestartNodeParams, options ...RequestOption) (NodesRestartNodeRes, error)
	// NodesUpdateNode invokes Nodes_updateNode operation.
	//
	// Update node.
	//
	// PATCH /api/nodes
	NodesUpdateNode(ctx context.Context, request *UpdateNodeRequest, options ...RequestOption) (NodesUpdateNodeRes, error)
	// NodesUsageHistoryGetStatsNodesUsage invokes NodesUsageHistory_getStatsNodesUsage operation.
	//
	// Get Nodes Usage by Range.
	//
	// GET /api/bandwidth-stats/nodes
	NodesUsageHistoryGetStatsNodesUsage(ctx context.Context, params NodesUsageHistoryGetStatsNodesUsageParams, options ...RequestOption) (NodesUsageHistoryGetStatsNodesUsageRes, error)
	// PasskeyDeletePasskey invokes Passkey_deletePasskey operation.
	//
	// Delete a passkey by ID.
	//
	// DELETE /api/passkeys
	PasskeyDeletePasskey(ctx context.Context, request *DeletePasskeyRequest, options ...RequestOption) (PasskeyDeletePasskeyRes, error)
	// PasskeyGetActivePasskeys invokes Passkey_getActivePasskeys operation.
	//
	// Get all passkeys.
	//
	// GET /api/passkeys
	PasskeyGetActivePasskeys(ctx context.Context, options ...RequestOption) (PasskeyGetActivePasskeysRes, error)
	// PasskeyPasskeyRegistrationOptions invokes Passkey_passkeyRegistrationOptions operation.
	//
	// Get registration options for passkey.
	//
	// GET /api/passkeys/registration/options
	PasskeyPasskeyRegistrationOptions(ctx context.Context, options ...RequestOption) (PasskeyPasskeyRegistrationOptionsRes, error)
	// PasskeyPasskeyRegistrationVerify invokes Passkey_passkeyRegistrationVerify operation.
	//
	// Verify registration for passkey.
	//
	// POST /api/passkeys/registration/verify
	PasskeyPasskeyRegistrationVerify(ctx context.Context, request *PasskeyOptions, options ...RequestOption) (PasskeyPasskeyRegistrationVerifyRes, error)
	// PasskeyUpdatePasskey invokes Passkey_updatePasskey operation.
	//
	// Update passkey.
	//
	// PATCH /api/passkeys
	PasskeyUpdatePasskey(ctx context.Context, request *UpdatePasskeyRequest, options ...RequestOption) (PasskeyUpdatePasskeyRes, error)
	// RemnawaveSettingsGetSettings invokes RemnawaveSettings_getSettings operation.
	//
	// Get Remnawave settings.
	//
	// GET /api/remnawave-settings
	RemnawaveSettingsGetSettings(ctx context.Context, options ...RequestOption) (RemnawaveSettingsGetSettingsRes, error)
	// RemnawaveSettingsUpdateSettings invokes RemnawaveSettings_updateSettings operation.
	//
	// Update Remnawave settings.
	//
	// PATCH /api/remnawave-settings
	RemnawaveSettingsUpdateSettings(ctx context.Context, request *UpdateRemnawaveSettingsRequest, options ...RequestOption) (RemnawaveSettingsUpdateSettingsRes, error)
	// SnippetsCreateSnippet invokes Snippets_createSnippet operation.
	//
	// Create snippet.
	//
	// POST /api/snippets
	SnippetsCreateSnippet(ctx context.Context, request *SnippetRequest, options ...RequestOption) (SnippetsCreateSnippetRes, error)
	// SnippetsDeleteSnippetByName invokes Snippets_deleteSnippetByName operation.
	//
	// Delete snippet.
	//
	// DELETE /api/snippets
	SnippetsDeleteSnippetByName(ctx context.Context, request *DeleteSnippetRequest, options ...RequestOption) (SnippetsDeleteSnippetByNameRes, error)
	// SnippetsGetSnippets invokes Snippets_getSnippets operation.
	//
	// Get snippets.
	//
	// GET /api/snippets
	SnippetsGetSnippets(ctx context.Context, options ...RequestOption) (SnippetsGetSnippetsRes, error)
	// SnippetsUpdateSnippet invokes Snippets_updateSnippet operation.
	//
	// Update snippet.
	//
	// PATCH /api/snippets
	SnippetsUpdateSnippet(ctx context.Context, request *SnippetRequest, options ...RequestOption) (SnippetsUpdateSnippetRes, error)
	// SubscriptionGetSubscription invokes Subscription_getSubscription operation.
	//
	// GET /api/sub/{shortUuid}
	SubscriptionGetSubscription(ctx context.Context, params SubscriptionGetSubscriptionParams, options ...RequestOption) (SubscriptionGetSubscriptionOK, error)
	// SubscriptionGetSubscriptionByClientType invokes Subscription_getSubscriptionByClientType operation.
	//
	// GET /api/sub/{shortUuid}/{clientType}
	SubscriptionGetSubscriptionByClientType(ctx context.Context, params SubscriptionGetSubscriptionByClientTypeParams, options ...RequestOption) (SubscriptionGetSubscriptionByClientTypeOK, error)
	// SubscriptionGetSubscriptionInfoByShortUuid invokes Subscription_getSubscriptionInfoByShortUuid operation.
	//
	// Get Subscription Info by Short UUID.
	//
	// GET /api/sub/{shortUuid}/info
	SubscriptionGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (SubscriptionGetSubscriptionInfoByShortUuidRes, error)
	// SubscriptionGetSubscriptionWithType invokes Subscription_getSubscriptionWithType operation.
	//
	// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
	SubscriptionGetSubscriptionWithType(ctx context.Context, params SubscriptionGetSubscriptionWithTypeParams, options ...RequestOption) (SubscriptionGetSubscriptionWithTypeOK, error)
	// SubscriptionPageConfigCloneSubscriptionPageConfig invokes SubscriptionPageConfig_cloneSubscriptionPageConfig operation.
	//
	// Clone subscription page config.
	//
	// POST /api/subscription-page-configs/actions/clone
	SubscriptionPageConfigCloneSubscriptionPageConfig(ctx context.Context, request *CloneSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigCloneSubscriptionPageConfigRes, error)
	// SubscriptionPageConfigCreateConfig invokes SubscriptionPageConfig_createConfig operation.
	//
	// Create subscription page config.
	//
	// POST /api/subscription-page-configs
	SubscriptionPageConfigCreateConfig(ctx context.Context, request *CreateSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigCreateConfigRes, error)
	// SubscriptionPageConfigDeleteConfig invokes SubscriptionPageConfig_deleteConfig operation.
	//
	// Delete subscription page config.
	//
	// DELETE /api/subscription-page-configs/{uuid}
	SubscriptionPageConfigDeleteConfig(ctx context.Context, params SubscriptionPageConfigDeleteConfigParams, options ...RequestOption) (SubscriptionPageConfigDeleteConfigRes, error)
	// SubscriptionPageConfigGetAllConfigs invokes SubscriptionPageConfig_getAllConfigs operation.
	//
	// Get all subscription page configs.
	//
	// GET /api/subscription-page-configs
	SubscriptionPageConfigGetAllConfigs(ctx context.Context, options ...RequestOption) (SubscriptionPageConfigGetAllConfigsRes, error)
	// SubscriptionPageConfigGetConfigByUuid invokes SubscriptionPageConfig_getConfigByUuid operation.
	//
	// Get subscription page config by uuid.
	//
	// GET /api/subscription-page-configs/{uuid}
	SubscriptionPageConfigGetConfigByUuid(ctx context.Context, params SubscriptionPageConfigGetConfigByUuidParams, options ...RequestOption) (SubscriptionPageConfigGetConfigByUuidRes, error)
	// SubscriptionPageConfigReorderSubscriptionPageConfigs invokes SubscriptionPageConfig_reorderSubscriptionPageConfigs operation.
	//
	// Reorder subscription page configs.
	//
	// POST /api/subscription-page-configs/actions/reorder
	SubscriptionPageConfigReorderSubscriptionPageConfigs(ctx context.Context, request *ReorderRequest, options ...RequestOption) (SubscriptionPageConfigReorderSubscriptionPageConfigsRes, error)
	// SubscriptionPageConfigUpdateConfig invokes SubscriptionPageConfig_updateConfig operation.
	//
	// Update subscription page config.
	//
	// PATCH /api/subscription-page-configs
	SubscriptionPageConfigUpdateConfig(ctx context.Context, request *UpdateSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigUpdateConfigRes, error)
	// SubscriptionSettingsGetSettings invokes SubscriptionSettings_getSettings operation.
	//
	// Get subscription settings.
	//
	// GET /api/subscription-settings
	SubscriptionSettingsGetSettings(ctx context.Context, options ...RequestOption) (SubscriptionSettingsGetSettingsRes, error)
	// SubscriptionSettingsUpdateSettings invokes SubscriptionSettings_updateSettings operation.
	//
	// Update subscription settings.
	//
	// PATCH /api/subscription-settings
	SubscriptionSettingsUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequest, options ...RequestOption) (SubscriptionSettingsUpdateSettingsRes, error)
	// SubscriptionTemplateCreateTemplate invokes SubscriptionTemplate_createTemplate operation.
	//
	// Create subscription template.
	//
	// POST /api/subscription-templates
	SubscriptionTemplateCreateTemplate(ctx context.Context, request *CreateSubscriptionTemplateRequest, options ...RequestOption) (SubscriptionTemplateCreateTemplateRes, error)
	// SubscriptionTemplateDeleteTemplate invokes SubscriptionTemplate_deleteTemplate operation.
	//
	// Delete subscription template.
	//
	// DELETE /api/subscription-templates/{uuid}
	SubscriptionTemplateDeleteTemplate(ctx context.Context, params SubscriptionTemplateDeleteTemplateParams, options ...RequestOption) (SubscriptionTemplateDeleteTemplateRes, error)
	// SubscriptionTemplateGetAllTemplates invokes SubscriptionTemplate_getAllTemplates operation.
	//
	// Get all subscription templates (wihout content).
	//
	// GET /api/subscription-templates
	SubscriptionTemplateGetAllTemplates(ctx context.Context, options ...RequestOption) (SubscriptionTemplateGetAllTemplatesRes, error)
	// SubscriptionTemplateGetTemplateByUuid invokes SubscriptionTemplate_getTemplateByUuid operation.
	//
	// Get subscription template by uuid.
	//
	// GET /api/subscription-templates/{uuid}
	SubscriptionTemplateGetTemplateByUuid(ctx context.Context, params SubscriptionTemplateGetTemplateByUuidParams, options ...RequestOption) (SubscriptionTemplateGetTemplateByUuidRes, error)
	// SubscriptionTemplateReorderSubscriptionTemplates invokes SubscriptionTemplate_reorderSubscriptionTemplates operation.
	//
	// Reorder subscription templates.
	//
	// POST /api/subscription-templates/actions/reorder
	SubscriptionTemplateReorderSubscriptionTemplates(ctx context.Context, request *ReorderRequest, options ...RequestOption) (SubscriptionTemplateReorderSubscriptionTemplatesRes, error)
	// SubscriptionTemplateUpdateTemplate invokes SubscriptionTemplate_updateTemplate operation.
	//
	// Update subscription template.
	//
	// PATCH /api/subscription-templates
	SubscriptionTemplateUpdateTemplate(ctx context.Context, request *UpdateTemplateRequest, options ...RequestOption) (SubscriptionTemplateUpdateTemplateRes, error)
	// SubscriptionsGetAllSubscriptions invokes Subscriptions_getAllSubscriptions operation.
	//
	// Get all subscriptions.
	//
	// GET /api/subscriptions
	SubscriptionsGetAllSubscriptions(ctx context.Context, params SubscriptionsGetAllSubscriptionsParams, options ...RequestOption) (SubscriptionsGetAllSubscriptionsRes, error)
	// SubscriptionsGetRawSubscriptionByShortUuid invokes Subscriptions_getRawSubscriptionByShortUuid operation.
	//
	// Get Raw Subscription by Short UUID.
	//
	// GET /api/subscriptions/by-short-uuid/{shortUuid}/raw
	SubscriptionsGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionsGetRawSubscriptionByShortUuidParams, options ...RequestOption) (SubscriptionsGetRawSubscriptionByShortUuidRes, error)
	// SubscriptionsGetSubpageConfigByShortUuid invokes Subscriptions_getSubpageConfigByShortUuid operation.
	//
	// Get Subpage Config by Short UUID.
	//
	// GET /api/subscriptions/subpage-config/{shortUuid}
	SubscriptionsGetSubpageConfigByShortUuid(ctx context.Context, request *GetSubpageConfigByShortUuidRequestBody, params SubscriptionsGetSubpageConfigByShortUuidParams, options ...RequestOption) (SubscriptionsGetSubpageConfigByShortUuidRes, error)
	// SubscriptionsGetSubscriptionByShortUuidProtected invokes Subscriptions_getSubscriptionByShortUuidProtected operation.
	//
	// Get subscription by short uuid (protected route).
	//
	// GET /api/subscriptions/by-short-uuid/{shortUuid}
	SubscriptionsGetSubscriptionByShortUuidProtected(ctx context.Context, params SubscriptionsGetSubscriptionByShortUuidProtectedParams, options ...RequestOption) (SubscriptionsGetSubscriptionByShortUuidProtectedRes, error)
	// SubscriptionsGetSubscriptionByUsername invokes Subscriptions_getSubscriptionByUsername operation.
	//
	// Get subscription by username.
	//
	// GET /api/subscriptions/by-username/{username}
	SubscriptionsGetSubscriptionByUsername(ctx context.Context, params SubscriptionsGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsGetSubscriptionByUsernameRes, error)
	// SubscriptionsGetSubscriptionByUuid invokes Subscriptions_getSubscriptionByUuid operation.
	//
	// Get subscription by uuid.
	//
	// GET /api/subscriptions/by-uuid/{uuid}
	SubscriptionsGetSubscriptionByUuid(ctx context.Context, params SubscriptionsGetSubscriptionByUuidParams, options ...RequestOption) (SubscriptionsGetSubscriptionByUuidRes, error)
	// SystemDebugSrrMatcher invokes System_debugSrrMatcher operation.
	//
	// Test SRR Matcher.
	//
	// POST /api/system/testers/srr-matcher
	SystemDebugSrrMatcher(ctx context.Context, request *DebugSrrMatcherRequest, options ...RequestOption) (SystemDebugSrrMatcherRes, error)
	// SystemEncryptHappCryptoLink invokes System_encryptHappCryptoLink operation.
	//
	// Encrypt Happ Crypto Link.
	//
	// POST /api/system/tools/happ/encrypt
	SystemEncryptHappCryptoLink(ctx context.Context, request *EncryptHappCryptoLinkRequest, options ...RequestOption) (SystemEncryptHappCryptoLinkRes, error)
	// SystemGetBandwidthStats invokes System_getBandwidthStats operation.
	//
	// Get Bandwidth Stats.
	//
	// GET /api/system/stats/bandwidth
	SystemGetBandwidthStats(ctx context.Context, options ...RequestOption) (SystemGetBandwidthStatsRes, error)
	// SystemGetMetadata invokes System_getMetadata operation.
	//
	// Get Remnawave Information.
	//
	// GET /api/system/metadata
	SystemGetMetadata(ctx context.Context, options ...RequestOption) (SystemGetMetadataRes, error)
	// SystemGetNodesMetrics invokes System_getNodesMetrics operation.
	//
	// Get Nodes Metrics.
	//
	// GET /api/system/nodes/metrics
	SystemGetNodesMetrics(ctx context.Context, options ...RequestOption) (SystemGetNodesMetricsRes, error)
	// SystemGetNodesStatistics invokes System_getNodesStatistics operation.
	//
	// Get Nodes Statistics.
	//
	// GET /api/system/stats/nodes
	SystemGetNodesStatistics(ctx context.Context, options ...RequestOption) (SystemGetNodesStatisticsRes, error)
	// SystemGetRemnawaveHealth invokes System_getRemnawaveHealth operation.
	//
	// Get Remnawave Health.
	//
	// GET /api/system/health
	SystemGetRemnawaveHealth(ctx context.Context, options ...RequestOption) (SystemGetRemnawaveHealthRes, error)
	// SystemGetStats invokes System_getStats operation.
	//
	// Get Stats.
	//
	// GET /api/system/stats
	SystemGetStats(ctx context.Context, options ...RequestOption) (SystemGetStatsRes, error)
	// SystemGetX25519Keypairs invokes System_getX25519Keypairs operation.
	//
	// Generate 30 X25519 keypairs.
	//
	// GET /api/system/tools/x25519/generate
	SystemGetX25519Keypairs(ctx context.Context, options ...RequestOption) (SystemGetX25519KeypairsRes, error)
	// UserSubscriptionRequestHistoryGetSubscriptionRequestHistory invokes UserSubscriptionRequestHistory_getSubscriptionRequestHistory operation.
	//
	// Get all subscription request history.
	//
	// GET /api/subscription-request-history
	UserSubscriptionRequestHistoryGetSubscriptionRequestHistory(ctx context.Context, params UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryParams, options ...RequestOption) (UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryRes, error)
	// UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats invokes UserSubscriptionRequestHistory_getSubscriptionRequestHistoryStats operation.
	//
	// Get subscription request history stats.
	//
	// GET /api/subscription-request-history/stats
	UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats(ctx context.Context, options ...RequestOption) (UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsRes, error)
	// UsersBulkActionsBulkAllExtendExpirationDate invokes UsersBulkActions_bulkAllExtendExpirationDate operation.
	//
	// Bulk extend all users expiration date.
	//
	// POST /api/users/bulk/all/extend-expiration-date
	UsersBulkActionsBulkAllExtendExpirationDate(ctx context.Context, request *BulkAllExtendExpirationDateRequest, options ...RequestOption) (UsersBulkActionsBulkAllExtendExpirationDateRes, error)
	// UsersBulkActionsBulkAllResetUserTraffic invokes UsersBulkActions_bulkAllResetUserTraffic operation.
	//
	// Bulk reset all users traffic.
	//
	// POST /api/users/bulk/all/reset-traffic
	UsersBulkActionsBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (UsersBulkActionsBulkAllResetUserTrafficRes, error)
	// UsersBulkActionsBulkDeleteUsers invokes UsersBulkActions_bulkDeleteUsers operation.
	//
	// Bulk delete users by UUIDs.
	//
	// POST /api/users/bulk/delete
	UsersBulkActionsBulkDeleteUsers(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkDeleteUsersRes, error)
	// UsersBulkActionsBulkDeleteUsersByStatus invokes UsersBulkActions_bulkDeleteUsersByStatus operation.
	//
	// Bulk delete users by status.
	//
	// POST /api/users/bulk/delete-by-status
	UsersBulkActionsBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequest, options ...RequestOption) (UsersBulkActionsBulkDeleteUsersByStatusRes, error)
	// UsersBulkActionsBulkExtendExpirationDate invokes UsersBulkActions_bulkExtendExpirationDate operation.
	//
	// Bulk extend all users expiration date.
	//
	// POST /api/users/bulk/extend-expiration-date
	UsersBulkActionsBulkExtendExpirationDate(ctx context.Context, request *BulkExtendExpirationDateRequest, options ...RequestOption) (UsersBulkActionsBulkExtendExpirationDateRes, error)
	// UsersBulkActionsBulkResetUserTraffic invokes UsersBulkActions_bulkResetUserTraffic operation.
	//
	// Bulk reset traffic users by UUIDs.
	//
	// POST /api/users/bulk/reset-traffic
	UsersBulkActionsBulkResetUserTraffic(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkResetUserTrafficRes, error)
	// UsersBulkActionsBulkRevokeUsersSubscription invokes UsersBulkActions_bulkRevokeUsersSubscription operation.
	//
	// Revoke users subscription by User UUIDs.
	//
	// POST /api/users/bulk/revoke-subscription
	UsersBulkActionsBulkRevokeUsersSubscription(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkRevokeUsersSubscriptionRes, error)
	// UsersBulkActionsBulkUpdateAllUsers invokes UsersBulkActions_bulkUpdateAllUsers operation.
	//
	// Bulk update all users.
	//
	// POST /api/users/bulk/all/update
	UsersBulkActionsBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateAllUsersRes, error)
	// UsersBulkActionsBulkUpdateUsers invokes UsersBulkActions_bulkUpdateUsers operation.
	//
	// Bulk update users by UUIDs.
	//
	// POST /api/users/bulk/update
	UsersBulkActionsBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateUsersRes, error)
	// UsersBulkActionsBulkUpdateUsersInternalSquads invokes UsersBulkActions_bulkUpdateUsersInternalSquads operation.
	//
	// Bulk update users internal squads by UUIDs.
	//
	// POST /api/users/bulk/update-squads
	UsersBulkActionsBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateUsersInternalSquadsRes, error)
	// UsersCreateUser invokes Users_createUser operation.
	//
	// Create a new user.
	//
	// POST /api/users
	UsersCreateUser(ctx context.Context, request *CreateUserRequest, options ...RequestOption) (UsersCreateUserRes, error)
	// UsersDeleteUser invokes Users_deleteUser operation.
	//
	// Delete user.
	//
	// DELETE /api/users/{uuid}
	UsersDeleteUser(ctx context.Context, params UsersDeleteUserParams, options ...RequestOption) (UsersDeleteUserRes, error)
	// UsersDisableUser invokes Users_disableUser operation.
	//
	// Disable user.
	//
	// POST /api/users/{uuid}/actions/disable
	UsersDisableUser(ctx context.Context, params UsersDisableUserParams, options ...RequestOption) (UsersDisableUserRes, error)
	// UsersEnableUser invokes Users_enableUser operation.
	//
	// Enable user.
	//
	// POST /api/users/{uuid}/actions/enable
	UsersEnableUser(ctx context.Context, params UsersEnableUserParams, options ...RequestOption) (UsersEnableUserRes, error)
	// UsersGetAllTags invokes Users_getAllTags operation.
	//
	// Get all existing user tags.
	//
	// GET /api/users/tags
	UsersGetAllTags(ctx context.Context, options ...RequestOption) (UsersGetAllTagsRes, error)
	// UsersGetAllUsers invokes Users_getAllUsers operation.
	//
	// Get all users.
	//
	// GET /api/users
	UsersGetAllUsers(ctx context.Context, params UsersGetAllUsersParams, options ...RequestOption) (UsersGetAllUsersRes, error)
	// UsersGetUserAccessibleNodes invokes Users_getUserAccessibleNodes operation.
	//
	// Get user accessible nodes.
	//
	// GET /api/users/{uuid}/accessible-nodes
	UsersGetUserAccessibleNodes(ctx context.Context, params UsersGetUserAccessibleNodesParams, options ...RequestOption) (UsersGetUserAccessibleNodesRes, error)
	// UsersGetUserById invokes Users_getUserById operation.
	//
	// Get user by ID.
	//
	// GET /api/users/by-id/{id}
	UsersGetUserById(ctx context.Context, params UsersGetUserByIdParams, options ...RequestOption) (UsersGetUserByIdRes, error)
	// UsersGetUserByShortUuid invokes Users_getUserByShortUuid operation.
	//
	// Get user by Short UUID.
	//
	// GET /api/users/by-short-uuid/{shortUuid}
	UsersGetUserByShortUuid(ctx context.Context, params UsersGetUserByShortUuidParams, options ...RequestOption) (UsersGetUserByShortUuidRes, error)
	// UsersGetUserByTelegramId invokes Users_getUserByTelegramId operation.
	//
	// Get users by telegram ID.
	//
	// GET /api/users/by-telegram-id/{telegramId}
	UsersGetUserByTelegramId(ctx context.Context, params UsersGetUserByTelegramIdParams, options ...RequestOption) (UsersGetUserByTelegramIdRes, error)
	// UsersGetUserByUsername invokes Users_getUserByUsername operation.
	//
	// Get user by username.
	//
	// GET /api/users/by-username/{username}
	UsersGetUserByUsername(ctx context.Context, params UsersGetUserByUsernameParams, options ...RequestOption) (UsersGetUserByUsernameRes, error)
	// UsersGetUserByUuid invokes Users_getUserByUuid operation.
	//
	// Get user by UUID.
	//
	// GET /api/users/{uuid}
	UsersGetUserByUuid(ctx context.Context, params UsersGetUserByUuidParams, options ...RequestOption) (UsersGetUserByUuidRes, error)
	// UsersGetUserSubscriptionRequestHistory invokes Users_getUserSubscriptionRequestHistory operation.
	//
	// Get user subscription request history, recent 24 records.
	//
	// GET /api/users/{uuid}/subscription-request-history
	UsersGetUserSubscriptionRequestHistory(ctx context.Context, params UsersGetUserSubscriptionRequestHistoryParams, options ...RequestOption) (UsersGetUserSubscriptionRequestHistoryRes, error)
	// UsersGetUsersByEmail invokes Users_getUsersByEmail operation.
	//
	// Get users by email.
	//
	// GET /api/users/by-email/{email}
	UsersGetUsersByEmail(ctx context.Context, params UsersGetUsersByEmailParams, options ...RequestOption) (UsersGetUsersByEmailRes, error)
	// UsersGetUsersByTag invokes Users_getUsersByTag operation.
	//
	// Get users by tag.
	//
	// GET /api/users/by-tag/{tag}
	UsersGetUsersByTag(ctx context.Context, params UsersGetUsersByTagParams, options ...RequestOption) (UsersGetUsersByTagRes, error)
	// UsersResetUserTraffic invokes Users_resetUserTraffic operation.
	//
	// Reset user traffic.
	//
	// POST /api/users/{uuid}/actions/reset-traffic
	UsersResetUserTraffic(ctx context.Context, params UsersResetUserTrafficParams, options ...RequestOption) (UsersResetUserTrafficRes, error)
	// UsersRevokeUserSubscription invokes Users_revokeUserSubscription operation.
	//
	// Revoke user subscription.
	//
	// POST /api/users/{uuid}/actions/revoke
	UsersRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBody, params UsersRevokeUserSubscriptionParams, options ...RequestOption) (UsersRevokeUserSubscriptionRes, error)
	// UsersUpdateUser invokes Users_updateUser operation.
	//
	// Update a user by UUID or username.
	//
	// PATCH /api/users
	UsersUpdateUser(ctx context.Context, request *UpdateUserRequest, options ...RequestOption) (UsersUpdateUserRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}
func (c *Client) onRequest(ctx context.Context, req *http.Request) error {
	for _, fn := range c.cfg.RequestEditors {
		if err := fn(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

func (c *Client) onResponse(ctx context.Context, resp *http.Response) error {
	for _, fn := range c.cfg.ResponseEditors {
		if err := fn(ctx, resp); err != nil {
			return err
		}
	}
	return nil
}

// ApiTokensCreate invokes ApiTokens_create operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
//
// POST /api/tokens
func (c *Client) ApiTokensCreate(ctx context.Context, request *CreateApiTokenRequest, options ...RequestOption) (ApiTokensCreateRes, error) {
	res, err := c.sendApiTokensCreate(ctx, request, options...)
	return res, err
}

func (c *Client) sendApiTokensCreate(ctx context.Context, request *CreateApiTokenRequest, requestOptions ...RequestOption) (res ApiTokensCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ApiTokens_create"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/tokens"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ApiTokensCreateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeApiTokensCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ApiTokensCreateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeApiTokensCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensDelete invokes ApiTokens_delete operation.
//
// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
//
// DELETE /api/tokens/{uuid}
func (c *Client) ApiTokensDelete(ctx context.Context, params ApiTokensDeleteParams, options ...RequestOption) (ApiTokensDeleteRes, error) {
	res, err := c.sendApiTokensDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendApiTokensDelete(ctx context.Context, params ApiTokensDeleteParams, requestOptions ...RequestOption) (res ApiTokensDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ApiTokens_delete"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/tokens/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ApiTokensDeleteOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/tokens/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ApiTokensDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeApiTokensDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensFindAll invokes ApiTokens_findAll operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
//
// GET /api/tokens
func (c *Client) ApiTokensFindAll(ctx context.Context, options ...RequestOption) (ApiTokensFindAllRes, error) {
	res, err := c.sendApiTokensFindAll(ctx, options...)
	return res, err
}

func (c *Client) sendApiTokensFindAll(ctx context.Context, requestOptions ...RequestOption) (res ApiTokensFindAllRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ApiTokens_findAll"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/tokens"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ApiTokensFindAllOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ApiTokensFindAllOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeApiTokensFindAllResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthGetStatus invokes Auth_getStatus operation.
//
// Get the status of the authentication.
//
// GET /api/auth/status
func (c *Client) AuthGetStatus(ctx context.Context, options ...RequestOption) (AuthGetStatusRes, error) {
	res, err := c.sendAuthGetStatus(ctx, options...)
	return res, err
}

func (c *Client) sendAuthGetStatus(ctx context.Context, requestOptions ...RequestOption) (res AuthGetStatusRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_getStatus"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/auth/status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthGetStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthGetStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthLogin invokes Auth_login operation.
//
// Login as superadmin.
//
// POST /api/auth/login
func (c *Client) AuthLogin(ctx context.Context, request *LoginRequest, options ...RequestOption) (AuthLoginRes, error) {
	res, err := c.sendAuthLogin(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthLogin(ctx context.Context, request *LoginRequest, requestOptions ...RequestOption) (res AuthLoginRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_login"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/login"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthLoginOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/login"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthOauth2Authorize invokes Auth_oauth2Authorize operation.
//
// Initiate OAuth2 authorization.
//
// POST /api/auth/oauth2/authorize
func (c *Client) AuthOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequest, options ...RequestOption) (AuthOauth2AuthorizeRes, error) {
	res, err := c.sendAuthOauth2Authorize(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequest, requestOptions ...RequestOption) (res AuthOauth2AuthorizeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_oauth2Authorize"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/oauth2/authorize"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthOauth2AuthorizeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthOauth2AuthorizeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthOauth2AuthorizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthOauth2Callback invokes Auth_oauth2Callback operation.
//
// Callback from OAuth2.
//
// POST /api/auth/oauth2/callback
func (c *Client) AuthOauth2Callback(ctx context.Context, request *OAuth2CallbackRequest, options ...RequestOption) (AuthOauth2CallbackRes, error) {
	res, err := c.sendAuthOauth2Callback(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthOauth2Callback(ctx context.Context, request *OAuth2CallbackRequest, requestOptions ...RequestOption) (res AuthOauth2CallbackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_oauth2Callback"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/oauth2/callback"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthOauth2CallbackOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/callback"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthOauth2CallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthOauth2CallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthPasskeyAuthenticationOptions invokes Auth_passkeyAuthenticationOptions operation.
//
// Get the authentication options for passkey.
//
// GET /api/auth/passkey/authentication/options
func (c *Client) AuthPasskeyAuthenticationOptions(ctx context.Context, options ...RequestOption) (AuthPasskeyAuthenticationOptionsRes, error) {
	res, err := c.sendAuthPasskeyAuthenticationOptions(ctx, options...)
	return res, err
}

func (c *Client) sendAuthPasskeyAuthenticationOptions(ctx context.Context, requestOptions ...RequestOption) (res AuthPasskeyAuthenticationOptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_passkeyAuthenticationOptions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/auth/passkey/authentication/options"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthPasskeyAuthenticationOptionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/passkey/authentication/options"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthPasskeyAuthenticationOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthPasskeyAuthenticationVerify invokes Auth_passkeyAuthenticationVerify operation.
//
// Verify the authentication for passkey.
//
// POST /api/auth/passkey/authentication/verify
func (c *Client) AuthPasskeyAuthenticationVerify(ctx context.Context, request *PasskeyOptions, options ...RequestOption) (AuthPasskeyAuthenticationVerifyRes, error) {
	res, err := c.sendAuthPasskeyAuthenticationVerify(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthPasskeyAuthenticationVerify(ctx context.Context, request *PasskeyOptions, requestOptions ...RequestOption) (res AuthPasskeyAuthenticationVerifyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_passkeyAuthenticationVerify"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/passkey/authentication/verify"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthPasskeyAuthenticationVerifyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/passkey/authentication/verify"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthPasskeyAuthenticationVerifyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthPasskeyAuthenticationVerifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthRegister invokes Auth_register operation.
//
// Register as superadmin.
//
// POST /api/auth/register
func (c *Client) AuthRegister(ctx context.Context, request *RegisterRequest, options ...RequestOption) (AuthRegisterRes, error) {
	res, err := c.sendAuthRegister(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthRegister(ctx context.Context, request *RegisterRequest, requestOptions ...RequestOption) (res AuthRegisterRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_register"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/register"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthRegisterOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/register"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthRegisterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthRegisterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthTelegramCallback invokes Auth_telegramCallback operation.
//
// Callback from Telegram OAuth2.
//
// POST /api/auth/oauth2/tg/callback
func (c *Client) AuthTelegramCallback(ctx context.Context, request *TelegramCallbackRequest, options ...RequestOption) (AuthTelegramCallbackRes, error) {
	res, err := c.sendAuthTelegramCallback(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthTelegramCallback(ctx context.Context, request *TelegramCallbackRequest, requestOptions ...RequestOption) (res AuthTelegramCallbackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Auth_telegramCallback"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/auth/oauth2/tg/callback"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, AuthTelegramCallbackOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/tg/callback"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthTelegramCallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeAuthTelegramCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BandwidthStatsNodesGetNodeUserUsage invokes BandwidthStatsNodes_getNodeUserUsage operation.
//
// Get Node User Usage by Range and Node UUID (Legacy).
//
// GET /api/bandwidth-stats/nodes/{uuid}/users/legacy
func (c *Client) BandwidthStatsNodesGetNodeUserUsage(ctx context.Context, params BandwidthStatsNodesGetNodeUserUsageParams, options ...RequestOption) (BandwidthStatsNodesGetNodeUserUsageRes, error) {
	res, err := c.sendBandwidthStatsNodesGetNodeUserUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendBandwidthStatsNodesGetNodeUserUsage(ctx context.Context, params BandwidthStatsNodesGetNodeUserUsageParams, requestOptions ...RequestOption) (res BandwidthStatsNodesGetNodeUserUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BandwidthStatsNodes_getNodeUserUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/nodes/{uuid}/users/legacy"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BandwidthStatsNodesGetNodeUserUsageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/bandwidth-stats/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/legacy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, BandwidthStatsNodesGetNodeUserUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeBandwidthStatsNodesGetNodeUserUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BandwidthStatsNodesGetNodesRealtimeUsage invokes BandwidthStatsNodes_getNodesRealtimeUsage operation.
//
// Get Nodes Realtime Usage.
//
// GET /api/bandwidth-stats/nodes/realtime
func (c *Client) BandwidthStatsNodesGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (BandwidthStatsNodesGetNodesRealtimeUsageRes, error) {
	res, err := c.sendBandwidthStatsNodesGetNodesRealtimeUsage(ctx, options...)
	return res, err
}

func (c *Client) sendBandwidthStatsNodesGetNodesRealtimeUsage(ctx context.Context, requestOptions ...RequestOption) (res BandwidthStatsNodesGetNodesRealtimeUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BandwidthStatsNodes_getNodesRealtimeUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/nodes/realtime"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BandwidthStatsNodesGetNodesRealtimeUsageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/bandwidth-stats/nodes/realtime"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, BandwidthStatsNodesGetNodesRealtimeUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeBandwidthStatsNodesGetNodesRealtimeUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BandwidthStatsNodesGetStatsNodeUsersUsage invokes BandwidthStatsNodes_getStatsNodeUsersUsage operation.
//
// Get Node Users Usage by Node UUID.
//
// GET /api/bandwidth-stats/nodes/{uuid}/users
func (c *Client) BandwidthStatsNodesGetStatsNodeUsersUsage(ctx context.Context, params BandwidthStatsNodesGetStatsNodeUsersUsageParams, options ...RequestOption) (BandwidthStatsNodesGetStatsNodeUsersUsageRes, error) {
	res, err := c.sendBandwidthStatsNodesGetStatsNodeUsersUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendBandwidthStatsNodesGetStatsNodeUsersUsage(ctx context.Context, params BandwidthStatsNodesGetStatsNodeUsersUsageParams, requestOptions ...RequestOption) (res BandwidthStatsNodesGetStatsNodeUsersUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BandwidthStatsNodes_getStatsNodeUsersUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/nodes/{uuid}/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BandwidthStatsNodesGetStatsNodeUsersUsageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/bandwidth-stats/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "topUsersLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "topUsersLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.TopUsersLimit))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, BandwidthStatsNodesGetStatsNodeUsersUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeBandwidthStatsNodesGetStatsNodeUsersUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BandwidthStatsUsersGetStatsNodesUsage invokes BandwidthStatsUsers_getStatsNodesUsage operation.
//
// Get User Usage by Range.
//
// GET /api/bandwidth-stats/users/{uuid}
func (c *Client) BandwidthStatsUsersGetStatsNodesUsage(ctx context.Context, params BandwidthStatsUsersGetStatsNodesUsageParams, options ...RequestOption) (BandwidthStatsUsersGetStatsNodesUsageRes, error) {
	res, err := c.sendBandwidthStatsUsersGetStatsNodesUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendBandwidthStatsUsersGetStatsNodesUsage(ctx context.Context, params BandwidthStatsUsersGetStatsNodesUsageParams, requestOptions ...RequestOption) (res BandwidthStatsUsersGetStatsNodesUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BandwidthStatsUsers_getStatsNodesUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/users/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BandwidthStatsUsersGetStatsNodesUsageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/bandwidth-stats/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "topNodesLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "topNodesLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.TopNodesLimit))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, BandwidthStatsUsersGetStatsNodesUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeBandwidthStatsUsersGetStatsNodesUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// BandwidthStatsUsersGetUserUsageByRange invokes BandwidthStatsUsers_getUserUsageByRange operation.
//
// Get User Usage by Range (Legacy).
//
// GET /api/bandwidth-stats/users/{uuid}/legacy
func (c *Client) BandwidthStatsUsersGetUserUsageByRange(ctx context.Context, params BandwidthStatsUsersGetUserUsageByRangeParams, options ...RequestOption) (BandwidthStatsUsersGetUserUsageByRangeRes, error) {
	res, err := c.sendBandwidthStatsUsersGetUserUsageByRange(ctx, params, options...)
	return res, err
}

func (c *Client) sendBandwidthStatsUsersGetUserUsageByRange(ctx context.Context, params BandwidthStatsUsersGetUserUsageByRangeParams, requestOptions ...RequestOption) (res BandwidthStatsUsersGetUserUsageByRangeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("BandwidthStatsUsers_getUserUsageByRange"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/users/{uuid}/legacy"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, BandwidthStatsUsersGetUserUsageByRangeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/bandwidth-stats/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/legacy"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, BandwidthStatsUsersGetUserUsageByRangeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeBandwidthStatsUsersGetUserUsageByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileCreateConfigProfile invokes ConfigProfile_createConfigProfile operation.
//
// Create config profile.
//
// POST /api/config-profiles
func (c *Client) ConfigProfileCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequest, options ...RequestOption) (ConfigProfileCreateConfigProfileRes, error) {
	res, err := c.sendConfigProfileCreateConfigProfile(ctx, request, options...)
	return res, err
}

func (c *Client) sendConfigProfileCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequest, requestOptions ...RequestOption) (res ConfigProfileCreateConfigProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_createConfigProfile"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/config-profiles"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileCreateConfigProfileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigProfileCreateConfigProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileCreateConfigProfileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileCreateConfigProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileDeleteConfigProfileByUuid invokes ConfigProfile_deleteConfigProfileByUuid operation.
//
// Delete config profile.
//
// DELETE /api/config-profiles/{uuid}
func (c *Client) ConfigProfileDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileDeleteConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileDeleteConfigProfileByUuidRes, error) {
	res, err := c.sendConfigProfileDeleteConfigProfileByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileDeleteConfigProfileByUuidParams, requestOptions ...RequestOption) (res ConfigProfileDeleteConfigProfileByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_deleteConfigProfileByUuid"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/config-profiles/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileDeleteConfigProfileByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileDeleteConfigProfileByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileDeleteConfigProfileByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileGetAllInbounds invokes ConfigProfile_getAllInbounds operation.
//
// Get all inbounds from all config profiles.
//
// GET /api/config-profiles/inbounds
func (c *Client) ConfigProfileGetAllInbounds(ctx context.Context, options ...RequestOption) (ConfigProfileGetAllInboundsRes, error) {
	res, err := c.sendConfigProfileGetAllInbounds(ctx, options...)
	return res, err
}

func (c *Client) sendConfigProfileGetAllInbounds(ctx context.Context, requestOptions ...RequestOption) (res ConfigProfileGetAllInboundsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_getAllInbounds"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/config-profiles/inbounds"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileGetAllInboundsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles/inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileGetAllInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileGetAllInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileGetComputedConfigProfileByUuid invokes ConfigProfile_getComputedConfigProfileByUuid operation.
//
// Get computed config profile by uuid.
//
// GET /api/config-profiles/{uuid}/computed-config
func (c *Client) ConfigProfileGetComputedConfigProfileByUuid(ctx context.Context, params ConfigProfileGetComputedConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileGetComputedConfigProfileByUuidRes, error) {
	res, err := c.sendConfigProfileGetComputedConfigProfileByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileGetComputedConfigProfileByUuid(ctx context.Context, params ConfigProfileGetComputedConfigProfileByUuidParams, requestOptions ...RequestOption) (res ConfigProfileGetComputedConfigProfileByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_getComputedConfigProfileByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/config-profiles/{uuid}/computed-config"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileGetComputedConfigProfileByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/computed-config"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileGetComputedConfigProfileByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileGetComputedConfigProfileByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileGetConfigProfileByUuid invokes ConfigProfile_getConfigProfileByUuid operation.
//
// Get config profile by uuid.
//
// GET /api/config-profiles/{uuid}
func (c *Client) ConfigProfileGetConfigProfileByUuid(ctx context.Context, params ConfigProfileGetConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileGetConfigProfileByUuidRes, error) {
	res, err := c.sendConfigProfileGetConfigProfileByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileGetConfigProfileByUuid(ctx context.Context, params ConfigProfileGetConfigProfileByUuidParams, requestOptions ...RequestOption) (res ConfigProfileGetConfigProfileByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_getConfigProfileByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/config-profiles/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileGetConfigProfileByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileGetConfigProfileByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileGetConfigProfileByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileGetConfigProfiles invokes ConfigProfile_getConfigProfiles operation.
//
// Get config profiles.
//
// GET /api/config-profiles
func (c *Client) ConfigProfileGetConfigProfiles(ctx context.Context, options ...RequestOption) (ConfigProfileGetConfigProfilesRes, error) {
	res, err := c.sendConfigProfileGetConfigProfiles(ctx, options...)
	return res, err
}

func (c *Client) sendConfigProfileGetConfigProfiles(ctx context.Context, requestOptions ...RequestOption) (res ConfigProfileGetConfigProfilesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_getConfigProfiles"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/config-profiles"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileGetConfigProfilesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileGetConfigProfilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileGetConfigProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileGetInboundsByProfileUuid invokes ConfigProfile_getInboundsByProfileUuid operation.
//
// Get inbounds by profile uuid.
//
// GET /api/config-profiles/{uuid}/inbounds
func (c *Client) ConfigProfileGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileGetInboundsByProfileUuidParams, options ...RequestOption) (ConfigProfileGetInboundsByProfileUuidRes, error) {
	res, err := c.sendConfigProfileGetInboundsByProfileUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileGetInboundsByProfileUuidParams, requestOptions ...RequestOption) (res ConfigProfileGetInboundsByProfileUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_getInboundsByProfileUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/config-profiles/{uuid}/inbounds"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileGetInboundsByProfileUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileGetInboundsByProfileUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileGetInboundsByProfileUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileReorderConfigProfiles invokes ConfigProfile_reorderConfigProfiles operation.
//
// Reorder config profiles.
//
// POST /api/config-profiles/actions/reorder
func (c *Client) ConfigProfileReorderConfigProfiles(ctx context.Context, request *ReorderRequest, options ...RequestOption) (ConfigProfileReorderConfigProfilesRes, error) {
	res, err := c.sendConfigProfileReorderConfigProfiles(ctx, request, options...)
	return res, err
}

func (c *Client) sendConfigProfileReorderConfigProfiles(ctx context.Context, request *ReorderRequest, requestOptions ...RequestOption) (res ConfigProfileReorderConfigProfilesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_reorderConfigProfiles"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/config-profiles/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileReorderConfigProfilesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigProfileReorderConfigProfilesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileReorderConfigProfilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileReorderConfigProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileUpdateConfigProfile invokes ConfigProfile_updateConfigProfile operation.
//
// Update Core Config in specific config profile.
//
// PATCH /api/config-profiles
func (c *Client) ConfigProfileUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequest, options ...RequestOption) (ConfigProfileUpdateConfigProfileRes, error) {
	res, err := c.sendConfigProfileUpdateConfigProfile(ctx, request, options...)
	return res, err
}

func (c *Client) sendConfigProfileUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequest, requestOptions ...RequestOption) (res ConfigProfileUpdateConfigProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ConfigProfile_updateConfigProfile"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/config-profiles"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ConfigProfileUpdateConfigProfileOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigProfileUpdateConfigProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ConfigProfileUpdateConfigProfileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeConfigProfileUpdateConfigProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadAddUsersToExternalSquad invokes ExternalSquad_addUsersToExternalSquad operation.
//
// Add all users to external squad.
//
// POST /api/external-squads/{uuid}/bulk-actions/add-users
func (c *Client) ExternalSquadAddUsersToExternalSquad(ctx context.Context, params ExternalSquadAddUsersToExternalSquadParams, options ...RequestOption) (ExternalSquadAddUsersToExternalSquadRes, error) {
	res, err := c.sendExternalSquadAddUsersToExternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendExternalSquadAddUsersToExternalSquad(ctx context.Context, params ExternalSquadAddUsersToExternalSquadParams, requestOptions ...RequestOption) (res ExternalSquadAddUsersToExternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_addUsersToExternalSquad"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/external-squads/{uuid}/bulk-actions/add-users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadAddUsersToExternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/external-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/add-users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadAddUsersToExternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadAddUsersToExternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadCreateExternalSquad invokes ExternalSquad_createExternalSquad operation.
//
// Create external squad.
//
// POST /api/external-squads
func (c *Client) ExternalSquadCreateExternalSquad(ctx context.Context, request *CreateExternalSquadRequest, options ...RequestOption) (ExternalSquadCreateExternalSquadRes, error) {
	res, err := c.sendExternalSquadCreateExternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendExternalSquadCreateExternalSquad(ctx context.Context, request *CreateExternalSquadRequest, requestOptions ...RequestOption) (res ExternalSquadCreateExternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_createExternalSquad"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/external-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadCreateExternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/external-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExternalSquadCreateExternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadCreateExternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadCreateExternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadDeleteExternalSquad invokes ExternalSquad_deleteExternalSquad operation.
//
// Delete external squad.
//
// DELETE /api/external-squads/{uuid}
func (c *Client) ExternalSquadDeleteExternalSquad(ctx context.Context, params ExternalSquadDeleteExternalSquadParams, options ...RequestOption) (ExternalSquadDeleteExternalSquadRes, error) {
	res, err := c.sendExternalSquadDeleteExternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendExternalSquadDeleteExternalSquad(ctx context.Context, params ExternalSquadDeleteExternalSquadParams, requestOptions ...RequestOption) (res ExternalSquadDeleteExternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_deleteExternalSquad"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/external-squads/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadDeleteExternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/external-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadDeleteExternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadDeleteExternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadGetExternalSquadByUuid invokes ExternalSquad_getExternalSquadByUuid operation.
//
// Get external squad by uuid.
//
// GET /api/external-squads/{uuid}
func (c *Client) ExternalSquadGetExternalSquadByUuid(ctx context.Context, params ExternalSquadGetExternalSquadByUuidParams, options ...RequestOption) (ExternalSquadGetExternalSquadByUuidRes, error) {
	res, err := c.sendExternalSquadGetExternalSquadByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendExternalSquadGetExternalSquadByUuid(ctx context.Context, params ExternalSquadGetExternalSquadByUuidParams, requestOptions ...RequestOption) (res ExternalSquadGetExternalSquadByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_getExternalSquadByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/external-squads/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadGetExternalSquadByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/external-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadGetExternalSquadByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadGetExternalSquadByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadGetExternalSquads invokes ExternalSquad_getExternalSquads operation.
//
// Get all external squads.
//
// GET /api/external-squads
func (c *Client) ExternalSquadGetExternalSquads(ctx context.Context, options ...RequestOption) (ExternalSquadGetExternalSquadsRes, error) {
	res, err := c.sendExternalSquadGetExternalSquads(ctx, options...)
	return res, err
}

func (c *Client) sendExternalSquadGetExternalSquads(ctx context.Context, requestOptions ...RequestOption) (res ExternalSquadGetExternalSquadsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_getExternalSquads"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/external-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadGetExternalSquadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/external-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadGetExternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadGetExternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadRemoveUsersFromExternalSquad invokes ExternalSquad_removeUsersFromExternalSquad operation.
//
// Delete users from external squad.
//
// DELETE /api/external-squads/{uuid}/bulk-actions/remove-users
func (c *Client) ExternalSquadRemoveUsersFromExternalSquad(ctx context.Context, params ExternalSquadRemoveUsersFromExternalSquadParams, options ...RequestOption) (ExternalSquadRemoveUsersFromExternalSquadRes, error) {
	res, err := c.sendExternalSquadRemoveUsersFromExternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendExternalSquadRemoveUsersFromExternalSquad(ctx context.Context, params ExternalSquadRemoveUsersFromExternalSquadParams, requestOptions ...RequestOption) (res ExternalSquadRemoveUsersFromExternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_removeUsersFromExternalSquad"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/external-squads/{uuid}/bulk-actions/remove-users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadRemoveUsersFromExternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/external-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/remove-users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadRemoveUsersFromExternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadRemoveUsersFromExternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadReorderExternalSquads invokes ExternalSquad_reorderExternalSquads operation.
//
// Reorder external squads.
//
// POST /api/external-squads/actions/reorder
func (c *Client) ExternalSquadReorderExternalSquads(ctx context.Context, request *ReorderRequest, options ...RequestOption) (ExternalSquadReorderExternalSquadsRes, error) {
	res, err := c.sendExternalSquadReorderExternalSquads(ctx, request, options...)
	return res, err
}

func (c *Client) sendExternalSquadReorderExternalSquads(ctx context.Context, request *ReorderRequest, requestOptions ...RequestOption) (res ExternalSquadReorderExternalSquadsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_reorderExternalSquads"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/external-squads/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadReorderExternalSquadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/external-squads/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExternalSquadReorderExternalSquadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadReorderExternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadReorderExternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ExternalSquadUpdateExternalSquad invokes ExternalSquad_updateExternalSquad operation.
//
// Update external squad.
//
// PATCH /api/external-squads
func (c *Client) ExternalSquadUpdateExternalSquad(ctx context.Context, request *UpdateExternalSquadRequest, options ...RequestOption) (ExternalSquadUpdateExternalSquadRes, error) {
	res, err := c.sendExternalSquadUpdateExternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendExternalSquadUpdateExternalSquad(ctx context.Context, request *UpdateExternalSquadRequest, requestOptions ...RequestOption) (res ExternalSquadUpdateExternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ExternalSquad_updateExternalSquad"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/external-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, ExternalSquadUpdateExternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/external-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeExternalSquadUpdateExternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, ExternalSquadUpdateExternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeExternalSquadUpdateExternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsDeleteHosts invokes HostsBulkActions_deleteHosts operation.
//
// Delete hosts by UUIDs.
//
// POST /api/hosts/bulk/delete
func (c *Client) HostsBulkActionsDeleteHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsDeleteHostsRes, error) {
	res, err := c.sendHostsBulkActionsDeleteHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsDeleteHosts(ctx context.Context, request *BulkUuidsRequest2, requestOptions ...RequestOption) (res HostsBulkActionsDeleteHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HostsBulkActions_deleteHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/bulk/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsBulkActionsDeleteHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsDeleteHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsBulkActionsDeleteHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsBulkActionsDeleteHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsDisableHosts invokes HostsBulkActions_disableHosts operation.
//
// Disable hosts by UUIDs.
//
// POST /api/hosts/bulk/disable
func (c *Client) HostsBulkActionsDisableHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsDisableHostsRes, error) {
	res, err := c.sendHostsBulkActionsDisableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsDisableHosts(ctx context.Context, request *BulkUuidsRequest2, requestOptions ...RequestOption) (res HostsBulkActionsDisableHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HostsBulkActions_disableHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/bulk/disable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsBulkActionsDisableHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/disable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsDisableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsBulkActionsDisableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsBulkActionsDisableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsEnableHosts invokes HostsBulkActions_enableHosts operation.
//
// Enable hosts by UUIDs.
//
// POST /api/hosts/bulk/enable
func (c *Client) HostsBulkActionsEnableHosts(ctx context.Context, request *BulkUuidsRequest2, options ...RequestOption) (HostsBulkActionsEnableHostsRes, error) {
	res, err := c.sendHostsBulkActionsEnableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsEnableHosts(ctx context.Context, request *BulkUuidsRequest2, requestOptions ...RequestOption) (res HostsBulkActionsEnableHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HostsBulkActions_enableHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/bulk/enable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsBulkActionsEnableHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/enable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsEnableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsBulkActionsEnableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsBulkActionsEnableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsSetInboundToHosts invokes HostsBulkActions_setInboundToHosts operation.
//
// Set inbound to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-inbound
func (c *Client) HostsBulkActionsSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequest, options ...RequestOption) (HostsBulkActionsSetInboundToHostsRes, error) {
	res, err := c.sendHostsBulkActionsSetInboundToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequest, requestOptions ...RequestOption) (res HostsBulkActionsSetInboundToHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HostsBulkActions_setInboundToHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/bulk/set-inbound"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsBulkActionsSetInboundToHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-inbound"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsSetInboundToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsBulkActionsSetInboundToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsBulkActionsSetInboundToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsSetPortToHosts invokes HostsBulkActions_setPortToHosts operation.
//
// Set port to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-port
func (c *Client) HostsBulkActionsSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequest, options ...RequestOption) (HostsBulkActionsSetPortToHostsRes, error) {
	res, err := c.sendHostsBulkActionsSetPortToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequest, requestOptions ...RequestOption) (res HostsBulkActionsSetPortToHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HostsBulkActions_setPortToHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/bulk/set-port"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsBulkActionsSetPortToHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-port"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsSetPortToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsBulkActionsSetPortToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsBulkActionsSetPortToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsCreateHost invokes Hosts_createHost operation.
//
// Create a new host.
//
// POST /api/hosts
func (c *Client) HostsCreateHost(ctx context.Context, request *CreateHostRequest, options ...RequestOption) (HostsCreateHostRes, error) {
	res, err := c.sendHostsCreateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsCreateHost(ctx context.Context, request *CreateHostRequest, requestOptions ...RequestOption) (res HostsCreateHostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_createHost"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsCreateHostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsCreateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsCreateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsCreateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsDeleteHost invokes Hosts_deleteHost operation.
//
// Delete a host by UUID.
//
// DELETE /api/hosts/{uuid}
func (c *Client) HostsDeleteHost(ctx context.Context, params HostsDeleteHostParams, options ...RequestOption) (HostsDeleteHostRes, error) {
	res, err := c.sendHostsDeleteHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsDeleteHost(ctx context.Context, params HostsDeleteHostParams, requestOptions ...RequestOption) (res HostsDeleteHostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_deleteHost"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/hosts/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsDeleteHostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsDeleteHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsDeleteHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsGetAllHostTags invokes Hosts_getAllHostTags operation.
//
// Get all existing host tags.
//
// GET /api/hosts/tags
func (c *Client) HostsGetAllHostTags(ctx context.Context, options ...RequestOption) (HostsGetAllHostTagsRes, error) {
	res, err := c.sendHostsGetAllHostTags(ctx, options...)
	return res, err
}

func (c *Client) sendHostsGetAllHostTags(ctx context.Context, requestOptions ...RequestOption) (res HostsGetAllHostTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_getAllHostTags"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hosts/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsGetAllHostTagsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsGetAllHostTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsGetAllHostTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsGetAllHosts invokes Hosts_getAllHosts operation.
//
// Get all hosts.
//
// GET /api/hosts
func (c *Client) HostsGetAllHosts(ctx context.Context, options ...RequestOption) (HostsGetAllHostsRes, error) {
	res, err := c.sendHostsGetAllHosts(ctx, options...)
	return res, err
}

func (c *Client) sendHostsGetAllHosts(ctx context.Context, requestOptions ...RequestOption) (res HostsGetAllHostsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_getAllHosts"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hosts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsGetAllHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsGetAllHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsGetAllHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsGetOneHost invokes Hosts_getOneHost operation.
//
// Get a host by UUID.
//
// GET /api/hosts/{uuid}
func (c *Client) HostsGetOneHost(ctx context.Context, params HostsGetOneHostParams, options ...RequestOption) (HostsGetOneHostRes, error) {
	res, err := c.sendHostsGetOneHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsGetOneHost(ctx context.Context, params HostsGetOneHostParams, requestOptions ...RequestOption) (res HostsGetOneHostRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_getOneHost"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hosts/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsGetOneHostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsGetOneHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsGetOneHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsReorderHosts invokes Hosts_reorderHosts operation.
//
// Reorder hosts.
//
// POST /api/hosts/actions/reorder
func (c *Client) HostsReorderHosts(ctx context.Context, request *ReorderHostRequest, options ...RequestOption) (HostsReorderHostsRes, error) {
	res, err := c.sendHostsReorderHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsReorderHosts(ctx context.Context, request *ReorderHostRequest, requestOptions ...RequestOption) (res HostsReorderHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_reorderHosts"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hosts/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsReorderHostsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsReorderHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsReorderHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsReorderHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsUpdateHost invokes Hosts_updateHost operation.
//
// Update a host.
//
// PATCH /api/hosts
func (c *Client) HostsUpdateHost(ctx context.Context, request *UpdateHostRequest, options ...RequestOption) (HostsUpdateHostRes, error) {
	res, err := c.sendHostsUpdateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsUpdateHost(ctx context.Context, request *UpdateHostRequest, requestOptions ...RequestOption) (res HostsUpdateHostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Hosts_updateHost"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/hosts"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HostsUpdateHostOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsUpdateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HostsUpdateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHostsUpdateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesCreateUserHwidDevice invokes HwidUserDevices_createUserHwidDevice operation.
//
// Create a user HWID device.
//
// POST /api/hwid/devices
func (c *Client) HwidUserDevicesCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequest, options ...RequestOption) (HwidUserDevicesCreateUserHwidDeviceRes, error) {
	res, err := c.sendHwidUserDevicesCreateUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequest, requestOptions ...RequestOption) (res HwidUserDevicesCreateUserHwidDeviceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_createUserHwidDevice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hwid/devices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesCreateUserHwidDeviceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesCreateUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesCreateUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesCreateUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesDeleteAllUserHwidDevices invokes HwidUserDevices_deleteAllUserHwidDevices operation.
//
// Delete all user HWID devices.
//
// POST /api/hwid/devices/delete-all
func (c *Client) HwidUserDevicesDeleteAllUserHwidDevices(ctx context.Context, request *DeleteAllUserHwidDevicesRequest, options ...RequestOption) (HwidUserDevicesDeleteAllUserHwidDevicesRes, error) {
	res, err := c.sendHwidUserDevicesDeleteAllUserHwidDevices(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesDeleteAllUserHwidDevices(ctx context.Context, request *DeleteAllUserHwidDevicesRequest, requestOptions ...RequestOption) (res HwidUserDevicesDeleteAllUserHwidDevicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_deleteAllUserHwidDevices"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hwid/devices/delete-all"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesDeleteAllUserHwidDevicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/delete-all"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesDeleteAllUserHwidDevicesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesDeleteAllUserHwidDevicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesDeleteAllUserHwidDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesDeleteUserHwidDevice invokes HwidUserDevices_deleteUserHwidDevice operation.
//
// Delete a user HWID device.
//
// POST /api/hwid/devices/delete
func (c *Client) HwidUserDevicesDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequest, options ...RequestOption) (HwidUserDevicesDeleteUserHwidDeviceRes, error) {
	res, err := c.sendHwidUserDevicesDeleteUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequest, requestOptions ...RequestOption) (res HwidUserDevicesDeleteUserHwidDeviceRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_deleteUserHwidDevice"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/hwid/devices/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesDeleteUserHwidDeviceOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesDeleteUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesDeleteUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesDeleteUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesGetAllUsers invokes HwidUserDevices_getAllUsers operation.
//
// Get all HWID devices.
//
// GET /api/hwid/devices
func (c *Client) HwidUserDevicesGetAllUsers(ctx context.Context, params HwidUserDevicesGetAllUsersParams, options ...RequestOption) (HwidUserDevicesGetAllUsersRes, error) {
	res, err := c.sendHwidUserDevicesGetAllUsers(ctx, params, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesGetAllUsers(ctx context.Context, params HwidUserDevicesGetAllUsersParams, requestOptions ...RequestOption) (res HwidUserDevicesGetAllUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_getAllUsers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hwid/devices"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesGetAllUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesGetAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesGetAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesGetHwidDevicesStats invokes HwidUserDevices_getHwidDevicesStats operation.
//
// Get HWID devices stats.
//
// GET /api/hwid/devices/stats
func (c *Client) HwidUserDevicesGetHwidDevicesStats(ctx context.Context, options ...RequestOption) (HwidUserDevicesGetHwidDevicesStatsRes, error) {
	res, err := c.sendHwidUserDevicesGetHwidDevicesStats(ctx, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesGetHwidDevicesStats(ctx context.Context, requestOptions ...RequestOption) (res HwidUserDevicesGetHwidDevicesStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_getHwidDevicesStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hwid/devices/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesGetHwidDevicesStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesGetHwidDevicesStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesGetHwidDevicesStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesGetTopUsersByHwidDevices invokes HwidUserDevices_getTopUsersByHwidDevices operation.
//
// Get top users by HWID devices.
//
// GET /api/hwid/devices/top-users
func (c *Client) HwidUserDevicesGetTopUsersByHwidDevices(ctx context.Context, params HwidUserDevicesGetTopUsersByHwidDevicesParams, options ...RequestOption) (HwidUserDevicesGetTopUsersByHwidDevicesRes, error) {
	res, err := c.sendHwidUserDevicesGetTopUsersByHwidDevices(ctx, params, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesGetTopUsersByHwidDevices(ctx context.Context, params HwidUserDevicesGetTopUsersByHwidDevicesParams, requestOptions ...RequestOption) (res HwidUserDevicesGetTopUsersByHwidDevicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_getTopUsersByHwidDevices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hwid/devices/top-users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesGetTopUsersByHwidDevicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/top-users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesGetTopUsersByHwidDevicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesGetTopUsersByHwidDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesGetUserHwidDevices invokes HwidUserDevices_getUserHwidDevices operation.
//
// Get user HWID devices.
//
// GET /api/hwid/devices/{userUuid}
func (c *Client) HwidUserDevicesGetUserHwidDevices(ctx context.Context, params HwidUserDevicesGetUserHwidDevicesParams, options ...RequestOption) (HwidUserDevicesGetUserHwidDevicesRes, error) {
	res, err := c.sendHwidUserDevicesGetUserHwidDevices(ctx, params, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesGetUserHwidDevices(ctx context.Context, params HwidUserDevicesGetUserHwidDevicesParams, requestOptions ...RequestOption) (res HwidUserDevicesGetUserHwidDevicesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("HwidUserDevices_getUserHwidDevices"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/hwid/devices/{userUuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, HwidUserDevicesGetUserHwidDevicesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hwid/devices/"
	{
		// Encode "userUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, HwidUserDevicesGetUserHwidDevicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeHwidUserDevicesGetUserHwidDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingCreateInfraBillingHistoryRecord invokes InfraBilling_createInfraBillingHistoryRecord operation.
//
// Create infra billing history.
//
// POST /api/infra-billing/history
func (c *Client) InfraBillingCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequest, options ...RequestOption) (InfraBillingCreateInfraBillingHistoryRecordRes, error) {
	res, err := c.sendInfraBillingCreateInfraBillingHistoryRecord(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequest, requestOptions ...RequestOption) (res InfraBillingCreateInfraBillingHistoryRecordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_createInfraBillingHistoryRecord"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/infra-billing/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingCreateInfraBillingHistoryRecordOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingCreateInfraBillingHistoryRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingCreateInfraBillingHistoryRecordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingCreateInfraBillingHistoryRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingCreateInfraBillingNode invokes InfraBilling_createInfraBillingNode operation.
//
// Create infra billing node.
//
// POST /api/infra-billing/nodes
func (c *Client) InfraBillingCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequest, options ...RequestOption) (InfraBillingCreateInfraBillingNodeRes, error) {
	res, err := c.sendInfraBillingCreateInfraBillingNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequest, requestOptions ...RequestOption) (res InfraBillingCreateInfraBillingNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_createInfraBillingNode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/infra-billing/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingCreateInfraBillingNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingCreateInfraBillingNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingCreateInfraBillingNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingCreateInfraBillingNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingCreateInfraProvider invokes InfraBilling_createInfraProvider operation.
//
// Create infra provider.
//
// POST /api/infra-billing/providers
func (c *Client) InfraBillingCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequest, options ...RequestOption) (InfraBillingCreateInfraProviderRes, error) {
	res, err := c.sendInfraBillingCreateInfraProvider(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequest, requestOptions ...RequestOption) (res InfraBillingCreateInfraProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_createInfraProvider"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/infra-billing/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingCreateInfraProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingCreateInfraProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingCreateInfraProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingCreateInfraProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingDeleteInfraBillingHistoryRecordByUuid invokes InfraBilling_deleteInfraBillingHistoryRecordByUuid operation.
//
// Delete infra billing history.
//
// DELETE /api/infra-billing/history/{uuid}
func (c *Client) InfraBillingDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingHistoryRecordByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraBillingHistoryRecordByUuidRes, error) {
	res, err := c.sendInfraBillingDeleteInfraBillingHistoryRecordByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingHistoryRecordByUuidParams, requestOptions ...RequestOption) (res InfraBillingDeleteInfraBillingHistoryRecordByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_deleteInfraBillingHistoryRecordByUuid"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/infra-billing/history/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingDeleteInfraBillingHistoryRecordByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/history/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingDeleteInfraBillingHistoryRecordByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingDeleteInfraBillingHistoryRecordByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingDeleteInfraBillingNodeByUuid invokes InfraBilling_deleteInfraBillingNodeByUuid operation.
//
// Delete infra billing node.
//
// DELETE /api/infra-billing/nodes/{uuid}
func (c *Client) InfraBillingDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingNodeByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraBillingNodeByUuidRes, error) {
	res, err := c.sendInfraBillingDeleteInfraBillingNodeByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingDeleteInfraBillingNodeByUuidParams, requestOptions ...RequestOption) (res InfraBillingDeleteInfraBillingNodeByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_deleteInfraBillingNodeByUuid"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/infra-billing/nodes/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingDeleteInfraBillingNodeByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingDeleteInfraBillingNodeByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingDeleteInfraBillingNodeByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingDeleteInfraProviderByUuid invokes InfraBilling_deleteInfraProviderByUuid operation.
//
// Delete infra provider by uuid.
//
// DELETE /api/infra-billing/providers/{uuid}
func (c *Client) InfraBillingDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingDeleteInfraProviderByUuidParams, options ...RequestOption) (InfraBillingDeleteInfraProviderByUuidRes, error) {
	res, err := c.sendInfraBillingDeleteInfraProviderByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingDeleteInfraProviderByUuidParams, requestOptions ...RequestOption) (res InfraBillingDeleteInfraProviderByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_deleteInfraProviderByUuid"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/infra-billing/providers/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingDeleteInfraProviderByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/providers/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingDeleteInfraProviderByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingDeleteInfraProviderByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingGetBillingNodes invokes InfraBilling_getBillingNodes operation.
//
// Get infra billing nodes.
//
// GET /api/infra-billing/nodes
func (c *Client) InfraBillingGetBillingNodes(ctx context.Context, options ...RequestOption) (InfraBillingGetBillingNodesRes, error) {
	res, err := c.sendInfraBillingGetBillingNodes(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingGetBillingNodes(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingGetBillingNodesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_getBillingNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/infra-billing/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingGetBillingNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingGetBillingNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingGetBillingNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingGetInfraBillingHistoryRecords invokes InfraBilling_getInfraBillingHistoryRecords operation.
//
// Get infra billing history.
//
// GET /api/infra-billing/history
func (c *Client) InfraBillingGetInfraBillingHistoryRecords(ctx context.Context, options ...RequestOption) (InfraBillingGetInfraBillingHistoryRecordsRes, error) {
	res, err := c.sendInfraBillingGetInfraBillingHistoryRecords(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingGetInfraBillingHistoryRecords(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingGetInfraBillingHistoryRecordsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_getInfraBillingHistoryRecords"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/infra-billing/history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingGetInfraBillingHistoryRecordsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingGetInfraBillingHistoryRecordsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingGetInfraBillingHistoryRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingGetInfraProviderByUuid invokes InfraBilling_getInfraProviderByUuid operation.
//
// Get infra provider by uuid.
//
// GET /api/infra-billing/providers/{uuid}
func (c *Client) InfraBillingGetInfraProviderByUuid(ctx context.Context, params InfraBillingGetInfraProviderByUuidParams, options ...RequestOption) (InfraBillingGetInfraProviderByUuidRes, error) {
	res, err := c.sendInfraBillingGetInfraProviderByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingGetInfraProviderByUuid(ctx context.Context, params InfraBillingGetInfraProviderByUuidParams, requestOptions ...RequestOption) (res InfraBillingGetInfraProviderByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_getInfraProviderByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/infra-billing/providers/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingGetInfraProviderByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/providers/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingGetInfraProviderByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingGetInfraProviderByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingGetInfraProviders invokes InfraBilling_getInfraProviders operation.
//
// Get all infra providers.
//
// GET /api/infra-billing/providers
func (c *Client) InfraBillingGetInfraProviders(ctx context.Context, options ...RequestOption) (InfraBillingGetInfraProvidersRes, error) {
	res, err := c.sendInfraBillingGetInfraProviders(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingGetInfraProviders(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingGetInfraProvidersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_getInfraProviders"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/infra-billing/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingGetInfraProvidersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingGetInfraProvidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingGetInfraProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingUpdateInfraBillingNode invokes InfraBilling_updateInfraBillingNode operation.
//
// Update infra billing nodes.
//
// PATCH /api/infra-billing/nodes
func (c *Client) InfraBillingUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequest, options ...RequestOption) (InfraBillingUpdateInfraBillingNodeRes, error) {
	res, err := c.sendInfraBillingUpdateInfraBillingNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequest, requestOptions ...RequestOption) (res InfraBillingUpdateInfraBillingNodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_updateInfraBillingNode"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/infra-billing/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingUpdateInfraBillingNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingUpdateInfraBillingNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingUpdateInfraBillingNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingUpdateInfraBillingNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingUpdateInfraProvider invokes InfraBilling_updateInfraProvider operation.
//
// Update infra provider.
//
// PATCH /api/infra-billing/providers
func (c *Client) InfraBillingUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequest, options ...RequestOption) (InfraBillingUpdateInfraProviderRes, error) {
	res, err := c.sendInfraBillingUpdateInfraProvider(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequest, requestOptions ...RequestOption) (res InfraBillingUpdateInfraProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InfraBilling_updateInfraProvider"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/infra-billing/providers"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InfraBillingUpdateInfraProviderOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingUpdateInfraProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InfraBillingUpdateInfraProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInfraBillingUpdateInfraProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadAddUsersToInternalSquad invokes InternalSquad_addUsersToInternalSquad operation.
//
// Add all users to internal squad.
//
// POST /api/internal-squads/{uuid}/bulk-actions/add-users
func (c *Client) InternalSquadAddUsersToInternalSquad(ctx context.Context, params InternalSquadAddUsersToInternalSquadParams, options ...RequestOption) (InternalSquadAddUsersToInternalSquadRes, error) {
	res, err := c.sendInternalSquadAddUsersToInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadAddUsersToInternalSquad(ctx context.Context, params InternalSquadAddUsersToInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadAddUsersToInternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_addUsersToInternalSquad"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/internal-squads/{uuid}/bulk-actions/add-users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadAddUsersToInternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/add-users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadAddUsersToInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadAddUsersToInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadCreateInternalSquad invokes InternalSquad_createInternalSquad operation.
//
// Create internal squad.
//
// POST /api/internal-squads
func (c *Client) InternalSquadCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequest, options ...RequestOption) (InternalSquadCreateInternalSquadRes, error) {
	res, err := c.sendInternalSquadCreateInternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendInternalSquadCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequest, requestOptions ...RequestOption) (res InternalSquadCreateInternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_createInternalSquad"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/internal-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadCreateInternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInternalSquadCreateInternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadCreateInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadCreateInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadDeleteInternalSquad invokes InternalSquad_deleteInternalSquad operation.
//
// Delete internal squad.
//
// DELETE /api/internal-squads/{uuid}
func (c *Client) InternalSquadDeleteInternalSquad(ctx context.Context, params InternalSquadDeleteInternalSquadParams, options ...RequestOption) (InternalSquadDeleteInternalSquadRes, error) {
	res, err := c.sendInternalSquadDeleteInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadDeleteInternalSquad(ctx context.Context, params InternalSquadDeleteInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadDeleteInternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_deleteInternalSquad"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/internal-squads/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadDeleteInternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadDeleteInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadDeleteInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadGetInternalSquadAccessibleNodes invokes InternalSquad_getInternalSquadAccessibleNodes operation.
//
// Get internal squad accessible nodes.
//
// GET /api/internal-squads/{uuid}/accessible-nodes
func (c *Client) InternalSquadGetInternalSquadAccessibleNodes(ctx context.Context, params InternalSquadGetInternalSquadAccessibleNodesParams, options ...RequestOption) (InternalSquadGetInternalSquadAccessibleNodesRes, error) {
	res, err := c.sendInternalSquadGetInternalSquadAccessibleNodes(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadGetInternalSquadAccessibleNodes(ctx context.Context, params InternalSquadGetInternalSquadAccessibleNodesParams, requestOptions ...RequestOption) (res InternalSquadGetInternalSquadAccessibleNodesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_getInternalSquadAccessibleNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/internal-squads/{uuid}/accessible-nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadGetInternalSquadAccessibleNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accessible-nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadGetInternalSquadAccessibleNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadGetInternalSquadAccessibleNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadGetInternalSquadByUuid invokes InternalSquad_getInternalSquadByUuid operation.
//
// Get internal squad by uuid.
//
// GET /api/internal-squads/{uuid}
func (c *Client) InternalSquadGetInternalSquadByUuid(ctx context.Context, params InternalSquadGetInternalSquadByUuidParams, options ...RequestOption) (InternalSquadGetInternalSquadByUuidRes, error) {
	res, err := c.sendInternalSquadGetInternalSquadByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadGetInternalSquadByUuid(ctx context.Context, params InternalSquadGetInternalSquadByUuidParams, requestOptions ...RequestOption) (res InternalSquadGetInternalSquadByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_getInternalSquadByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/internal-squads/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadGetInternalSquadByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadGetInternalSquadByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadGetInternalSquadByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadGetInternalSquads invokes InternalSquad_getInternalSquads operation.
//
// Get all internal squads.
//
// GET /api/internal-squads
func (c *Client) InternalSquadGetInternalSquads(ctx context.Context, options ...RequestOption) (InternalSquadGetInternalSquadsRes, error) {
	res, err := c.sendInternalSquadGetInternalSquads(ctx, options...)
	return res, err
}

func (c *Client) sendInternalSquadGetInternalSquads(ctx context.Context, requestOptions ...RequestOption) (res InternalSquadGetInternalSquadsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_getInternalSquads"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/internal-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadGetInternalSquadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadGetInternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadGetInternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadRemoveUsersFromInternalSquad invokes InternalSquad_removeUsersFromInternalSquad operation.
//
// Delete users from internal squad.
//
// DELETE /api/internal-squads/{uuid}/bulk-actions/remove-users
func (c *Client) InternalSquadRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadRemoveUsersFromInternalSquadParams, options ...RequestOption) (InternalSquadRemoveUsersFromInternalSquadRes, error) {
	res, err := c.sendInternalSquadRemoveUsersFromInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadRemoveUsersFromInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadRemoveUsersFromInternalSquadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_removeUsersFromInternalSquad"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/internal-squads/{uuid}/bulk-actions/remove-users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadRemoveUsersFromInternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/remove-users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadRemoveUsersFromInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadRemoveUsersFromInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadReorderInternalSquads invokes InternalSquad_reorderInternalSquads operation.
//
// Reorder internal squads.
//
// POST /api/internal-squads/actions/reorder
func (c *Client) InternalSquadReorderInternalSquads(ctx context.Context, request *ReorderRequest, options ...RequestOption) (InternalSquadReorderInternalSquadsRes, error) {
	res, err := c.sendInternalSquadReorderInternalSquads(ctx, request, options...)
	return res, err
}

func (c *Client) sendInternalSquadReorderInternalSquads(ctx context.Context, request *ReorderRequest, requestOptions ...RequestOption) (res InternalSquadReorderInternalSquadsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_reorderInternalSquads"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/internal-squads/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadReorderInternalSquadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInternalSquadReorderInternalSquadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadReorderInternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadReorderInternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadUpdateInternalSquad invokes InternalSquad_updateInternalSquad operation.
//
// Update internal squad.
//
// PATCH /api/internal-squads
func (c *Client) InternalSquadUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequest, options ...RequestOption) (InternalSquadUpdateInternalSquadRes, error) {
	res, err := c.sendInternalSquadUpdateInternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendInternalSquadUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequest, requestOptions ...RequestOption) (res InternalSquadUpdateInternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InternalSquad_updateInternalSquad"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/internal-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, InternalSquadUpdateInternalSquadOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInternalSquadUpdateInternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, InternalSquadUpdateInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeInternalSquadUpdateInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KeygenGenerateKey invokes Keygen_generateKey operation.
//
// Get SSL_CERT for Remnawave Node.
//
// GET /api/keygen
func (c *Client) KeygenGenerateKey(ctx context.Context, options ...RequestOption) (KeygenGenerateKeyRes, error) {
	res, err := c.sendKeygenGenerateKey(ctx, options...)
	return res, err
}

func (c *Client) sendKeygenGenerateKey(ctx context.Context, requestOptions ...RequestOption) (res KeygenGenerateKeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Keygen_generateKey"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/keygen"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, KeygenGenerateKeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/keygen"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, KeygenGenerateKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeKeygenGenerateKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesBulkNodesActions invokes Nodes_bulkNodesActions operation.
//
// Perform actions for many nodes.
//
// POST /api/nodes/bulk-actions
func (c *Client) NodesBulkNodesActions(ctx context.Context, request *BulkNodesActionsRequest, options ...RequestOption) (NodesBulkNodesActionsRes, error) {
	res, err := c.sendNodesBulkNodesActions(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesBulkNodesActions(ctx context.Context, request *BulkNodesActionsRequest, requestOptions ...RequestOption) (res NodesBulkNodesActionsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_bulkNodesActions"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/bulk-actions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesBulkNodesActionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/bulk-actions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesBulkNodesActionsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesBulkNodesActionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesBulkNodesActionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesCreateNode invokes Nodes_createNode operation.
//
// Create a new node.
//
// POST /api/nodes
func (c *Client) NodesCreateNode(ctx context.Context, request *CreateNodeRequest, options ...RequestOption) (NodesCreateNodeRes, error) {
	res, err := c.sendNodesCreateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesCreateNode(ctx context.Context, request *CreateNodeRequest, requestOptions ...RequestOption) (res NodesCreateNodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_createNode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesCreateNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesCreateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesCreateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesCreateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesDeleteNode invokes Nodes_deleteNode operation.
//
// Delete a node.
//
// DELETE /api/nodes/{uuid}
func (c *Client) NodesDeleteNode(ctx context.Context, params NodesDeleteNodeParams, options ...RequestOption) (NodesDeleteNodeRes, error) {
	res, err := c.sendNodesDeleteNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesDeleteNode(ctx context.Context, params NodesDeleteNodeParams, requestOptions ...RequestOption) (res NodesDeleteNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_deleteNode"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesDeleteNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesDeleteNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesDeleteNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesDisableNode invokes Nodes_disableNode operation.
//
// Disable a node.
//
// POST /api/nodes/{uuid}/actions/disable
func (c *Client) NodesDisableNode(ctx context.Context, params NodesDisableNodeParams, options ...RequestOption) (NodesDisableNodeRes, error) {
	res, err := c.sendNodesDisableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesDisableNode(ctx context.Context, params NodesDisableNodeParams, requestOptions ...RequestOption) (res NodesDisableNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_disableNode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}/actions/disable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesDisableNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesDisableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesDisableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesEnableNode invokes Nodes_enableNode operation.
//
// Enable a node.
//
// POST /api/nodes/{uuid}/actions/enable
func (c *Client) NodesEnableNode(ctx context.Context, params NodesEnableNodeParams, options ...RequestOption) (NodesEnableNodeRes, error) {
	res, err := c.sendNodesEnableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesEnableNode(ctx context.Context, params NodesEnableNodeParams, requestOptions ...RequestOption) (res NodesEnableNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_enableNode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}/actions/enable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesEnableNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesEnableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesEnableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesGetAllNodes invokes Nodes_getAllNodes operation.
//
// Get all nodes.
//
// GET /api/nodes
func (c *Client) NodesGetAllNodes(ctx context.Context, options ...RequestOption) (NodesGetAllNodesRes, error) {
	res, err := c.sendNodesGetAllNodes(ctx, options...)
	return res, err
}

func (c *Client) sendNodesGetAllNodes(ctx context.Context, requestOptions ...RequestOption) (res NodesGetAllNodesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_getAllNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesGetAllNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesGetAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesGetAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesGetAllNodesTags invokes Nodes_getAllNodesTags operation.
//
// Get all existing nodes tags.
//
// GET /api/nodes/tags
func (c *Client) NodesGetAllNodesTags(ctx context.Context, options ...RequestOption) (NodesGetAllNodesTagsRes, error) {
	res, err := c.sendNodesGetAllNodesTags(ctx, options...)
	return res, err
}

func (c *Client) sendNodesGetAllNodesTags(ctx context.Context, requestOptions ...RequestOption) (res NodesGetAllNodesTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_getAllNodesTags"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/nodes/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesGetAllNodesTagsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesGetAllNodesTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesGetAllNodesTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesGetOneNode invokes Nodes_getOneNode operation.
//
// Get node by UUID.
//
// GET /api/nodes/{uuid}
func (c *Client) NodesGetOneNode(ctx context.Context, params NodesGetOneNodeParams, options ...RequestOption) (NodesGetOneNodeRes, error) {
	res, err := c.sendNodesGetOneNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesGetOneNode(ctx context.Context, params NodesGetOneNodeParams, requestOptions ...RequestOption) (res NodesGetOneNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_getOneNode"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesGetOneNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesGetOneNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesGetOneNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesProfileModification invokes Nodes_profileModification operation.
//
// Modify Inbounds & Profile for many nodes.
//
// POST /api/nodes/bulk-actions/profile-modification
func (c *Client) NodesProfileModification(ctx context.Context, request *ProfileModificationRequest, options ...RequestOption) (NodesProfileModificationRes, error) {
	res, err := c.sendNodesProfileModification(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesProfileModification(ctx context.Context, request *ProfileModificationRequest, requestOptions ...RequestOption) (res NodesProfileModificationRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_profileModification"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/bulk-actions/profile-modification"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesProfileModificationOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/bulk-actions/profile-modification"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesProfileModificationRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesProfileModificationOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesProfileModificationResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesReorderNodes invokes Nodes_reorderNodes operation.
//
// Reorder nodes.
//
// POST /api/nodes/actions/reorder
func (c *Client) NodesReorderNodes(ctx context.Context, request *ReorderNodeRequest, options ...RequestOption) (NodesReorderNodesRes, error) {
	res, err := c.sendNodesReorderNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesReorderNodes(ctx context.Context, request *ReorderNodeRequest, requestOptions ...RequestOption) (res NodesReorderNodesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_reorderNodes"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesReorderNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesReorderNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesReorderNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesReorderNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesResetNodeTraffic invokes Nodes_resetNodeTraffic operation.
//
// Reset Node Traffic.
//
// POST /api/nodes/{uuid}/actions/reset-traffic
func (c *Client) NodesResetNodeTraffic(ctx context.Context, params NodesResetNodeTrafficParams, options ...RequestOption) (NodesResetNodeTrafficRes, error) {
	res, err := c.sendNodesResetNodeTraffic(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesResetNodeTraffic(ctx context.Context, params NodesResetNodeTrafficParams, requestOptions ...RequestOption) (res NodesResetNodeTrafficRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_resetNodeTraffic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}/actions/reset-traffic"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesResetNodeTrafficOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesResetNodeTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesResetNodeTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesRestartAllNodes invokes Nodes_restartAllNodes operation.
//
// Restart all nodes.
//
// POST /api/nodes/actions/restart-all
func (c *Client) NodesRestartAllNodes(ctx context.Context, request *RestartAllNodesRequestBody, options ...RequestOption) (NodesRestartAllNodesRes, error) {
	res, err := c.sendNodesRestartAllNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesRestartAllNodes(ctx context.Context, request *RestartAllNodesRequestBody, requestOptions ...RequestOption) (res NodesRestartAllNodesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_restartAllNodes"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/actions/restart-all"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesRestartAllNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/restart-all"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesRestartAllNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesRestartAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesRestartAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesRestartNode invokes Nodes_restartNode operation.
//
// Restart node.
//
// POST /api/nodes/{uuid}/actions/restart
func (c *Client) NodesRestartNode(ctx context.Context, params NodesRestartNodeParams, options ...RequestOption) (NodesRestartNodeRes, error) {
	res, err := c.sendNodesRestartNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesRestartNode(ctx context.Context, params NodesRestartNodeParams, requestOptions ...RequestOption) (res NodesRestartNodeRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_restartNode"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/nodes/{uuid}/actions/restart"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesRestartNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/restart"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesRestartNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesRestartNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUpdateNode invokes Nodes_updateNode operation.
//
// Update node.
//
// PATCH /api/nodes
func (c *Client) NodesUpdateNode(ctx context.Context, request *UpdateNodeRequest, options ...RequestOption) (NodesUpdateNodeRes, error) {
	res, err := c.sendNodesUpdateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesUpdateNode(ctx context.Context, request *UpdateNodeRequest, requestOptions ...RequestOption) (res NodesUpdateNodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Nodes_updateNode"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesUpdateNodeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesUpdateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesUpdateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesUpdateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUsageHistoryGetStatsNodesUsage invokes NodesUsageHistory_getStatsNodesUsage operation.
//
// Get Nodes Usage by Range.
//
// GET /api/bandwidth-stats/nodes
func (c *Client) NodesUsageHistoryGetStatsNodesUsage(ctx context.Context, params NodesUsageHistoryGetStatsNodesUsageParams, options ...RequestOption) (NodesUsageHistoryGetStatsNodesUsageRes, error) {
	res, err := c.sendNodesUsageHistoryGetStatsNodesUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesUsageHistoryGetStatsNodesUsage(ctx context.Context, params NodesUsageHistoryGetStatsNodesUsageParams, requestOptions ...RequestOption) (res NodesUsageHistoryGetStatsNodesUsageRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("NodesUsageHistory_getStatsNodesUsage"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/bandwidth-stats/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, NodesUsageHistoryGetStatsNodesUsageOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/bandwidth-stats/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "topNodesLimit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "topNodesLimit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.IntToString(params.TopNodesLimit))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, NodesUsageHistoryGetStatsNodesUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeNodesUsageHistoryGetStatsNodesUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PasskeyDeletePasskey invokes Passkey_deletePasskey operation.
//
// Delete a passkey by ID.
//
// DELETE /api/passkeys
func (c *Client) PasskeyDeletePasskey(ctx context.Context, request *DeletePasskeyRequest, options ...RequestOption) (PasskeyDeletePasskeyRes, error) {
	res, err := c.sendPasskeyDeletePasskey(ctx, request, options...)
	return res, err
}

func (c *Client) sendPasskeyDeletePasskey(ctx context.Context, request *DeletePasskeyRequest, requestOptions ...RequestOption) (res PasskeyDeletePasskeyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Passkey_deletePasskey"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/passkeys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PasskeyDeletePasskeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/passkeys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePasskeyDeletePasskeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, PasskeyDeletePasskeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodePasskeyDeletePasskeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PasskeyGetActivePasskeys invokes Passkey_getActivePasskeys operation.
//
// Get all passkeys.
//
// GET /api/passkeys
func (c *Client) PasskeyGetActivePasskeys(ctx context.Context, options ...RequestOption) (PasskeyGetActivePasskeysRes, error) {
	res, err := c.sendPasskeyGetActivePasskeys(ctx, options...)
	return res, err
}

func (c *Client) sendPasskeyGetActivePasskeys(ctx context.Context, requestOptions ...RequestOption) (res PasskeyGetActivePasskeysRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Passkey_getActivePasskeys"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/passkeys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PasskeyGetActivePasskeysOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/passkeys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, PasskeyGetActivePasskeysOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodePasskeyGetActivePasskeysResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PasskeyPasskeyRegistrationOptions invokes Passkey_passkeyRegistrationOptions operation.
//
// Get registration options for passkey.
//
// GET /api/passkeys/registration/options
func (c *Client) PasskeyPasskeyRegistrationOptions(ctx context.Context, options ...RequestOption) (PasskeyPasskeyRegistrationOptionsRes, error) {
	res, err := c.sendPasskeyPasskeyRegistrationOptions(ctx, options...)
	return res, err
}

func (c *Client) sendPasskeyPasskeyRegistrationOptions(ctx context.Context, requestOptions ...RequestOption) (res PasskeyPasskeyRegistrationOptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Passkey_passkeyRegistrationOptions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/passkeys/registration/options"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PasskeyPasskeyRegistrationOptionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/passkeys/registration/options"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, PasskeyPasskeyRegistrationOptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodePasskeyPasskeyRegistrationOptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PasskeyPasskeyRegistrationVerify invokes Passkey_passkeyRegistrationVerify operation.
//
// Verify registration for passkey.
//
// POST /api/passkeys/registration/verify
func (c *Client) PasskeyPasskeyRegistrationVerify(ctx context.Context, request *PasskeyOptions, options ...RequestOption) (PasskeyPasskeyRegistrationVerifyRes, error) {
	res, err := c.sendPasskeyPasskeyRegistrationVerify(ctx, request, options...)
	return res, err
}

func (c *Client) sendPasskeyPasskeyRegistrationVerify(ctx context.Context, request *PasskeyOptions, requestOptions ...RequestOption) (res PasskeyPasskeyRegistrationVerifyRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Passkey_passkeyRegistrationVerify"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/passkeys/registration/verify"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PasskeyPasskeyRegistrationVerifyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/passkeys/registration/verify"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePasskeyPasskeyRegistrationVerifyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, PasskeyPasskeyRegistrationVerifyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodePasskeyPasskeyRegistrationVerifyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PasskeyUpdatePasskey invokes Passkey_updatePasskey operation.
//
// Update passkey.
//
// PATCH /api/passkeys
func (c *Client) PasskeyUpdatePasskey(ctx context.Context, request *UpdatePasskeyRequest, options ...RequestOption) (PasskeyUpdatePasskeyRes, error) {
	res, err := c.sendPasskeyUpdatePasskey(ctx, request, options...)
	return res, err
}

func (c *Client) sendPasskeyUpdatePasskey(ctx context.Context, request *UpdatePasskeyRequest, requestOptions ...RequestOption) (res PasskeyUpdatePasskeyRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Passkey_updatePasskey"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/passkeys"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, PasskeyUpdatePasskeyOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/passkeys"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodePasskeyUpdatePasskeyRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, PasskeyUpdatePasskeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodePasskeyUpdatePasskeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemnawaveSettingsGetSettings invokes RemnawaveSettings_getSettings operation.
//
// Get Remnawave settings.
//
// GET /api/remnawave-settings
func (c *Client) RemnawaveSettingsGetSettings(ctx context.Context, options ...RequestOption) (RemnawaveSettingsGetSettingsRes, error) {
	res, err := c.sendRemnawaveSettingsGetSettings(ctx, options...)
	return res, err
}

func (c *Client) sendRemnawaveSettingsGetSettings(ctx context.Context, requestOptions ...RequestOption) (res RemnawaveSettingsGetSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("RemnawaveSettings_getSettings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/remnawave-settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemnawaveSettingsGetSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/remnawave-settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, RemnawaveSettingsGetSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeRemnawaveSettingsGetSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// RemnawaveSettingsUpdateSettings invokes RemnawaveSettings_updateSettings operation.
//
// Update Remnawave settings.
//
// PATCH /api/remnawave-settings
func (c *Client) RemnawaveSettingsUpdateSettings(ctx context.Context, request *UpdateRemnawaveSettingsRequest, options ...RequestOption) (RemnawaveSettingsUpdateSettingsRes, error) {
	res, err := c.sendRemnawaveSettingsUpdateSettings(ctx, request, options...)
	return res, err
}

func (c *Client) sendRemnawaveSettingsUpdateSettings(ctx context.Context, request *UpdateRemnawaveSettingsRequest, requestOptions ...RequestOption) (res RemnawaveSettingsUpdateSettingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("RemnawaveSettings_updateSettings"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/remnawave-settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, RemnawaveSettingsUpdateSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/remnawave-settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeRemnawaveSettingsUpdateSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, RemnawaveSettingsUpdateSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeRemnawaveSettingsUpdateSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SnippetsCreateSnippet invokes Snippets_createSnippet operation.
//
// Create snippet.
//
// POST /api/snippets
func (c *Client) SnippetsCreateSnippet(ctx context.Context, request *SnippetRequest, options ...RequestOption) (SnippetsCreateSnippetRes, error) {
	res, err := c.sendSnippetsCreateSnippet(ctx, request, options...)
	return res, err
}

func (c *Client) sendSnippetsCreateSnippet(ctx context.Context, request *SnippetRequest, requestOptions ...RequestOption) (res SnippetsCreateSnippetRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Snippets_createSnippet"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/snippets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SnippetsCreateSnippetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/snippets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSnippetsCreateSnippetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SnippetsCreateSnippetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSnippetsCreateSnippetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SnippetsDeleteSnippetByName invokes Snippets_deleteSnippetByName operation.
//
// Delete snippet.
//
// DELETE /api/snippets
func (c *Client) SnippetsDeleteSnippetByName(ctx context.Context, request *DeleteSnippetRequest, options ...RequestOption) (SnippetsDeleteSnippetByNameRes, error) {
	res, err := c.sendSnippetsDeleteSnippetByName(ctx, request, options...)
	return res, err
}

func (c *Client) sendSnippetsDeleteSnippetByName(ctx context.Context, request *DeleteSnippetRequest, requestOptions ...RequestOption) (res SnippetsDeleteSnippetByNameRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Snippets_deleteSnippetByName"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/snippets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SnippetsDeleteSnippetByNameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/snippets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSnippetsDeleteSnippetByNameRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SnippetsDeleteSnippetByNameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSnippetsDeleteSnippetByNameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SnippetsGetSnippets invokes Snippets_getSnippets operation.
//
// Get snippets.
//
// GET /api/snippets
func (c *Client) SnippetsGetSnippets(ctx context.Context, options ...RequestOption) (SnippetsGetSnippetsRes, error) {
	res, err := c.sendSnippetsGetSnippets(ctx, options...)
	return res, err
}

func (c *Client) sendSnippetsGetSnippets(ctx context.Context, requestOptions ...RequestOption) (res SnippetsGetSnippetsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Snippets_getSnippets"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/snippets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SnippetsGetSnippetsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/snippets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SnippetsGetSnippetsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSnippetsGetSnippetsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SnippetsUpdateSnippet invokes Snippets_updateSnippet operation.
//
// Update snippet.
//
// PATCH /api/snippets
func (c *Client) SnippetsUpdateSnippet(ctx context.Context, request *SnippetRequest, options ...RequestOption) (SnippetsUpdateSnippetRes, error) {
	res, err := c.sendSnippetsUpdateSnippet(ctx, request, options...)
	return res, err
}

func (c *Client) sendSnippetsUpdateSnippet(ctx context.Context, request *SnippetRequest, requestOptions ...RequestOption) (res SnippetsUpdateSnippetRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Snippets_updateSnippet"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/snippets"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SnippetsUpdateSnippetOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/snippets"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSnippetsUpdateSnippetRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SnippetsUpdateSnippetOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSnippetsUpdateSnippetResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionGetSubscription invokes Subscription_getSubscription operation.
//
// GET /api/sub/{shortUuid}
func (c *Client) SubscriptionGetSubscription(ctx context.Context, params SubscriptionGetSubscriptionParams, options ...RequestOption) (SubscriptionGetSubscriptionOK, error) {
	res, err := c.sendSubscriptionGetSubscription(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionGetSubscription(ctx context.Context, params SubscriptionGetSubscriptionParams, requestOptions ...RequestOption) (res SubscriptionGetSubscriptionOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscription_getSubscription"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/sub/{shortUuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionGetSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionGetSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionGetSubscriptionByClientType invokes Subscription_getSubscriptionByClientType operation.
//
// GET /api/sub/{shortUuid}/{clientType}
func (c *Client) SubscriptionGetSubscriptionByClientType(ctx context.Context, params SubscriptionGetSubscriptionByClientTypeParams, options ...RequestOption) (SubscriptionGetSubscriptionByClientTypeOK, error) {
	res, err := c.sendSubscriptionGetSubscriptionByClientType(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionGetSubscriptionByClientType(ctx context.Context, params SubscriptionGetSubscriptionByClientTypeParams, requestOptions ...RequestOption) (res SubscriptionGetSubscriptionByClientTypeOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscription_getSubscriptionByClientType"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/sub/{shortUuid}/{clientType}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionGetSubscriptionByClientTypeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "clientType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.ClientType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionGetSubscriptionByClientTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionGetSubscriptionInfoByShortUuid invokes Subscription_getSubscriptionInfoByShortUuid operation.
//
// Get Subscription Info by Short UUID.
//
// GET /api/sub/{shortUuid}/info
func (c *Client) SubscriptionGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (SubscriptionGetSubscriptionInfoByShortUuidRes, error) {
	res, err := c.sendSubscriptionGetSubscriptionInfoByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionGetSubscriptionInfoByShortUuidParams, requestOptions ...RequestOption) (res SubscriptionGetSubscriptionInfoByShortUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscription_getSubscriptionInfoByShortUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/sub/{shortUuid}/info"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionGetSubscriptionInfoByShortUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/info"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionGetSubscriptionInfoByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionGetSubscriptionWithType invokes Subscription_getSubscriptionWithType operation.
//
// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
func (c *Client) SubscriptionGetSubscriptionWithType(ctx context.Context, params SubscriptionGetSubscriptionWithTypeParams, options ...RequestOption) (SubscriptionGetSubscriptionWithTypeOK, error) {
	res, err := c.sendSubscriptionGetSubscriptionWithType(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionGetSubscriptionWithType(ctx context.Context, params SubscriptionGetSubscriptionWithTypeParams, requestOptions ...RequestOption) (res SubscriptionGetSubscriptionWithTypeOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscription_getSubscriptionWithType"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/sub/outline/{shortUuid}/{type}/{encodedTag}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionGetSubscriptionWithTypeOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [6]string
	pathParts[0] = "/api/sub/outline/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "encodedTag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encodedTag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncodedTag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionGetSubscriptionWithTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigCloneSubscriptionPageConfig invokes SubscriptionPageConfig_cloneSubscriptionPageConfig operation.
//
// Clone subscription page config.
//
// POST /api/subscription-page-configs/actions/clone
func (c *Client) SubscriptionPageConfigCloneSubscriptionPageConfig(ctx context.Context, request *CloneSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigCloneSubscriptionPageConfigRes, error) {
	res, err := c.sendSubscriptionPageConfigCloneSubscriptionPageConfig(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigCloneSubscriptionPageConfig(ctx context.Context, request *CloneSubscriptionPageConfigRequest, requestOptions ...RequestOption) (res SubscriptionPageConfigCloneSubscriptionPageConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_cloneSubscriptionPageConfig"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs/actions/clone"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigCloneSubscriptionPageConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-page-configs/actions/clone"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionPageConfigCloneSubscriptionPageConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigCloneSubscriptionPageConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigCloneSubscriptionPageConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigCreateConfig invokes SubscriptionPageConfig_createConfig operation.
//
// Create subscription page config.
//
// POST /api/subscription-page-configs
func (c *Client) SubscriptionPageConfigCreateConfig(ctx context.Context, request *CreateSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigCreateConfigRes, error) {
	res, err := c.sendSubscriptionPageConfigCreateConfig(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigCreateConfig(ctx context.Context, request *CreateSubscriptionPageConfigRequest, requestOptions ...RequestOption) (res SubscriptionPageConfigCreateConfigRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_createConfig"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigCreateConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-page-configs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionPageConfigCreateConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigCreateConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigCreateConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigDeleteConfig invokes SubscriptionPageConfig_deleteConfig operation.
//
// Delete subscription page config.
//
// DELETE /api/subscription-page-configs/{uuid}
func (c *Client) SubscriptionPageConfigDeleteConfig(ctx context.Context, params SubscriptionPageConfigDeleteConfigParams, options ...RequestOption) (SubscriptionPageConfigDeleteConfigRes, error) {
	res, err := c.sendSubscriptionPageConfigDeleteConfig(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigDeleteConfig(ctx context.Context, params SubscriptionPageConfigDeleteConfigParams, requestOptions ...RequestOption) (res SubscriptionPageConfigDeleteConfigRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_deleteConfig"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigDeleteConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-page-configs/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigDeleteConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigDeleteConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigGetAllConfigs invokes SubscriptionPageConfig_getAllConfigs operation.
//
// Get all subscription page configs.
//
// GET /api/subscription-page-configs
func (c *Client) SubscriptionPageConfigGetAllConfigs(ctx context.Context, options ...RequestOption) (SubscriptionPageConfigGetAllConfigsRes, error) {
	res, err := c.sendSubscriptionPageConfigGetAllConfigs(ctx, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigGetAllConfigs(ctx context.Context, requestOptions ...RequestOption) (res SubscriptionPageConfigGetAllConfigsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_getAllConfigs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigGetAllConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-page-configs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigGetAllConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigGetAllConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigGetConfigByUuid invokes SubscriptionPageConfig_getConfigByUuid operation.
//
// Get subscription page config by uuid.
//
// GET /api/subscription-page-configs/{uuid}
func (c *Client) SubscriptionPageConfigGetConfigByUuid(ctx context.Context, params SubscriptionPageConfigGetConfigByUuidParams, options ...RequestOption) (SubscriptionPageConfigGetConfigByUuidRes, error) {
	res, err := c.sendSubscriptionPageConfigGetConfigByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigGetConfigByUuid(ctx context.Context, params SubscriptionPageConfigGetConfigByUuidParams, requestOptions ...RequestOption) (res SubscriptionPageConfigGetConfigByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_getConfigByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigGetConfigByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-page-configs/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigGetConfigByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigGetConfigByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigReorderSubscriptionPageConfigs invokes SubscriptionPageConfig_reorderSubscriptionPageConfigs operation.
//
// Reorder subscription page configs.
//
// POST /api/subscription-page-configs/actions/reorder
func (c *Client) SubscriptionPageConfigReorderSubscriptionPageConfigs(ctx context.Context, request *ReorderRequest, options ...RequestOption) (SubscriptionPageConfigReorderSubscriptionPageConfigsRes, error) {
	res, err := c.sendSubscriptionPageConfigReorderSubscriptionPageConfigs(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigReorderSubscriptionPageConfigs(ctx context.Context, request *ReorderRequest, requestOptions ...RequestOption) (res SubscriptionPageConfigReorderSubscriptionPageConfigsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_reorderSubscriptionPageConfigs"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigReorderSubscriptionPageConfigsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-page-configs/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionPageConfigReorderSubscriptionPageConfigsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigReorderSubscriptionPageConfigsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigReorderSubscriptionPageConfigsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionPageConfigUpdateConfig invokes SubscriptionPageConfig_updateConfig operation.
//
// Update subscription page config.
//
// PATCH /api/subscription-page-configs
func (c *Client) SubscriptionPageConfigUpdateConfig(ctx context.Context, request *UpdateSubscriptionPageConfigRequest, options ...RequestOption) (SubscriptionPageConfigUpdateConfigRes, error) {
	res, err := c.sendSubscriptionPageConfigUpdateConfig(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionPageConfigUpdateConfig(ctx context.Context, request *UpdateSubscriptionPageConfigRequest, requestOptions ...RequestOption) (res SubscriptionPageConfigUpdateConfigRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionPageConfig_updateConfig"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/subscription-page-configs"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionPageConfigUpdateConfigOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-page-configs"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionPageConfigUpdateConfigRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionPageConfigUpdateConfigOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionPageConfigUpdateConfigResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsGetSettings invokes SubscriptionSettings_getSettings operation.
//
// Get subscription settings.
//
// GET /api/subscription-settings
func (c *Client) SubscriptionSettingsGetSettings(ctx context.Context, options ...RequestOption) (SubscriptionSettingsGetSettingsRes, error) {
	res, err := c.sendSubscriptionSettingsGetSettings(ctx, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsGetSettings(ctx context.Context, requestOptions ...RequestOption) (res SubscriptionSettingsGetSettingsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionSettings_getSettings"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionSettingsGetSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionSettingsGetSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionSettingsGetSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsUpdateSettings invokes SubscriptionSettings_updateSettings operation.
//
// Update subscription settings.
//
// PATCH /api/subscription-settings
func (c *Client) SubscriptionSettingsUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequest, options ...RequestOption) (SubscriptionSettingsUpdateSettingsRes, error) {
	res, err := c.sendSubscriptionSettingsUpdateSettings(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequest, requestOptions ...RequestOption) (res SubscriptionSettingsUpdateSettingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionSettings_updateSettings"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/subscription-settings"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionSettingsUpdateSettingsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionSettingsUpdateSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionSettingsUpdateSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionSettingsUpdateSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateCreateTemplate invokes SubscriptionTemplate_createTemplate operation.
//
// Create subscription template.
//
// POST /api/subscription-templates
func (c *Client) SubscriptionTemplateCreateTemplate(ctx context.Context, request *CreateSubscriptionTemplateRequest, options ...RequestOption) (SubscriptionTemplateCreateTemplateRes, error) {
	res, err := c.sendSubscriptionTemplateCreateTemplate(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateCreateTemplate(ctx context.Context, request *CreateSubscriptionTemplateRequest, requestOptions ...RequestOption) (res SubscriptionTemplateCreateTemplateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_createTemplate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/subscription-templates"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateCreateTemplateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionTemplateCreateTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateCreateTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateCreateTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateDeleteTemplate invokes SubscriptionTemplate_deleteTemplate operation.
//
// Delete subscription template.
//
// DELETE /api/subscription-templates/{uuid}
func (c *Client) SubscriptionTemplateDeleteTemplate(ctx context.Context, params SubscriptionTemplateDeleteTemplateParams, options ...RequestOption) (SubscriptionTemplateDeleteTemplateRes, error) {
	res, err := c.sendSubscriptionTemplateDeleteTemplate(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateDeleteTemplate(ctx context.Context, params SubscriptionTemplateDeleteTemplateParams, requestOptions ...RequestOption) (res SubscriptionTemplateDeleteTemplateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_deleteTemplate"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/subscription-templates/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateDeleteTemplateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-templates/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateDeleteTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateDeleteTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateGetAllTemplates invokes SubscriptionTemplate_getAllTemplates operation.
//
// Get all subscription templates (wihout content).
//
// GET /api/subscription-templates
func (c *Client) SubscriptionTemplateGetAllTemplates(ctx context.Context, options ...RequestOption) (SubscriptionTemplateGetAllTemplatesRes, error) {
	res, err := c.sendSubscriptionTemplateGetAllTemplates(ctx, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateGetAllTemplates(ctx context.Context, requestOptions ...RequestOption) (res SubscriptionTemplateGetAllTemplatesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_getAllTemplates"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-templates"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateGetAllTemplatesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateGetAllTemplatesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateGetAllTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateGetTemplateByUuid invokes SubscriptionTemplate_getTemplateByUuid operation.
//
// Get subscription template by uuid.
//
// GET /api/subscription-templates/{uuid}
func (c *Client) SubscriptionTemplateGetTemplateByUuid(ctx context.Context, params SubscriptionTemplateGetTemplateByUuidParams, options ...RequestOption) (SubscriptionTemplateGetTemplateByUuidRes, error) {
	res, err := c.sendSubscriptionTemplateGetTemplateByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateGetTemplateByUuid(ctx context.Context, params SubscriptionTemplateGetTemplateByUuidParams, requestOptions ...RequestOption) (res SubscriptionTemplateGetTemplateByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_getTemplateByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-templates/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateGetTemplateByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-templates/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateGetTemplateByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateGetTemplateByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateReorderSubscriptionTemplates invokes SubscriptionTemplate_reorderSubscriptionTemplates operation.
//
// Reorder subscription templates.
//
// POST /api/subscription-templates/actions/reorder
func (c *Client) SubscriptionTemplateReorderSubscriptionTemplates(ctx context.Context, request *ReorderRequest, options ...RequestOption) (SubscriptionTemplateReorderSubscriptionTemplatesRes, error) {
	res, err := c.sendSubscriptionTemplateReorderSubscriptionTemplates(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateReorderSubscriptionTemplates(ctx context.Context, request *ReorderRequest, requestOptions ...RequestOption) (res SubscriptionTemplateReorderSubscriptionTemplatesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_reorderSubscriptionTemplates"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/subscription-templates/actions/reorder"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateReorderSubscriptionTemplatesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionTemplateReorderSubscriptionTemplatesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateReorderSubscriptionTemplatesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateReorderSubscriptionTemplatesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateUpdateTemplate invokes SubscriptionTemplate_updateTemplate operation.
//
// Update subscription template.
//
// PATCH /api/subscription-templates
func (c *Client) SubscriptionTemplateUpdateTemplate(ctx context.Context, request *UpdateTemplateRequest, options ...RequestOption) (SubscriptionTemplateUpdateTemplateRes, error) {
	res, err := c.sendSubscriptionTemplateUpdateTemplate(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateUpdateTemplate(ctx context.Context, request *UpdateTemplateRequest, requestOptions ...RequestOption) (res SubscriptionTemplateUpdateTemplateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("SubscriptionTemplate_updateTemplate"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/subscription-templates"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionTemplateUpdateTemplateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionTemplateUpdateTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionTemplateUpdateTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionTemplateUpdateTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetAllSubscriptions invokes Subscriptions_getAllSubscriptions operation.
//
// Get all subscriptions.
//
// GET /api/subscriptions
func (c *Client) SubscriptionsGetAllSubscriptions(ctx context.Context, params SubscriptionsGetAllSubscriptionsParams, options ...RequestOption) (SubscriptionsGetAllSubscriptionsRes, error) {
	res, err := c.sendSubscriptionsGetAllSubscriptions(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetAllSubscriptions(ctx context.Context, params SubscriptionsGetAllSubscriptionsParams, requestOptions ...RequestOption) (res SubscriptionsGetAllSubscriptionsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getAllSubscriptions"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetAllSubscriptionsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetAllSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetAllSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetRawSubscriptionByShortUuid invokes Subscriptions_getRawSubscriptionByShortUuid operation.
//
// Get Raw Subscription by Short UUID.
//
// GET /api/subscriptions/by-short-uuid/{shortUuid}/raw
func (c *Client) SubscriptionsGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionsGetRawSubscriptionByShortUuidParams, options ...RequestOption) (SubscriptionsGetRawSubscriptionByShortUuidRes, error) {
	res, err := c.sendSubscriptionsGetRawSubscriptionByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionsGetRawSubscriptionByShortUuidParams, requestOptions ...RequestOption) (res SubscriptionsGetRawSubscriptionByShortUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getRawSubscriptionByShortUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions/by-short-uuid/{shortUuid}/raw"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetRawSubscriptionByShortUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/subscriptions/by-short-uuid/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/raw"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "withDisabledHosts" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "withDisabledHosts",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithDisabledHosts.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetRawSubscriptionByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetRawSubscriptionByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetSubpageConfigByShortUuid invokes Subscriptions_getSubpageConfigByShortUuid operation.
//
// Get Subpage Config by Short UUID.
//
// GET /api/subscriptions/subpage-config/{shortUuid}
func (c *Client) SubscriptionsGetSubpageConfigByShortUuid(ctx context.Context, request *GetSubpageConfigByShortUuidRequestBody, params SubscriptionsGetSubpageConfigByShortUuidParams, options ...RequestOption) (SubscriptionsGetSubpageConfigByShortUuidRes, error) {
	res, err := c.sendSubscriptionsGetSubpageConfigByShortUuid(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetSubpageConfigByShortUuid(ctx context.Context, request *GetSubpageConfigByShortUuidRequestBody, params SubscriptionsGetSubpageConfigByShortUuidParams, requestOptions ...RequestOption) (res SubscriptionsGetSubpageConfigByShortUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getSubpageConfigByShortUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions/subpage-config/{shortUuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetSubpageConfigByShortUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/subpage-config/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionsGetSubpageConfigByShortUuidRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetSubpageConfigByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetSubpageConfigByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetSubscriptionByShortUuidProtected invokes Subscriptions_getSubscriptionByShortUuidProtected operation.
//
// Get subscription by short uuid (protected route).
//
// GET /api/subscriptions/by-short-uuid/{shortUuid}
func (c *Client) SubscriptionsGetSubscriptionByShortUuidProtected(ctx context.Context, params SubscriptionsGetSubscriptionByShortUuidProtectedParams, options ...RequestOption) (SubscriptionsGetSubscriptionByShortUuidProtectedRes, error) {
	res, err := c.sendSubscriptionsGetSubscriptionByShortUuidProtected(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetSubscriptionByShortUuidProtected(ctx context.Context, params SubscriptionsGetSubscriptionByShortUuidProtectedParams, requestOptions ...RequestOption) (res SubscriptionsGetSubscriptionByShortUuidProtectedRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getSubscriptionByShortUuidProtected"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions/by-short-uuid/{shortUuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetSubscriptionByShortUuidProtectedOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/by-short-uuid/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetSubscriptionByShortUuidProtectedOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetSubscriptionByShortUuidProtectedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetSubscriptionByUsername invokes Subscriptions_getSubscriptionByUsername operation.
//
// Get subscription by username.
//
// GET /api/subscriptions/by-username/{username}
func (c *Client) SubscriptionsGetSubscriptionByUsername(ctx context.Context, params SubscriptionsGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsGetSubscriptionByUsernameRes, error) {
	res, err := c.sendSubscriptionsGetSubscriptionByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetSubscriptionByUsername(ctx context.Context, params SubscriptionsGetSubscriptionByUsernameParams, requestOptions ...RequestOption) (res SubscriptionsGetSubscriptionByUsernameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getSubscriptionByUsername"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions/by-username/{username}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetSubscriptionByUsernameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetSubscriptionByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetSubscriptionByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsGetSubscriptionByUuid invokes Subscriptions_getSubscriptionByUuid operation.
//
// Get subscription by uuid.
//
// GET /api/subscriptions/by-uuid/{uuid}
func (c *Client) SubscriptionsGetSubscriptionByUuid(ctx context.Context, params SubscriptionsGetSubscriptionByUuidParams, options ...RequestOption) (SubscriptionsGetSubscriptionByUuidRes, error) {
	res, err := c.sendSubscriptionsGetSubscriptionByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsGetSubscriptionByUuid(ctx context.Context, params SubscriptionsGetSubscriptionByUuidParams, requestOptions ...RequestOption) (res SubscriptionsGetSubscriptionByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Subscriptions_getSubscriptionByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscriptions/by-uuid/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SubscriptionsGetSubscriptionByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/by-uuid/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SubscriptionsGetSubscriptionByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSubscriptionsGetSubscriptionByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemDebugSrrMatcher invokes System_debugSrrMatcher operation.
//
// Test SRR Matcher.
//
// POST /api/system/testers/srr-matcher
func (c *Client) SystemDebugSrrMatcher(ctx context.Context, request *DebugSrrMatcherRequest, options ...RequestOption) (SystemDebugSrrMatcherRes, error) {
	res, err := c.sendSystemDebugSrrMatcher(ctx, request, options...)
	return res, err
}

func (c *Client) sendSystemDebugSrrMatcher(ctx context.Context, request *DebugSrrMatcherRequest, requestOptions ...RequestOption) (res SystemDebugSrrMatcherRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_debugSrrMatcher"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/system/testers/srr-matcher"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemDebugSrrMatcherOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/testers/srr-matcher"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSystemDebugSrrMatcherRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemDebugSrrMatcherOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemDebugSrrMatcherResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemEncryptHappCryptoLink invokes System_encryptHappCryptoLink operation.
//
// Encrypt Happ Crypto Link.
//
// POST /api/system/tools/happ/encrypt
func (c *Client) SystemEncryptHappCryptoLink(ctx context.Context, request *EncryptHappCryptoLinkRequest, options ...RequestOption) (SystemEncryptHappCryptoLinkRes, error) {
	res, err := c.sendSystemEncryptHappCryptoLink(ctx, request, options...)
	return res, err
}

func (c *Client) sendSystemEncryptHappCryptoLink(ctx context.Context, request *EncryptHappCryptoLinkRequest, requestOptions ...RequestOption) (res SystemEncryptHappCryptoLinkRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_encryptHappCryptoLink"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/system/tools/happ/encrypt"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemEncryptHappCryptoLinkOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/tools/happ/encrypt"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSystemEncryptHappCryptoLinkRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemEncryptHappCryptoLinkOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemEncryptHappCryptoLinkResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetBandwidthStats invokes System_getBandwidthStats operation.
//
// Get Bandwidth Stats.
//
// GET /api/system/stats/bandwidth
func (c *Client) SystemGetBandwidthStats(ctx context.Context, options ...RequestOption) (SystemGetBandwidthStatsRes, error) {
	res, err := c.sendSystemGetBandwidthStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetBandwidthStats(ctx context.Context, requestOptions ...RequestOption) (res SystemGetBandwidthStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getBandwidthStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/stats/bandwidth"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetBandwidthStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/bandwidth"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetBandwidthStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetBandwidthStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetMetadata invokes System_getMetadata operation.
//
// Get Remnawave Information.
//
// GET /api/system/metadata
func (c *Client) SystemGetMetadata(ctx context.Context, options ...RequestOption) (SystemGetMetadataRes, error) {
	res, err := c.sendSystemGetMetadata(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetMetadata(ctx context.Context, requestOptions ...RequestOption) (res SystemGetMetadataRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getMetadata"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/metadata"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetMetadataOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/metadata"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetMetadataOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetMetadataResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetNodesMetrics invokes System_getNodesMetrics operation.
//
// Get Nodes Metrics.
//
// GET /api/system/nodes/metrics
func (c *Client) SystemGetNodesMetrics(ctx context.Context, options ...RequestOption) (SystemGetNodesMetricsRes, error) {
	res, err := c.sendSystemGetNodesMetrics(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetNodesMetrics(ctx context.Context, requestOptions ...RequestOption) (res SystemGetNodesMetricsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getNodesMetrics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/nodes/metrics"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetNodesMetricsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/nodes/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetNodesMetricsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetNodesMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetNodesStatistics invokes System_getNodesStatistics operation.
//
// Get Nodes Statistics.
//
// GET /api/system/stats/nodes
func (c *Client) SystemGetNodesStatistics(ctx context.Context, options ...RequestOption) (SystemGetNodesStatisticsRes, error) {
	res, err := c.sendSystemGetNodesStatistics(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetNodesStatistics(ctx context.Context, requestOptions ...RequestOption) (res SystemGetNodesStatisticsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getNodesStatistics"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/stats/nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetNodesStatisticsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetNodesStatisticsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetNodesStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetRemnawaveHealth invokes System_getRemnawaveHealth operation.
//
// Get Remnawave Health.
//
// GET /api/system/health
func (c *Client) SystemGetRemnawaveHealth(ctx context.Context, options ...RequestOption) (SystemGetRemnawaveHealthRes, error) {
	res, err := c.sendSystemGetRemnawaveHealth(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetRemnawaveHealth(ctx context.Context, requestOptions ...RequestOption) (res SystemGetRemnawaveHealthRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getRemnawaveHealth"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/health"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetRemnawaveHealthOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/health"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetRemnawaveHealthOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetRemnawaveHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetStats invokes System_getStats operation.
//
// Get Stats.
//
// GET /api/system/stats
func (c *Client) SystemGetStats(ctx context.Context, options ...RequestOption) (SystemGetStatsRes, error) {
	res, err := c.sendSystemGetStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetStats(ctx context.Context, requestOptions ...RequestOption) (res SystemGetStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemGetX25519Keypairs invokes System_getX25519Keypairs operation.
//
// Generate 30 X25519 keypairs.
//
// GET /api/system/tools/x25519/generate
func (c *Client) SystemGetX25519Keypairs(ctx context.Context, options ...RequestOption) (SystemGetX25519KeypairsRes, error) {
	res, err := c.sendSystemGetX25519Keypairs(ctx, options...)
	return res, err
}

func (c *Client) sendSystemGetX25519Keypairs(ctx context.Context, requestOptions ...RequestOption) (res SystemGetX25519KeypairsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("System_getX25519Keypairs"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/system/tools/x25519/generate"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, SystemGetX25519KeypairsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/tools/x25519/generate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, SystemGetX25519KeypairsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeSystemGetX25519KeypairsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSubscriptionRequestHistoryGetSubscriptionRequestHistory invokes UserSubscriptionRequestHistory_getSubscriptionRequestHistory operation.
//
// Get all subscription request history.
//
// GET /api/subscription-request-history
func (c *Client) UserSubscriptionRequestHistoryGetSubscriptionRequestHistory(ctx context.Context, params UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryParams, options ...RequestOption) (UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryRes, error) {
	res, err := c.sendUserSubscriptionRequestHistoryGetSubscriptionRequestHistory(ctx, params, options...)
	return res, err
}

func (c *Client) sendUserSubscriptionRequestHistoryGetSubscriptionRequestHistory(ctx context.Context, params UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryParams, requestOptions ...RequestOption) (res UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UserSubscriptionRequestHistory_getSubscriptionRequestHistory"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-request-history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-request-history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUserSubscriptionRequestHistoryGetSubscriptionRequestHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats invokes UserSubscriptionRequestHistory_getSubscriptionRequestHistoryStats operation.
//
// Get subscription request history stats.
//
// GET /api/subscription-request-history/stats
func (c *Client) UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats(ctx context.Context, options ...RequestOption) (UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsRes, error) {
	res, err := c.sendUserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats(ctx, options...)
	return res, err
}

func (c *Client) sendUserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStats(ctx context.Context, requestOptions ...RequestOption) (res UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UserSubscriptionRequestHistory_getSubscriptionRequestHistoryStats"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/subscription-request-history/stats"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-request-history/stats"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUserSubscriptionRequestHistoryGetSubscriptionRequestHistoryStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkAllExtendExpirationDate invokes UsersBulkActions_bulkAllExtendExpirationDate operation.
//
// Bulk extend all users expiration date.
//
// POST /api/users/bulk/all/extend-expiration-date
func (c *Client) UsersBulkActionsBulkAllExtendExpirationDate(ctx context.Context, request *BulkAllExtendExpirationDateRequest, options ...RequestOption) (UsersBulkActionsBulkAllExtendExpirationDateRes, error) {
	res, err := c.sendUsersBulkActionsBulkAllExtendExpirationDate(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkAllExtendExpirationDate(ctx context.Context, request *BulkAllExtendExpirationDateRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkAllExtendExpirationDateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkAllExtendExpirationDate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/all/extend-expiration-date"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkAllExtendExpirationDateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/extend-expiration-date"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkAllExtendExpirationDateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkAllExtendExpirationDateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkAllExtendExpirationDateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkAllResetUserTraffic invokes UsersBulkActions_bulkAllResetUserTraffic operation.
//
// Bulk reset all users traffic.
//
// POST /api/users/bulk/all/reset-traffic
func (c *Client) UsersBulkActionsBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (UsersBulkActionsBulkAllResetUserTrafficRes, error) {
	res, err := c.sendUsersBulkActionsBulkAllResetUserTraffic(ctx, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkAllResetUserTraffic(ctx context.Context, requestOptions ...RequestOption) (res UsersBulkActionsBulkAllResetUserTrafficRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkAllResetUserTraffic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/all/reset-traffic"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkAllResetUserTrafficOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkAllResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkAllResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkDeleteUsers invokes UsersBulkActions_bulkDeleteUsers operation.
//
// Bulk delete users by UUIDs.
//
// POST /api/users/bulk/delete
func (c *Client) UsersBulkActionsBulkDeleteUsers(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkDeleteUsersRes, error) {
	res, err := c.sendUsersBulkActionsBulkDeleteUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkDeleteUsers(ctx context.Context, request *BulkUuidsRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkDeleteUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkDeleteUsers"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/delete"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkDeleteUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkDeleteUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkDeleteUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkDeleteUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkDeleteUsersByStatus invokes UsersBulkActions_bulkDeleteUsersByStatus operation.
//
// Bulk delete users by status.
//
// POST /api/users/bulk/delete-by-status
func (c *Client) UsersBulkActionsBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequest, options ...RequestOption) (UsersBulkActionsBulkDeleteUsersByStatusRes, error) {
	res, err := c.sendUsersBulkActionsBulkDeleteUsersByStatus(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkDeleteUsersByStatusRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkDeleteUsersByStatus"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/delete-by-status"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkDeleteUsersByStatusOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete-by-status"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkDeleteUsersByStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkDeleteUsersByStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkDeleteUsersByStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkExtendExpirationDate invokes UsersBulkActions_bulkExtendExpirationDate operation.
//
// Bulk extend all users expiration date.
//
// POST /api/users/bulk/extend-expiration-date
func (c *Client) UsersBulkActionsBulkExtendExpirationDate(ctx context.Context, request *BulkExtendExpirationDateRequest, options ...RequestOption) (UsersBulkActionsBulkExtendExpirationDateRes, error) {
	res, err := c.sendUsersBulkActionsBulkExtendExpirationDate(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkExtendExpirationDate(ctx context.Context, request *BulkExtendExpirationDateRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkExtendExpirationDateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkExtendExpirationDate"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/extend-expiration-date"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkExtendExpirationDateOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/extend-expiration-date"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkExtendExpirationDateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkExtendExpirationDateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkExtendExpirationDateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkResetUserTraffic invokes UsersBulkActions_bulkResetUserTraffic operation.
//
// Bulk reset traffic users by UUIDs.
//
// POST /api/users/bulk/reset-traffic
func (c *Client) UsersBulkActionsBulkResetUserTraffic(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkResetUserTrafficRes, error) {
	res, err := c.sendUsersBulkActionsBulkResetUserTraffic(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkResetUserTraffic(ctx context.Context, request *BulkUuidsRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkResetUserTrafficRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkResetUserTraffic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/reset-traffic"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkResetUserTrafficOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkResetUserTrafficRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkRevokeUsersSubscription invokes UsersBulkActions_bulkRevokeUsersSubscription operation.
//
// Revoke users subscription by User UUIDs.
//
// POST /api/users/bulk/revoke-subscription
func (c *Client) UsersBulkActionsBulkRevokeUsersSubscription(ctx context.Context, request *BulkUuidsRequest, options ...RequestOption) (UsersBulkActionsBulkRevokeUsersSubscriptionRes, error) {
	res, err := c.sendUsersBulkActionsBulkRevokeUsersSubscription(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkRevokeUsersSubscription(ctx context.Context, request *BulkUuidsRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkRevokeUsersSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkRevokeUsersSubscription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/revoke-subscription"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkRevokeUsersSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/revoke-subscription"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkRevokeUsersSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkRevokeUsersSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkRevokeUsersSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkUpdateAllUsers invokes UsersBulkActions_bulkUpdateAllUsers operation.
//
// Bulk update all users.
//
// POST /api/users/bulk/all/update
func (c *Client) UsersBulkActionsBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateAllUsersRes, error) {
	res, err := c.sendUsersBulkActionsBulkUpdateAllUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkUpdateAllUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkUpdateAllUsers"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/all/update"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkUpdateAllUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkUpdateAllUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkUpdateAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkUpdateAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkUpdateUsers invokes UsersBulkActions_bulkUpdateUsers operation.
//
// Bulk update users by UUIDs.
//
// POST /api/users/bulk/update
func (c *Client) UsersBulkActionsBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateUsersRes, error) {
	res, err := c.sendUsersBulkActionsBulkUpdateUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkUpdateUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkUpdateUsers"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/update"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkUpdateUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkUpdateUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkUpdateUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkUpdateUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsBulkUpdateUsersInternalSquads invokes UsersBulkActions_bulkUpdateUsersInternalSquads operation.
//
// Bulk update users internal squads by UUIDs.
//
// POST /api/users/bulk/update-squads
func (c *Client) UsersBulkActionsBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequest, options ...RequestOption) (UsersBulkActionsBulkUpdateUsersInternalSquadsRes, error) {
	res, err := c.sendUsersBulkActionsBulkUpdateUsersInternalSquads(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequest, requestOptions ...RequestOption) (res UsersBulkActionsBulkUpdateUsersInternalSquadsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UsersBulkActions_bulkUpdateUsersInternalSquads"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/bulk/update-squads"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersBulkActionsBulkUpdateUsersInternalSquadsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update-squads"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsBulkUpdateUsersInternalSquadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersBulkActionsBulkUpdateUsersInternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersBulkActionsBulkUpdateUsersInternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersCreateUser invokes Users_createUser operation.
//
// Create a new user.
//
// POST /api/users
func (c *Client) UsersCreateUser(ctx context.Context, request *CreateUserRequest, options ...RequestOption) (UsersCreateUserRes, error) {
	res, err := c.sendUsersCreateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersCreateUser(ctx context.Context, request *CreateUserRequest, requestOptions ...RequestOption) (res UsersCreateUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_createUser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersCreateUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersCreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDeleteUser invokes Users_deleteUser operation.
//
// Delete user.
//
// DELETE /api/users/{uuid}
func (c *Client) UsersDeleteUser(ctx context.Context, params UsersDeleteUserParams, options ...RequestOption) (UsersDeleteUserRes, error) {
	res, err := c.sendUsersDeleteUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersDeleteUser(ctx context.Context, params UsersDeleteUserParams, requestOptions ...RequestOption) (res UsersDeleteUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_deleteUser"),
		semconv.HTTPRequestMethodKey.String("DELETE"),
		semconv.URLTemplateKey.String("/api/users/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersDeleteUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersDeleteUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersDeleteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersDisableUser invokes Users_disableUser operation.
//
// Disable user.
//
// POST /api/users/{uuid}/actions/disable
func (c *Client) UsersDisableUser(ctx context.Context, params UsersDisableUserParams, options ...RequestOption) (UsersDisableUserRes, error) {
	res, err := c.sendUsersDisableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersDisableUser(ctx context.Context, params UsersDisableUserParams, requestOptions ...RequestOption) (res UsersDisableUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_disableUser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/actions/disable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersDisableUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersDisableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersDisableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersEnableUser invokes Users_enableUser operation.
//
// Enable user.
//
// POST /api/users/{uuid}/actions/enable
func (c *Client) UsersEnableUser(ctx context.Context, params UsersEnableUserParams, options ...RequestOption) (UsersEnableUserRes, error) {
	res, err := c.sendUsersEnableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersEnableUser(ctx context.Context, params UsersEnableUserParams, requestOptions ...RequestOption) (res UsersEnableUserRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_enableUser"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/actions/enable"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersEnableUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersEnableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersEnableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetAllTags invokes Users_getAllTags operation.
//
// Get all existing user tags.
//
// GET /api/users/tags
func (c *Client) UsersGetAllTags(ctx context.Context, options ...RequestOption) (UsersGetAllTagsRes, error) {
	res, err := c.sendUsersGetAllTags(ctx, options...)
	return res, err
}

func (c *Client) sendUsersGetAllTags(ctx context.Context, requestOptions ...RequestOption) (res UsersGetAllTagsRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getAllTags"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/tags"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetAllTagsOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/tags"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetAllTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetAllTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetAllUsers invokes Users_getAllUsers operation.
//
// Get all users.
//
// GET /api/users
func (c *Client) UsersGetAllUsers(ctx context.Context, params UsersGetAllUsersParams, options ...RequestOption) (UsersGetAllUsersRes, error) {
	res, err := c.sendUsersGetAllUsers(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetAllUsers(ctx context.Context, params UsersGetAllUsersParams, requestOptions ...RequestOption) (res UsersGetAllUsersRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getAllUsers"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetAllUsersOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserAccessibleNodes invokes Users_getUserAccessibleNodes operation.
//
// Get user accessible nodes.
//
// GET /api/users/{uuid}/accessible-nodes
func (c *Client) UsersGetUserAccessibleNodes(ctx context.Context, params UsersGetUserAccessibleNodesParams, options ...RequestOption) (UsersGetUserAccessibleNodesRes, error) {
	res, err := c.sendUsersGetUserAccessibleNodes(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserAccessibleNodes(ctx context.Context, params UsersGetUserAccessibleNodesParams, requestOptions ...RequestOption) (res UsersGetUserAccessibleNodesRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserAccessibleNodes"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/accessible-nodes"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserAccessibleNodesOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accessible-nodes"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserAccessibleNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserAccessibleNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserById invokes Users_getUserById operation.
//
// Get user by ID.
//
// GET /api/users/by-id/{id}
func (c *Client) UsersGetUserById(ctx context.Context, params UsersGetUserByIdParams, options ...RequestOption) (UsersGetUserByIdRes, error) {
	res, err := c.sendUsersGetUserById(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserById(ctx context.Context, params UsersGetUserByIdParams, requestOptions ...RequestOption) (res UsersGetUserByIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserById"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-id/{id}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserByIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-id/"
	{
		// Encode "id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserByIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserByIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserByShortUuid invokes Users_getUserByShortUuid operation.
//
// Get user by Short UUID.
//
// GET /api/users/by-short-uuid/{shortUuid}
func (c *Client) UsersGetUserByShortUuid(ctx context.Context, params UsersGetUserByShortUuidParams, options ...RequestOption) (UsersGetUserByShortUuidRes, error) {
	res, err := c.sendUsersGetUserByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserByShortUuid(ctx context.Context, params UsersGetUserByShortUuidParams, requestOptions ...RequestOption) (res UsersGetUserByShortUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserByShortUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-short-uuid/{shortUuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserByShortUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-short-uuid/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserByTelegramId invokes Users_getUserByTelegramId operation.
//
// Get users by telegram ID.
//
// GET /api/users/by-telegram-id/{telegramId}
func (c *Client) UsersGetUserByTelegramId(ctx context.Context, params UsersGetUserByTelegramIdParams, options ...RequestOption) (UsersGetUserByTelegramIdRes, error) {
	res, err := c.sendUsersGetUserByTelegramId(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserByTelegramId(ctx context.Context, params UsersGetUserByTelegramIdParams, requestOptions ...RequestOption) (res UsersGetUserByTelegramIdRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserByTelegramId"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-telegram-id/{telegramId}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserByTelegramIdOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-telegram-id/"
	{
		// Encode "telegramId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "telegramId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TelegramId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserByTelegramIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserByTelegramIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserByUsername invokes Users_getUserByUsername operation.
//
// Get user by username.
//
// GET /api/users/by-username/{username}
func (c *Client) UsersGetUserByUsername(ctx context.Context, params UsersGetUserByUsernameParams, options ...RequestOption) (UsersGetUserByUsernameRes, error) {
	res, err := c.sendUsersGetUserByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserByUsername(ctx context.Context, params UsersGetUserByUsernameParams, requestOptions ...RequestOption) (res UsersGetUserByUsernameRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserByUsername"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-username/{username}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserByUsernameOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserByUuid invokes Users_getUserByUuid operation.
//
// Get user by UUID.
//
// GET /api/users/{uuid}
func (c *Client) UsersGetUserByUuid(ctx context.Context, params UsersGetUserByUuidParams, options ...RequestOption) (UsersGetUserByUuidRes, error) {
	res, err := c.sendUsersGetUserByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserByUuid(ctx context.Context, params UsersGetUserByUuidParams, requestOptions ...RequestOption) (res UsersGetUserByUuidRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserByUuid"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/{uuid}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserByUuidOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUserSubscriptionRequestHistory invokes Users_getUserSubscriptionRequestHistory operation.
//
// Get user subscription request history, recent 24 records.
//
// GET /api/users/{uuid}/subscription-request-history
func (c *Client) UsersGetUserSubscriptionRequestHistory(ctx context.Context, params UsersGetUserSubscriptionRequestHistoryParams, options ...RequestOption) (UsersGetUserSubscriptionRequestHistoryRes, error) {
	res, err := c.sendUsersGetUserSubscriptionRequestHistory(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUserSubscriptionRequestHistory(ctx context.Context, params UsersGetUserSubscriptionRequestHistoryParams, requestOptions ...RequestOption) (res UsersGetUserSubscriptionRequestHistoryRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUserSubscriptionRequestHistory"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/subscription-request-history"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUserSubscriptionRequestHistoryOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/subscription-request-history"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUserSubscriptionRequestHistoryOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUserSubscriptionRequestHistoryResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUsersByEmail invokes Users_getUsersByEmail operation.
//
// Get users by email.
//
// GET /api/users/by-email/{email}
func (c *Client) UsersGetUsersByEmail(ctx context.Context, params UsersGetUsersByEmailParams, options ...RequestOption) (UsersGetUsersByEmailRes, error) {
	res, err := c.sendUsersGetUsersByEmail(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUsersByEmail(ctx context.Context, params UsersGetUsersByEmailParams, requestOptions ...RequestOption) (res UsersGetUsersByEmailRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUsersByEmail"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-email/{email}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUsersByEmailOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-email/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUsersByEmailOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUsersByEmailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersGetUsersByTag invokes Users_getUsersByTag operation.
//
// Get users by tag.
//
// GET /api/users/by-tag/{tag}
func (c *Client) UsersGetUsersByTag(ctx context.Context, params UsersGetUsersByTagParams, options ...RequestOption) (UsersGetUsersByTagRes, error) {
	res, err := c.sendUsersGetUsersByTag(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersGetUsersByTag(ctx context.Context, params UsersGetUsersByTagParams, requestOptions ...RequestOption) (res UsersGetUsersByTagRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_getUsersByTag"),
		semconv.HTTPRequestMethodKey.String("GET"),
		semconv.URLTemplateKey.String("/api/users/by-tag/{tag}"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersGetUsersByTagOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-tag/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersGetUsersByTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersGetUsersByTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersResetUserTraffic invokes Users_resetUserTraffic operation.
//
// Reset user traffic.
//
// POST /api/users/{uuid}/actions/reset-traffic
func (c *Client) UsersResetUserTraffic(ctx context.Context, params UsersResetUserTrafficParams, options ...RequestOption) (UsersResetUserTrafficRes, error) {
	res, err := c.sendUsersResetUserTraffic(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersResetUserTraffic(ctx context.Context, params UsersResetUserTrafficParams, requestOptions ...RequestOption) (res UsersResetUserTrafficRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_resetUserTraffic"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/actions/reset-traffic"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersResetUserTrafficOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersRevokeUserSubscription invokes Users_revokeUserSubscription operation.
//
// Revoke user subscription.
//
// POST /api/users/{uuid}/actions/revoke
func (c *Client) UsersRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBody, params UsersRevokeUserSubscriptionParams, options ...RequestOption) (UsersRevokeUserSubscriptionRes, error) {
	res, err := c.sendUsersRevokeUserSubscription(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendUsersRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBody, params UsersRevokeUserSubscriptionParams, requestOptions ...RequestOption) (res UsersRevokeUserSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_revokeUserSubscription"),
		semconv.HTTPRequestMethodKey.String("POST"),
		semconv.URLTemplateKey.String("/api/users/{uuid}/actions/revoke"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersRevokeUserSubscriptionOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersRevokeUserSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersRevokeUserSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersRevokeUserSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersUpdateUser invokes Users_updateUser operation.
//
// Update a user by UUID or username.
//
// PATCH /api/users
func (c *Client) UsersUpdateUser(ctx context.Context, request *UpdateUserRequest, options ...RequestOption) (UsersUpdateUserRes, error) {
	res, err := c.sendUsersUpdateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersUpdateUser(ctx context.Context, request *UpdateUserRequest, requestOptions ...RequestOption) (res UsersUpdateUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("Users_updateUser"),
		semconv.HTTPRequestMethodKey.String("PATCH"),
		semconv.URLTemplateKey.String("/api/users"),
	}
	otelAttrs = append(otelAttrs, c.cfg.Attributes...)

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(elapsedDuration)/float64(time.Millisecond), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, UsersUpdateUserOperation,
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	stage = "BuildURL"
	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersUpdateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:Authorization"
			switch err := c.securityAuthorization(ctx, UsersUpdateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := c.onRequest(ctx, r); err != nil {
		return res, errors.Wrap(err, "client edit request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	stage = "SendRequest"
	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := c.onResponse(ctx, resp); err != nil {
		return res, errors.Wrap(err, "client edit response")
	}

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	stage = "DecodeResponse"
	result, err := decodeUsersUpdateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
