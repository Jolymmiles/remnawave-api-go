// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

type requestConfig struct {
	Client       ht.Client
	ServerURL    *url.URL
	EditRequest  func(req *http.Request) error
	EditResponse func(resp *http.Response) error
}

func (cfg *requestConfig) setDefaults(c baseClient) {
	if cfg.Client == nil {
		cfg.Client = c.cfg.Client
	}
}

func (cfg *requestConfig) onRequest(req *http.Request) error {
	if fn := cfg.EditRequest; fn != nil {
		return fn(req)
	}
	return nil
}

func (cfg *requestConfig) onResponse(resp *http.Response) error {
	if fn := cfg.EditResponse; fn != nil {
		return fn(resp)
	}
	return nil
}

// RequestOption defines options for request.
type RequestOption func(cfg *requestConfig)

// WithRequestClient sets client for request.
func WithRequestClient(client ht.Client) RequestOption {
	return func(cfg *requestConfig) {
		cfg.Client = client
	}
}

// WithServerURL sets client for request.
func WithServerURL(u *url.URL) RequestOption {
	return func(cfg *requestConfig) {
		cfg.ServerURL = u
	}
}

// WithEditRequest sets function to edit request.
func WithEditRequest(fn func(req *http.Request) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditRequest = fn
	}
}

// WithEditResponse sets function to edit response.
func WithEditResponse(fn func(resp *http.Response) error) RequestOption {
	return func(cfg *requestConfig) {
		cfg.EditResponse = fn
	}
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// ApiTokensControllerCreate invokes ApiTokensController_create operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
	//
	// POST /api/tokens
	ApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, options ...RequestOption) (ApiTokensControllerCreateRes, error)
	// ApiTokensControllerDelete invokes ApiTokensController_delete operation.
	//
	// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
	//
	// DELETE /api/tokens/{uuid}
	ApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, options ...RequestOption) (ApiTokensControllerDeleteRes, error)
	// ApiTokensControllerFindAll invokes ApiTokensController_findAll operation.
	//
	// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
	//
	// GET /api/tokens
	ApiTokensControllerFindAll(ctx context.Context, options ...RequestOption) (ApiTokensControllerFindAllRes, error)
	// AuthControllerGetStatus invokes AuthController_getStatus operation.
	//
	// Get the status of the authentication.
	//
	// GET /api/auth/status
	AuthControllerGetStatus(ctx context.Context, options ...RequestOption) (AuthControllerGetStatusRes, error)
	// AuthControllerLogin invokes AuthController_login operation.
	//
	// Login as superadmin.
	//
	// POST /api/auth/login
	AuthControllerLogin(ctx context.Context, request *LoginRequestDto, options ...RequestOption) (AuthControllerLoginRes, error)
	// AuthControllerOauth2Authorize invokes AuthController_oauth2Authorize operation.
	//
	// Initiate OAuth2 authorization.
	//
	// POST /api/auth/oauth2/authorize
	AuthControllerOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequestDto, options ...RequestOption) (AuthControllerOauth2AuthorizeRes, error)
	// AuthControllerOauth2Callback invokes AuthController_oauth2Callback operation.
	//
	// Callback from OAuth2.
	//
	// POST /api/auth/oauth2/callback
	AuthControllerOauth2Callback(ctx context.Context, request *OAuth2CallbackRequestDto, options ...RequestOption) (AuthControllerOauth2CallbackRes, error)
	// AuthControllerRegister invokes AuthController_register operation.
	//
	// Register as superadmin.
	//
	// POST /api/auth/register
	AuthControllerRegister(ctx context.Context, request *RegisterRequestDto, options ...RequestOption) (AuthControllerRegisterRes, error)
	// AuthControllerTelegramCallback invokes AuthController_telegramCallback operation.
	//
	// Callback from Telegram OAuth2.
	//
	// POST /api/auth/oauth2/tg/callback
	AuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, options ...RequestOption) (AuthControllerTelegramCallbackRes, error)
	// ConfigProfileControllerCreateConfigProfile invokes ConfigProfileController_createConfigProfile operation.
	//
	// Create config profile.
	//
	// POST /api/config-profiles
	ConfigProfileControllerCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequestDto, options ...RequestOption) (ConfigProfileControllerCreateConfigProfileRes, error)
	// ConfigProfileControllerDeleteConfigProfileByUuid invokes ConfigProfileController_deleteConfigProfileByUuid operation.
	//
	// Delete config profile.
	//
	// DELETE /api/config-profiles/{uuid}
	ConfigProfileControllerDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerDeleteConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileControllerDeleteConfigProfileByUuidRes, error)
	// ConfigProfileControllerGetAllInbounds invokes ConfigProfileController_getAllInbounds operation.
	//
	// Get all inbounds from all config profiles.
	//
	// GET /api/config-profiles/inbounds
	ConfigProfileControllerGetAllInbounds(ctx context.Context, options ...RequestOption) (ConfigProfileControllerGetAllInboundsRes, error)
	// ConfigProfileControllerGetConfigProfileByUuid invokes ConfigProfileController_getConfigProfileByUuid operation.
	//
	// Get config profile by uuid.
	//
	// GET /api/config-profiles/{uuid}
	ConfigProfileControllerGetConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerGetConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileControllerGetConfigProfileByUuidRes, error)
	// ConfigProfileControllerGetConfigProfiles invokes ConfigProfileController_getConfigProfiles operation.
	//
	// Get config profiles.
	//
	// GET /api/config-profiles
	ConfigProfileControllerGetConfigProfiles(ctx context.Context, options ...RequestOption) (ConfigProfileControllerGetConfigProfilesRes, error)
	// ConfigProfileControllerGetInboundsByProfileUuid invokes ConfigProfileController_getInboundsByProfileUuid operation.
	//
	// Get inbounds by profile uuid.
	//
	// GET /api/config-profiles/{uuid}/inbounds
	ConfigProfileControllerGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileControllerGetInboundsByProfileUuidParams, options ...RequestOption) (ConfigProfileControllerGetInboundsByProfileUuidRes, error)
	// ConfigProfileControllerUpdateConfigProfile invokes ConfigProfileController_updateConfigProfile operation.
	//
	// Update Core Config in specific config profile.
	//
	// PATCH /api/config-profiles
	ConfigProfileControllerUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequestDto, options ...RequestOption) (ConfigProfileControllerUpdateConfigProfileRes, error)
	// HostsBulkActionsControllerDeleteHosts invokes HostsBulkActionsController_deleteHosts operation.
	//
	// Delete hosts by UUIDs.
	//
	// POST /api/hosts/bulk/delete
	HostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerDeleteHostsRes, error)
	// HostsBulkActionsControllerDisableHosts invokes HostsBulkActionsController_disableHosts operation.
	//
	// Disable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/disable
	HostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerDisableHostsRes, error)
	// HostsBulkActionsControllerEnableHosts invokes HostsBulkActionsController_enableHosts operation.
	//
	// Enable hosts by UUIDs.
	//
	// POST /api/hosts/bulk/enable
	HostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerEnableHostsRes, error)
	// HostsBulkActionsControllerSetInboundToHosts invokes HostsBulkActionsController_setInboundToHosts operation.
	//
	// Set inbound to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-inbound
	HostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerSetInboundToHostsRes, error)
	// HostsBulkActionsControllerSetPortToHosts invokes HostsBulkActionsController_setPortToHosts operation.
	//
	// Set port to hosts by UUIDs.
	//
	// POST /api/hosts/bulk/set-port
	HostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerSetPortToHostsRes, error)
	// HostsControllerCreateHost invokes HostsController_createHost operation.
	//
	// Create a new host.
	//
	// POST /api/hosts
	HostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, options ...RequestOption) (HostsControllerCreateHostRes, error)
	// HostsControllerDeleteHost invokes HostsController_deleteHost operation.
	//
	// Delete a host by UUID.
	//
	// DELETE /api/hosts/{uuid}
	HostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, options ...RequestOption) (HostsControllerDeleteHostRes, error)
	// HostsControllerGetAllHosts invokes HostsController_getAllHosts operation.
	//
	// Get all hosts.
	//
	// GET /api/hosts
	HostsControllerGetAllHosts(ctx context.Context, options ...RequestOption) (HostsControllerGetAllHostsRes, error)
	// HostsControllerGetOneHost invokes HostsController_getOneHost operation.
	//
	// Get a host by UUID.
	//
	// GET /api/hosts/{uuid}
	HostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, options ...RequestOption) (HostsControllerGetOneHostRes, error)
	// HostsControllerReorderHosts invokes HostsController_reorderHosts operation.
	//
	// Reorder hosts.
	//
	// POST /api/hosts/actions/reorder
	HostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, options ...RequestOption) (HostsControllerReorderHostsRes, error)
	// HostsControllerUpdateHost invokes HostsController_updateHost operation.
	//
	// Update a host.
	//
	// PATCH /api/hosts
	HostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, options ...RequestOption) (HostsControllerUpdateHostRes, error)
	// HwidUserDevicesControllerCreateUserHwidDevice invokes HwidUserDevicesController_createUserHwidDevice operation.
	//
	// Create a user HWID device.
	//
	// POST /api/hwid/devices
	HwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, options ...RequestOption) (HwidUserDevicesControllerCreateUserHwidDeviceRes, error)
	// HwidUserDevicesControllerDeleteUserHwidDevice invokes HwidUserDevicesController_deleteUserHwidDevice operation.
	//
	// Delete a user HWID device.
	//
	// POST /api/hwid/devices/delete
	HwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, options ...RequestOption) (HwidUserDevicesControllerDeleteUserHwidDeviceRes, error)
	// HwidUserDevicesControllerGetUserHwidDevices invokes HwidUserDevicesController_getUserHwidDevices operation.
	//
	// Get user HWID devices.
	//
	// GET /api/hwid/devices/{userUuid}
	HwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, options ...RequestOption) (HwidUserDevicesControllerGetUserHwidDevicesRes, error)
	// InfraBillingControllerCreateInfraBillingHistoryRecord invokes InfraBillingController_createInfraBillingHistoryRecord operation.
	//
	// Create infra billing history.
	//
	// POST /api/infra-billing/history
	InfraBillingControllerCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraBillingHistoryRecordRes, error)
	// InfraBillingControllerCreateInfraBillingNode invokes InfraBillingController_createInfraBillingNode operation.
	//
	// Create infra billing node.
	//
	// POST /api/infra-billing/nodes
	InfraBillingControllerCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraBillingNodeRes, error)
	// InfraBillingControllerCreateInfraProvider invokes InfraBillingController_createInfraProvider operation.
	//
	// Create infra provider.
	//
	// POST /api/infra-billing/providers
	InfraBillingControllerCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraProviderRes, error)
	// InfraBillingControllerDeleteInfraBillingHistoryRecordByUuid invokes InfraBillingController_deleteInfraBillingHistoryRecordByUuid operation.
	//
	// Delete infra billing history.
	//
	// DELETE /api/infra-billing/history/{uuid}
	InfraBillingControllerDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidRes, error)
	// InfraBillingControllerDeleteInfraBillingNodeByUuid invokes InfraBillingController_deleteInfraBillingNodeByUuid operation.
	//
	// Delete infra billing node.
	//
	// DELETE /api/infra-billing/nodes/{uuid}
	InfraBillingControllerDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingNodeByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraBillingNodeByUuidRes, error)
	// InfraBillingControllerDeleteInfraProviderByUuid invokes InfraBillingController_deleteInfraProviderByUuid operation.
	//
	// Delete infra provider by uuid.
	//
	// DELETE /api/infra-billing/providers/{uuid}
	InfraBillingControllerDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraProviderByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraProviderByUuidRes, error)
	// InfraBillingControllerGetBillingNodes invokes InfraBillingController_getBillingNodes operation.
	//
	// Get infra billing nodes.
	//
	// GET /api/infra-billing/nodes
	InfraBillingControllerGetBillingNodes(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetBillingNodesRes, error)
	// InfraBillingControllerGetInfraBillingHistoryRecords invokes InfraBillingController_getInfraBillingHistoryRecords operation.
	//
	// Get infra billing history.
	//
	// GET /api/infra-billing/history
	InfraBillingControllerGetInfraBillingHistoryRecords(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetInfraBillingHistoryRecordsRes, error)
	// InfraBillingControllerGetInfraProviderByUuid invokes InfraBillingController_getInfraProviderByUuid operation.
	//
	// Get infra provider by uuid.
	//
	// GET /api/infra-billing/providers/{uuid}
	InfraBillingControllerGetInfraProviderByUuid(ctx context.Context, params InfraBillingControllerGetInfraProviderByUuidParams, options ...RequestOption) (InfraBillingControllerGetInfraProviderByUuidRes, error)
	// InfraBillingControllerGetInfraProviders invokes InfraBillingController_getInfraProviders operation.
	//
	// Get all infra providers.
	//
	// GET /api/infra-billing/providers
	InfraBillingControllerGetInfraProviders(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetInfraProvidersRes, error)
	// InfraBillingControllerUpdateInfraBillingNode invokes InfraBillingController_updateInfraBillingNode operation.
	//
	// Update infra billing node.
	//
	// PATCH /api/infra-billing/nodes
	InfraBillingControllerUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequestDto, options ...RequestOption) (InfraBillingControllerUpdateInfraBillingNodeRes, error)
	// InfraBillingControllerUpdateInfraProvider invokes InfraBillingController_updateInfraProvider operation.
	//
	// Update infra provider.
	//
	// PATCH /api/infra-billing/providers
	InfraBillingControllerUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequestDto, options ...RequestOption) (InfraBillingControllerUpdateInfraProviderRes, error)
	// InternalSquadControllerAddUsersToInternalSquad invokes InternalSquadController_addUsersToInternalSquad operation.
	//
	// Add all users to internal squad.
	//
	// POST /api/internal-squads/{uuid}/bulk-actions/add-users
	InternalSquadControllerAddUsersToInternalSquad(ctx context.Context, params InternalSquadControllerAddUsersToInternalSquadParams, options ...RequestOption) (InternalSquadControllerAddUsersToInternalSquadRes, error)
	// InternalSquadControllerCreateInternalSquad invokes InternalSquadController_createInternalSquad operation.
	//
	// Create internal squad.
	//
	// POST /api/internal-squads
	InternalSquadControllerCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequestDto, options ...RequestOption) (InternalSquadControllerCreateInternalSquadRes, error)
	// InternalSquadControllerDeleteInternalSquad invokes InternalSquadController_deleteInternalSquad operation.
	//
	// Delete internal squad.
	//
	// DELETE /api/internal-squads/{uuid}
	InternalSquadControllerDeleteInternalSquad(ctx context.Context, params InternalSquadControllerDeleteInternalSquadParams, options ...RequestOption) (InternalSquadControllerDeleteInternalSquadRes, error)
	// InternalSquadControllerGetInternalSquadByUuid invokes InternalSquadController_getInternalSquadByUuid operation.
	//
	// Get internal squad by uuid.
	//
	// GET /api/internal-squads/{uuid}
	InternalSquadControllerGetInternalSquadByUuid(ctx context.Context, params InternalSquadControllerGetInternalSquadByUuidParams, options ...RequestOption) (InternalSquadControllerGetInternalSquadByUuidRes, error)
	// InternalSquadControllerGetInternalSquads invokes InternalSquadController_getInternalSquads operation.
	//
	// Get all internal squads.
	//
	// GET /api/internal-squads
	InternalSquadControllerGetInternalSquads(ctx context.Context, options ...RequestOption) (InternalSquadControllerGetInternalSquadsRes, error)
	// InternalSquadControllerRemoveUsersFromInternalSquad invokes InternalSquadController_removeUsersFromInternalSquad operation.
	//
	// Delete users from internal squad.
	//
	// DELETE /api/internal-squads/{uuid}/bulk-actions/remove-users
	InternalSquadControllerRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadControllerRemoveUsersFromInternalSquadParams, options ...RequestOption) (InternalSquadControllerRemoveUsersFromInternalSquadRes, error)
	// InternalSquadControllerUpdateInternalSquad invokes InternalSquadController_updateInternalSquad operation.
	//
	// Update internal squad.
	//
	// PATCH /api/internal-squads
	InternalSquadControllerUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequestDto, options ...RequestOption) (InternalSquadControllerUpdateInternalSquadRes, error)
	// KeygenControllerGenerateKey invokes KeygenController_generateKey operation.
	//
	// Get SSL_CERT for Remnawave Node.
	//
	// GET /api/keygen
	KeygenControllerGenerateKey(ctx context.Context, options ...RequestOption) (KeygenControllerGenerateKeyRes, error)
	// NodesControllerCreateNode invokes NodesController_createNode operation.
	//
	// Create a new node.
	//
	// POST /api/nodes
	NodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, options ...RequestOption) (NodesControllerCreateNodeRes, error)
	// NodesControllerDeleteNode invokes NodesController_deleteNode operation.
	//
	// Delete a node.
	//
	// DELETE /api/nodes/{uuid}
	NodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, options ...RequestOption) (NodesControllerDeleteNodeRes, error)
	// NodesControllerDisableNode invokes NodesController_disableNode operation.
	//
	// Disable a node.
	//
	// POST /api/nodes/{uuid}/actions/disable
	NodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, options ...RequestOption) (NodesControllerDisableNodeRes, error)
	// NodesControllerEnableNode invokes NodesController_enableNode operation.
	//
	// Enable a node.
	//
	// POST /api/nodes/{uuid}/actions/enable
	NodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, options ...RequestOption) (NodesControllerEnableNodeRes, error)
	// NodesControllerGetAllNodes invokes NodesController_getAllNodes operation.
	//
	// Get all nodes.
	//
	// GET /api/nodes
	NodesControllerGetAllNodes(ctx context.Context, options ...RequestOption) (NodesControllerGetAllNodesRes, error)
	// NodesControllerGetOneNode invokes NodesController_getOneNode operation.
	//
	// Get node by UUID.
	//
	// GET /api/nodes/{uuid}
	NodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, options ...RequestOption) (NodesControllerGetOneNodeRes, error)
	// NodesControllerReorderNodes invokes NodesController_reorderNodes operation.
	//
	// Reorder nodes.
	//
	// POST /api/nodes/actions/reorder
	NodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, options ...RequestOption) (NodesControllerReorderNodesRes, error)
	// NodesControllerRestartAllNodes invokes NodesController_restartAllNodes operation.
	//
	// Restart all nodes.
	//
	// POST /api/nodes/actions/restart-all
	NodesControllerRestartAllNodes(ctx context.Context, options ...RequestOption) (NodesControllerRestartAllNodesRes, error)
	// NodesControllerRestartNode invokes NodesController_restartNode operation.
	//
	// Restart node.
	//
	// POST /api/nodes/{uuid}/actions/restart
	NodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, options ...RequestOption) (NodesControllerRestartNodeRes, error)
	// NodesControllerUpdateNode invokes NodesController_updateNode operation.
	//
	// Update node.
	//
	// PATCH /api/nodes
	NodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, options ...RequestOption) (NodesControllerUpdateNodeRes, error)
	// NodesUsageHistoryControllerGetNodesUsageByRange invokes NodesUsageHistoryController_getNodesUsageByRange operation.
	//
	// Get nodes usage by range.
	//
	// GET /api/nodes/usage/range
	NodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, options ...RequestOption) (NodesUsageHistoryControllerGetNodesUsageByRangeRes, error)
	// NodesUserUsageHistoryControllerGetNodeUserUsage invokes NodesUserUsageHistoryController_getNodeUserUsage operation.
	//
	// Get node user usage by range and Node UUID.
	//
	// GET /api/nodes/usage/{uuid}/users/range
	NodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, options ...RequestOption) (NodesUserUsageHistoryControllerGetNodeUserUsageRes, error)
	// NodesUserUsageHistoryControllerGetNodesRealtimeUsage invokes NodesUserUsageHistoryController_getNodesRealtimeUsage operation.
	//
	// Get nodes realtime usage.
	//
	// GET /api/nodes/usage/realtime
	NodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (NodesUserUsageHistoryControllerGetNodesRealtimeUsageRes, error)
	// SubscriptionControllerGetRawSubscriptionByShortUuid invokes SubscriptionController_getRawSubscriptionByShortUuid operation.
	//
	// Get Raw Subscription by Short UUID.
	//
	// GET /api/sub/{shortUuid}/raw
	SubscriptionControllerGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionControllerGetRawSubscriptionByShortUuidParams, options ...RequestOption) (SubscriptionControllerGetRawSubscriptionByShortUuidRes, error)
	// SubscriptionControllerGetSubscription invokes SubscriptionController_getSubscription operation.
	//
	// GET /api/sub/{shortUuid}
	SubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, options ...RequestOption) error
	// SubscriptionControllerGetSubscriptionByClientType invokes SubscriptionController_getSubscriptionByClientType operation.
	//
	// GET /api/sub/{shortUuid}/{clientType}
	SubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, options ...RequestOption) error
	// SubscriptionControllerGetSubscriptionInfoByShortUuid invokes SubscriptionController_getSubscriptionInfoByShortUuid operation.
	//
	// Get Subscription Info by Short UUID.
	//
	// GET /api/sub/{shortUuid}/info
	SubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (SubscriptionControllerGetSubscriptionInfoByShortUuidRes, error)
	// SubscriptionControllerGetSubscriptionWithType invokes SubscriptionController_getSubscriptionWithType operation.
	//
	// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
	SubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, options ...RequestOption) error
	// SubscriptionSettingsControllerGetSettings invokes SubscriptionSettingsController_getSettings operation.
	//
	// Get subscription settings.
	//
	// GET /api/subscription-settings
	SubscriptionSettingsControllerGetSettings(ctx context.Context, options ...RequestOption) (SubscriptionSettingsControllerGetSettingsRes, error)
	// SubscriptionSettingsControllerUpdateSettings invokes SubscriptionSettingsController_updateSettings operation.
	//
	// Update subscription settings.
	//
	// PATCH /api/subscription-settings
	SubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, options ...RequestOption) (SubscriptionSettingsControllerUpdateSettingsRes, error)
	// SubscriptionTemplateControllerGetTemplate invokes SubscriptionTemplateController_getTemplate operation.
	//
	// Get subscription template.
	//
	// GET /api/subscription-templates/{templateType}
	SubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, options ...RequestOption) (SubscriptionTemplateControllerGetTemplateRes, error)
	// SubscriptionTemplateControllerUpdateTemplate invokes SubscriptionTemplateController_updateTemplate operation.
	//
	// Update subscription template.
	//
	// PUT /api/subscription-templates
	SubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, options ...RequestOption) (SubscriptionTemplateControllerUpdateTemplateRes, error)
	// SubscriptionsControllerGetAllSubscriptions invokes SubscriptionsController_getAllSubscriptions operation.
	//
	// Get all subscriptions.
	//
	// GET /api/subscriptions
	SubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, options ...RequestOption) (SubscriptionsControllerGetAllSubscriptionsRes, error)
	// SubscriptionsControllerGetSubscriptionByUsername invokes SubscriptionsController_getSubscriptionByUsername operation.
	//
	// Get subscription by username.
	//
	// GET /api/subscriptions/by-username/{username}
	SubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsControllerGetSubscriptionByUsernameRes, error)
	// SystemControllerGetBandwidthStats invokes SystemController_getBandwidthStats operation.
	//
	// Get Bandwidth Stats.
	//
	// GET /api/system/stats/bandwidth
	SystemControllerGetBandwidthStats(ctx context.Context, options ...RequestOption) (SystemControllerGetBandwidthStatsRes, error)
	// SystemControllerGetNodesMetrics invokes SystemController_getNodesMetrics operation.
	//
	// Get Nodes Metrics.
	//
	// GET /api/system/nodes/metrics
	SystemControllerGetNodesMetrics(ctx context.Context, options ...RequestOption) (SystemControllerGetNodesMetricsRes, error)
	// SystemControllerGetNodesStatistics invokes SystemController_getNodesStatistics operation.
	//
	// Get Nodes Statistics.
	//
	// GET /api/system/stats/nodes
	SystemControllerGetNodesStatistics(ctx context.Context, options ...RequestOption) (SystemControllerGetNodesStatisticsRes, error)
	// SystemControllerGetRemnawaveHealth invokes SystemController_getRemnawaveHealth operation.
	//
	// Get Remnawave Health.
	//
	// GET /api/system/health
	SystemControllerGetRemnawaveHealth(ctx context.Context, options ...RequestOption) (SystemControllerGetRemnawaveHealthRes, error)
	// SystemControllerGetStats invokes SystemController_getStats operation.
	//
	// Get Stats.
	//
	// GET /api/system/stats
	SystemControllerGetStats(ctx context.Context, options ...RequestOption) (SystemControllerGetStatsRes, error)
	// UsersBulkActionsControllerBulkAllResetUserTraffic invokes UsersBulkActionsController_bulkAllResetUserTraffic operation.
	//
	// Bulk reset all users traffic.
	//
	// POST /api/users/bulk/all/reset-traffic
	UsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (UsersBulkActionsControllerBulkAllResetUserTrafficRes, error)
	// UsersBulkActionsControllerBulkDeleteUsers invokes UsersBulkActionsController_bulkDeleteUsers operation.
	//
	// Bulk delete users by UUIDs.
	//
	// POST /api/users/bulk/delete
	UsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkDeleteUsersRes, error)
	// UsersBulkActionsControllerBulkDeleteUsersByStatus invokes UsersBulkActionsController_bulkDeleteUsersByStatus operation.
	//
	// Bulk delete users by status.
	//
	// POST /api/users/bulk/delete-by-status
	UsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkDeleteUsersByStatusRes, error)
	// UsersBulkActionsControllerBulkResetUserTraffic invokes UsersBulkActionsController_bulkResetUserTraffic operation.
	//
	// Bulk reset traffic users by UUIDs.
	//
	// POST /api/users/bulk/reset-traffic
	UsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkResetUserTrafficRes, error)
	// UsersBulkActionsControllerBulkRevokeUsersSubscription invokes UsersBulkActionsController_bulkRevokeUsersSubscription operation.
	//
	// Revoke users subscription by User UUIDs.
	//
	// POST /api/users/bulk/revoke-subscription
	UsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkRevokeUsersSubscriptionRes, error)
	// UsersBulkActionsControllerBulkUpdateAllUsers invokes UsersBulkActionsController_bulkUpdateAllUsers operation.
	//
	// Bulk update all users.
	//
	// POST /api/users/bulk/all/update
	UsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateAllUsersRes, error)
	// UsersBulkActionsControllerBulkUpdateUsers invokes UsersBulkActionsController_bulkUpdateUsers operation.
	//
	// Bulk update users by UUIDs.
	//
	// POST /api/users/bulk/update
	UsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateUsersRes, error)
	// UsersBulkActionsControllerBulkUpdateUsersInternalSquads invokes UsersBulkActionsController_bulkUpdateUsersInternalSquads operation.
	//
	// Bulk update users internal squads by UUIDs.
	//
	// POST /api/users/bulk/update-squads
	UsersBulkActionsControllerBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateUsersInternalSquadsRes, error)
	// UsersControllerCreateUser invokes UsersController_createUser operation.
	//
	// Create a new user.
	//
	// POST /api/users
	UsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, options ...RequestOption) (UsersControllerCreateUserRes, error)
	// UsersControllerDeleteUser invokes UsersController_deleteUser operation.
	//
	// Delete user.
	//
	// DELETE /api/users/{uuid}
	UsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, options ...RequestOption) (UsersControllerDeleteUserRes, error)
	// UsersControllerDisableUser invokes UsersController_disableUser operation.
	//
	// Disable user.
	//
	// POST /api/users/{uuid}/actions/disable
	UsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, options ...RequestOption) (UsersControllerDisableUserRes, error)
	// UsersControllerEnableUser invokes UsersController_enableUser operation.
	//
	// Enable user.
	//
	// POST /api/users/{uuid}/actions/enable
	UsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, options ...RequestOption) (UsersControllerEnableUserRes, error)
	// UsersControllerGetAllTags invokes UsersController_getAllTags operation.
	//
	// Get all existing user tags.
	//
	// GET /api/users/tags
	UsersControllerGetAllTags(ctx context.Context, options ...RequestOption) (UsersControllerGetAllTagsRes, error)
	// UsersControllerGetAllUsers invokes UsersController_getAllUsers operation.
	//
	// Get all users.
	//
	// GET /api/users
	UsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, options ...RequestOption) (UsersControllerGetAllUsersRes, error)
	// UsersControllerGetUserAccessibleNodes invokes UsersController_getUserAccessibleNodes operation.
	//
	// Get user accessible nodes.
	//
	// GET /api/users/{uuid}/accessible-nodes
	UsersControllerGetUserAccessibleNodes(ctx context.Context, params UsersControllerGetUserAccessibleNodesParams, options ...RequestOption) (UsersControllerGetUserAccessibleNodesRes, error)
	// UsersControllerGetUserByShortUuid invokes UsersController_getUserByShortUuid operation.
	//
	// Get user by Short UUID.
	//
	// GET /api/users/by-short-uuid/{shortUuid}
	UsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, options ...RequestOption) (UsersControllerGetUserByShortUuidRes, error)
	// UsersControllerGetUserByTelegramId invokes UsersController_getUserByTelegramId operation.
	//
	// Get users by telegram ID.
	//
	// GET /api/users/by-telegram-id/{telegramId}
	UsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, options ...RequestOption) (UsersControllerGetUserByTelegramIdRes, error)
	// UsersControllerGetUserByUsername invokes UsersController_getUserByUsername operation.
	//
	// Get user by username.
	//
	// GET /api/users/by-username/{username}
	UsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, options ...RequestOption) (UsersControllerGetUserByUsernameRes, error)
	// UsersControllerGetUserByUuid invokes UsersController_getUserByUuid operation.
	//
	// Get user by UUID.
	//
	// GET /api/users/{uuid}
	UsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, options ...RequestOption) (UsersControllerGetUserByUuidRes, error)
	// UsersControllerGetUsersByEmail invokes UsersController_getUsersByEmail operation.
	//
	// Get users by email.
	//
	// GET /api/users/by-email/{email}
	UsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, options ...RequestOption) (UsersControllerGetUsersByEmailRes, error)
	// UsersControllerGetUsersByTag invokes UsersController_getUsersByTag operation.
	//
	// Get users by tag.
	//
	// GET /api/users/by-tag/{tag}
	UsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, options ...RequestOption) (UsersControllerGetUsersByTagRes, error)
	// UsersControllerResetUserTraffic invokes UsersController_resetUserTraffic operation.
	//
	// Reset user traffic.
	//
	// POST /api/users/{uuid}/actions/reset-traffic
	UsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, options ...RequestOption) (UsersControllerResetUserTrafficRes, error)
	// UsersControllerRevokeUserSubscription invokes UsersController_revokeUserSubscription operation.
	//
	// Revoke user subscription.
	//
	// POST /api/users/{uuid}/actions/revoke
	UsersControllerRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBodyDto, params UsersControllerRevokeUserSubscriptionParams, options ...RequestOption) (UsersControllerRevokeUserSubscriptionRes, error)
	// UsersControllerUpdateUser invokes UsersController_updateUser operation.
	//
	// Update a user.
	//
	// PATCH /api/users
	UsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, options ...RequestOption) (UsersControllerUpdateUserRes, error)
	// UsersStatsControllerGetUserUsageByRange invokes UsersStatsController_getUserUsageByRange operation.
	//
	// Get user usage by range.
	//
	// GET /api/users/stats/usage/{uuid}/range
	UsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, options ...RequestOption) (UsersStatsControllerGetUserUsageByRangeRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

// ApiTokensControllerCreate invokes ApiTokensController_create operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with an admin JWT-token.
//
// POST /api/tokens
func (c *Client) ApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, options ...RequestOption) (ApiTokensControllerCreateRes, error) {
	res, err := c.sendApiTokensControllerCreate(ctx, request, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerCreate(ctx context.Context, request *CreateApiTokenRequestDto, requestOptions ...RequestOption) (res ApiTokensControllerCreateRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeApiTokensControllerCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerCreateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensControllerDelete invokes ApiTokensController_delete operation.
//
// This endpoint is forbidden to use via "API-key". It can be used only with an admin JWT-token.
//
// DELETE /api/tokens/{uuid}
func (c *Client) ApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, options ...RequestOption) (ApiTokensControllerDeleteRes, error) {
	res, err := c.sendApiTokensControllerDelete(ctx, params, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerDelete(ctx context.Context, params ApiTokensControllerDeleteParams, requestOptions ...RequestOption) (res ApiTokensControllerDeleteRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/tokens/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ApiTokensControllerFindAll invokes ApiTokensController_findAll operation.
//
// This endpoint is forbidden to use via "API-key". It can only be used with admin JWT-token.
//
// GET /api/tokens
func (c *Client) ApiTokensControllerFindAll(ctx context.Context, options ...RequestOption) (ApiTokensControllerFindAllRes, error) {
	res, err := c.sendApiTokensControllerFindAll(ctx, options...)
	return res, err
}

func (c *Client) sendApiTokensControllerFindAll(ctx context.Context, requestOptions ...RequestOption) (res ApiTokensControllerFindAllRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/tokens"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ApiTokensControllerFindAllOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeApiTokensControllerFindAllResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerGetStatus invokes AuthController_getStatus operation.
//
// Get the status of the authentication.
//
// GET /api/auth/status
func (c *Client) AuthControllerGetStatus(ctx context.Context, options ...RequestOption) (AuthControllerGetStatusRes, error) {
	res, err := c.sendAuthControllerGetStatus(ctx, options...)
	return res, err
}

func (c *Client) sendAuthControllerGetStatus(ctx context.Context, requestOptions ...RequestOption) (res AuthControllerGetStatusRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerGetStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerLogin invokes AuthController_login operation.
//
// Login as superadmin.
//
// POST /api/auth/login
func (c *Client) AuthControllerLogin(ctx context.Context, request *LoginRequestDto, options ...RequestOption) (AuthControllerLoginRes, error) {
	res, err := c.sendAuthControllerLogin(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerLogin(ctx context.Context, request *LoginRequestDto, requestOptions ...RequestOption) (res AuthControllerLoginRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/login"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerLoginRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerLoginResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerOauth2Authorize invokes AuthController_oauth2Authorize operation.
//
// Initiate OAuth2 authorization.
//
// POST /api/auth/oauth2/authorize
func (c *Client) AuthControllerOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequestDto, options ...RequestOption) (AuthControllerOauth2AuthorizeRes, error) {
	res, err := c.sendAuthControllerOauth2Authorize(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerOauth2Authorize(ctx context.Context, request *OAuth2AuthorizeRequestDto, requestOptions ...RequestOption) (res AuthControllerOauth2AuthorizeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/authorize"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerOauth2AuthorizeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerOauth2AuthorizeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerOauth2Callback invokes AuthController_oauth2Callback operation.
//
// Callback from OAuth2.
//
// POST /api/auth/oauth2/callback
func (c *Client) AuthControllerOauth2Callback(ctx context.Context, request *OAuth2CallbackRequestDto, options ...RequestOption) (AuthControllerOauth2CallbackRes, error) {
	res, err := c.sendAuthControllerOauth2Callback(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerOauth2Callback(ctx context.Context, request *OAuth2CallbackRequestDto, requestOptions ...RequestOption) (res AuthControllerOauth2CallbackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/callback"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerOauth2CallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerOauth2CallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerRegister invokes AuthController_register operation.
//
// Register as superadmin.
//
// POST /api/auth/register
func (c *Client) AuthControllerRegister(ctx context.Context, request *RegisterRequestDto, options ...RequestOption) (AuthControllerRegisterRes, error) {
	res, err := c.sendAuthControllerRegister(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerRegister(ctx context.Context, request *RegisterRequestDto, requestOptions ...RequestOption) (res AuthControllerRegisterRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/register"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerRegisterRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerRegisterResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AuthControllerTelegramCallback invokes AuthController_telegramCallback operation.
//
// Callback from Telegram OAuth2.
//
// POST /api/auth/oauth2/tg/callback
func (c *Client) AuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, options ...RequestOption) (AuthControllerTelegramCallbackRes, error) {
	res, err := c.sendAuthControllerTelegramCallback(ctx, request, options...)
	return res, err
}

func (c *Client) sendAuthControllerTelegramCallback(ctx context.Context, request *TelegramCallbackRequestDto, requestOptions ...RequestOption) (res AuthControllerTelegramCallbackRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/auth/oauth2/tg/callback"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAuthControllerTelegramCallbackRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeAuthControllerTelegramCallbackResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerCreateConfigProfile invokes ConfigProfileController_createConfigProfile operation.
//
// Create config profile.
//
// POST /api/config-profiles
func (c *Client) ConfigProfileControllerCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequestDto, options ...RequestOption) (ConfigProfileControllerCreateConfigProfileRes, error) {
	res, err := c.sendConfigProfileControllerCreateConfigProfile(ctx, request, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerCreateConfigProfile(ctx context.Context, request *CreateConfigProfileRequestDto, requestOptions ...RequestOption) (res ConfigProfileControllerCreateConfigProfileRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigProfileControllerCreateConfigProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerCreateConfigProfileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerCreateConfigProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerDeleteConfigProfileByUuid invokes ConfigProfileController_deleteConfigProfileByUuid operation.
//
// Delete config profile.
//
// DELETE /api/config-profiles/{uuid}
func (c *Client) ConfigProfileControllerDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerDeleteConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileControllerDeleteConfigProfileByUuidRes, error) {
	res, err := c.sendConfigProfileControllerDeleteConfigProfileByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerDeleteConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerDeleteConfigProfileByUuidParams, requestOptions ...RequestOption) (res ConfigProfileControllerDeleteConfigProfileByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerDeleteConfigProfileByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerDeleteConfigProfileByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerGetAllInbounds invokes ConfigProfileController_getAllInbounds operation.
//
// Get all inbounds from all config profiles.
//
// GET /api/config-profiles/inbounds
func (c *Client) ConfigProfileControllerGetAllInbounds(ctx context.Context, options ...RequestOption) (ConfigProfileControllerGetAllInboundsRes, error) {
	res, err := c.sendConfigProfileControllerGetAllInbounds(ctx, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerGetAllInbounds(ctx context.Context, requestOptions ...RequestOption) (res ConfigProfileControllerGetAllInboundsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles/inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerGetAllInboundsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerGetAllInboundsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerGetConfigProfileByUuid invokes ConfigProfileController_getConfigProfileByUuid operation.
//
// Get config profile by uuid.
//
// GET /api/config-profiles/{uuid}
func (c *Client) ConfigProfileControllerGetConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerGetConfigProfileByUuidParams, options ...RequestOption) (ConfigProfileControllerGetConfigProfileByUuidRes, error) {
	res, err := c.sendConfigProfileControllerGetConfigProfileByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerGetConfigProfileByUuid(ctx context.Context, params ConfigProfileControllerGetConfigProfileByUuidParams, requestOptions ...RequestOption) (res ConfigProfileControllerGetConfigProfileByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerGetConfigProfileByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerGetConfigProfileByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerGetConfigProfiles invokes ConfigProfileController_getConfigProfiles operation.
//
// Get config profiles.
//
// GET /api/config-profiles
func (c *Client) ConfigProfileControllerGetConfigProfiles(ctx context.Context, options ...RequestOption) (ConfigProfileControllerGetConfigProfilesRes, error) {
	res, err := c.sendConfigProfileControllerGetConfigProfiles(ctx, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerGetConfigProfiles(ctx context.Context, requestOptions ...RequestOption) (res ConfigProfileControllerGetConfigProfilesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerGetConfigProfilesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerGetConfigProfilesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerGetInboundsByProfileUuid invokes ConfigProfileController_getInboundsByProfileUuid operation.
//
// Get inbounds by profile uuid.
//
// GET /api/config-profiles/{uuid}/inbounds
func (c *Client) ConfigProfileControllerGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileControllerGetInboundsByProfileUuidParams, options ...RequestOption) (ConfigProfileControllerGetInboundsByProfileUuidRes, error) {
	res, err := c.sendConfigProfileControllerGetInboundsByProfileUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerGetInboundsByProfileUuid(ctx context.Context, params ConfigProfileControllerGetInboundsByProfileUuidParams, requestOptions ...RequestOption) (res ConfigProfileControllerGetInboundsByProfileUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/config-profiles/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/inbounds"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerGetInboundsByProfileUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerGetInboundsByProfileUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ConfigProfileControllerUpdateConfigProfile invokes ConfigProfileController_updateConfigProfile operation.
//
// Update Core Config in specific config profile.
//
// PATCH /api/config-profiles
func (c *Client) ConfigProfileControllerUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequestDto, options ...RequestOption) (ConfigProfileControllerUpdateConfigProfileRes, error) {
	res, err := c.sendConfigProfileControllerUpdateConfigProfile(ctx, request, options...)
	return res, err
}

func (c *Client) sendConfigProfileControllerUpdateConfigProfile(ctx context.Context, request *UpdateConfigProfileRequestDto, requestOptions ...RequestOption) (res ConfigProfileControllerUpdateConfigProfileRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/config-profiles"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeConfigProfileControllerUpdateConfigProfileRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, ConfigProfileControllerUpdateConfigProfileOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeConfigProfileControllerUpdateConfigProfileResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerDeleteHosts invokes HostsBulkActionsController_deleteHosts operation.
//
// Delete hosts by UUIDs.
//
// POST /api/hosts/bulk/delete
func (c *Client) HostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerDeleteHostsRes, error) {
	res, err := c.sendHostsBulkActionsControllerDeleteHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerDeleteHosts(ctx context.Context, request *BulkDeleteHostsRequestDto, requestOptions ...RequestOption) (res HostsBulkActionsControllerDeleteHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerDeleteHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerDeleteHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerDeleteHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerDisableHosts invokes HostsBulkActionsController_disableHosts operation.
//
// Disable hosts by UUIDs.
//
// POST /api/hosts/bulk/disable
func (c *Client) HostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerDisableHostsRes, error) {
	res, err := c.sendHostsBulkActionsControllerDisableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerDisableHosts(ctx context.Context, request *BulkDisableHostsRequestDto, requestOptions ...RequestOption) (res HostsBulkActionsControllerDisableHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerDisableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerDisableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerDisableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerEnableHosts invokes HostsBulkActionsController_enableHosts operation.
//
// Enable hosts by UUIDs.
//
// POST /api/hosts/bulk/enable
func (c *Client) HostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerEnableHostsRes, error) {
	res, err := c.sendHostsBulkActionsControllerEnableHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerEnableHosts(ctx context.Context, request *BulkEnableHostsRequestDto, requestOptions ...RequestOption) (res HostsBulkActionsControllerEnableHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerEnableHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerEnableHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerEnableHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerSetInboundToHosts invokes HostsBulkActionsController_setInboundToHosts operation.
//
// Set inbound to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-inbound
func (c *Client) HostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerSetInboundToHostsRes, error) {
	res, err := c.sendHostsBulkActionsControllerSetInboundToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerSetInboundToHosts(ctx context.Context, request *SetInboundToManyHostsRequestDto, requestOptions ...RequestOption) (res HostsBulkActionsControllerSetInboundToHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-inbound"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerSetInboundToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerSetInboundToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerSetInboundToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsBulkActionsControllerSetPortToHosts invokes HostsBulkActionsController_setPortToHosts operation.
//
// Set port to hosts by UUIDs.
//
// POST /api/hosts/bulk/set-port
func (c *Client) HostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, options ...RequestOption) (HostsBulkActionsControllerSetPortToHostsRes, error) {
	res, err := c.sendHostsBulkActionsControllerSetPortToHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsBulkActionsControllerSetPortToHosts(ctx context.Context, request *SetPortToManyHostsRequestDto, requestOptions ...RequestOption) (res HostsBulkActionsControllerSetPortToHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/bulk/set-port"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsBulkActionsControllerSetPortToHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsBulkActionsControllerSetPortToHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsBulkActionsControllerSetPortToHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerCreateHost invokes HostsController_createHost operation.
//
// Create a new host.
//
// POST /api/hosts
func (c *Client) HostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, options ...RequestOption) (HostsControllerCreateHostRes, error) {
	res, err := c.sendHostsControllerCreateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerCreateHost(ctx context.Context, request *CreateHostRequestDto, requestOptions ...RequestOption) (res HostsControllerCreateHostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerCreateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerCreateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerCreateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerDeleteHost invokes HostsController_deleteHost operation.
//
// Delete a host by UUID.
//
// DELETE /api/hosts/{uuid}
func (c *Client) HostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, options ...RequestOption) (HostsControllerDeleteHostRes, error) {
	res, err := c.sendHostsControllerDeleteHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsControllerDeleteHost(ctx context.Context, params HostsControllerDeleteHostParams, requestOptions ...RequestOption) (res HostsControllerDeleteHostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerDeleteHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerDeleteHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerGetAllHosts invokes HostsController_getAllHosts operation.
//
// Get all hosts.
//
// GET /api/hosts
func (c *Client) HostsControllerGetAllHosts(ctx context.Context, options ...RequestOption) (HostsControllerGetAllHostsRes, error) {
	res, err := c.sendHostsControllerGetAllHosts(ctx, options...)
	return res, err
}

func (c *Client) sendHostsControllerGetAllHosts(ctx context.Context, requestOptions ...RequestOption) (res HostsControllerGetAllHostsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerGetAllHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerGetAllHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerGetOneHost invokes HostsController_getOneHost operation.
//
// Get a host by UUID.
//
// GET /api/hosts/{uuid}
func (c *Client) HostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, options ...RequestOption) (HostsControllerGetOneHostRes, error) {
	res, err := c.sendHostsControllerGetOneHost(ctx, params, options...)
	return res, err
}

func (c *Client) sendHostsControllerGetOneHost(ctx context.Context, params HostsControllerGetOneHostParams, requestOptions ...RequestOption) (res HostsControllerGetOneHostRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hosts/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerGetOneHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerGetOneHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerReorderHosts invokes HostsController_reorderHosts operation.
//
// Reorder hosts.
//
// POST /api/hosts/actions/reorder
func (c *Client) HostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, options ...RequestOption) (HostsControllerReorderHostsRes, error) {
	res, err := c.sendHostsControllerReorderHosts(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerReorderHosts(ctx context.Context, request *ReorderHostRequestDto, requestOptions ...RequestOption) (res HostsControllerReorderHostsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerReorderHostsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerReorderHostsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerReorderHostsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HostsControllerUpdateHost invokes HostsController_updateHost operation.
//
// Update a host.
//
// PATCH /api/hosts
func (c *Client) HostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, options ...RequestOption) (HostsControllerUpdateHostRes, error) {
	res, err := c.sendHostsControllerUpdateHost(ctx, request, options...)
	return res, err
}

func (c *Client) sendHostsControllerUpdateHost(ctx context.Context, request *UpdateHostRequestDto, requestOptions ...RequestOption) (res HostsControllerUpdateHostRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hosts"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHostsControllerUpdateHostRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HostsControllerUpdateHostOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHostsControllerUpdateHostResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerCreateUserHwidDevice invokes HwidUserDevicesController_createUserHwidDevice operation.
//
// Create a user HWID device.
//
// POST /api/hwid/devices
func (c *Client) HwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, options ...RequestOption) (HwidUserDevicesControllerCreateUserHwidDeviceRes, error) {
	res, err := c.sendHwidUserDevicesControllerCreateUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerCreateUserHwidDevice(ctx context.Context, request *CreateUserHwidDeviceRequestDto, requestOptions ...RequestOption) (res HwidUserDevicesControllerCreateUserHwidDeviceRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesControllerCreateUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerCreateUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerCreateUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerDeleteUserHwidDevice invokes HwidUserDevicesController_deleteUserHwidDevice operation.
//
// Delete a user HWID device.
//
// POST /api/hwid/devices/delete
func (c *Client) HwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, options ...RequestOption) (HwidUserDevicesControllerDeleteUserHwidDeviceRes, error) {
	res, err := c.sendHwidUserDevicesControllerDeleteUserHwidDevice(ctx, request, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerDeleteUserHwidDevice(ctx context.Context, request *DeleteUserHwidDeviceRequestDto, requestOptions ...RequestOption) (res HwidUserDevicesControllerDeleteUserHwidDeviceRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/hwid/devices/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeHwidUserDevicesControllerDeleteUserHwidDeviceRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerDeleteUserHwidDeviceOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerDeleteUserHwidDeviceResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// HwidUserDevicesControllerGetUserHwidDevices invokes HwidUserDevicesController_getUserHwidDevices operation.
//
// Get user HWID devices.
//
// GET /api/hwid/devices/{userUuid}
func (c *Client) HwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, options ...RequestOption) (HwidUserDevicesControllerGetUserHwidDevicesRes, error) {
	res, err := c.sendHwidUserDevicesControllerGetUserHwidDevices(ctx, params, options...)
	return res, err
}

func (c *Client) sendHwidUserDevicesControllerGetUserHwidDevices(ctx context.Context, params HwidUserDevicesControllerGetUserHwidDevicesParams, requestOptions ...RequestOption) (res HwidUserDevicesControllerGetUserHwidDevicesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/hwid/devices/"
	{
		// Encode "userUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "userUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UserUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, HwidUserDevicesControllerGetUserHwidDevicesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeHwidUserDevicesControllerGetUserHwidDevicesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerCreateInfraBillingHistoryRecord invokes InfraBillingController_createInfraBillingHistoryRecord operation.
//
// Create infra billing history.
//
// POST /api/infra-billing/history
func (c *Client) InfraBillingControllerCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraBillingHistoryRecordRes, error) {
	res, err := c.sendInfraBillingControllerCreateInfraBillingHistoryRecord(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerCreateInfraBillingHistoryRecord(ctx context.Context, request *CreateInfraBillingHistoryRecordRequestDto, requestOptions ...RequestOption) (res InfraBillingControllerCreateInfraBillingHistoryRecordRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/history"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingControllerCreateInfraBillingHistoryRecordRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerCreateInfraBillingHistoryRecordOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerCreateInfraBillingHistoryRecordResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerCreateInfraBillingNode invokes InfraBillingController_createInfraBillingNode operation.
//
// Create infra billing node.
//
// POST /api/infra-billing/nodes
func (c *Client) InfraBillingControllerCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraBillingNodeRes, error) {
	res, err := c.sendInfraBillingControllerCreateInfraBillingNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerCreateInfraBillingNode(ctx context.Context, request *CreateInfraBillingNodeRequestDto, requestOptions ...RequestOption) (res InfraBillingControllerCreateInfraBillingNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingControllerCreateInfraBillingNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerCreateInfraBillingNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerCreateInfraBillingNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerCreateInfraProvider invokes InfraBillingController_createInfraProvider operation.
//
// Create infra provider.
//
// POST /api/infra-billing/providers
func (c *Client) InfraBillingControllerCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequestDto, options ...RequestOption) (InfraBillingControllerCreateInfraProviderRes, error) {
	res, err := c.sendInfraBillingControllerCreateInfraProvider(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerCreateInfraProvider(ctx context.Context, request *CreateInfraProviderRequestDto, requestOptions ...RequestOption) (res InfraBillingControllerCreateInfraProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingControllerCreateInfraProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerCreateInfraProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerCreateInfraProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerDeleteInfraBillingHistoryRecordByUuid invokes InfraBillingController_deleteInfraBillingHistoryRecordByUuid operation.
//
// Delete infra billing history.
//
// DELETE /api/infra-billing/history/{uuid}
func (c *Client) InfraBillingControllerDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidRes, error) {
	res, err := c.sendInfraBillingControllerDeleteInfraBillingHistoryRecordByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerDeleteInfraBillingHistoryRecordByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidParams, requestOptions ...RequestOption) (res InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/history/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerDeleteInfraBillingHistoryRecordByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerDeleteInfraBillingHistoryRecordByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerDeleteInfraBillingNodeByUuid invokes InfraBillingController_deleteInfraBillingNodeByUuid operation.
//
// Delete infra billing node.
//
// DELETE /api/infra-billing/nodes/{uuid}
func (c *Client) InfraBillingControllerDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingNodeByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraBillingNodeByUuidRes, error) {
	res, err := c.sendInfraBillingControllerDeleteInfraBillingNodeByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerDeleteInfraBillingNodeByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraBillingNodeByUuidParams, requestOptions ...RequestOption) (res InfraBillingControllerDeleteInfraBillingNodeByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerDeleteInfraBillingNodeByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerDeleteInfraBillingNodeByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerDeleteInfraProviderByUuid invokes InfraBillingController_deleteInfraProviderByUuid operation.
//
// Delete infra provider by uuid.
//
// DELETE /api/infra-billing/providers/{uuid}
func (c *Client) InfraBillingControllerDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraProviderByUuidParams, options ...RequestOption) (InfraBillingControllerDeleteInfraProviderByUuidRes, error) {
	res, err := c.sendInfraBillingControllerDeleteInfraProviderByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerDeleteInfraProviderByUuid(ctx context.Context, params InfraBillingControllerDeleteInfraProviderByUuidParams, requestOptions ...RequestOption) (res InfraBillingControllerDeleteInfraProviderByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/providers/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerDeleteInfraProviderByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerDeleteInfraProviderByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerGetBillingNodes invokes InfraBillingController_getBillingNodes operation.
//
// Get infra billing nodes.
//
// GET /api/infra-billing/nodes
func (c *Client) InfraBillingControllerGetBillingNodes(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetBillingNodesRes, error) {
	res, err := c.sendInfraBillingControllerGetBillingNodes(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerGetBillingNodes(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingControllerGetBillingNodesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerGetBillingNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerGetBillingNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerGetInfraBillingHistoryRecords invokes InfraBillingController_getInfraBillingHistoryRecords operation.
//
// Get infra billing history.
//
// GET /api/infra-billing/history
func (c *Client) InfraBillingControllerGetInfraBillingHistoryRecords(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetInfraBillingHistoryRecordsRes, error) {
	res, err := c.sendInfraBillingControllerGetInfraBillingHistoryRecords(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerGetInfraBillingHistoryRecords(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingControllerGetInfraBillingHistoryRecordsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/history"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerGetInfraBillingHistoryRecordsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerGetInfraBillingHistoryRecordsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerGetInfraProviderByUuid invokes InfraBillingController_getInfraProviderByUuid operation.
//
// Get infra provider by uuid.
//
// GET /api/infra-billing/providers/{uuid}
func (c *Client) InfraBillingControllerGetInfraProviderByUuid(ctx context.Context, params InfraBillingControllerGetInfraProviderByUuidParams, options ...RequestOption) (InfraBillingControllerGetInfraProviderByUuidRes, error) {
	res, err := c.sendInfraBillingControllerGetInfraProviderByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerGetInfraProviderByUuid(ctx context.Context, params InfraBillingControllerGetInfraProviderByUuidParams, requestOptions ...RequestOption) (res InfraBillingControllerGetInfraProviderByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/infra-billing/providers/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerGetInfraProviderByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerGetInfraProviderByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerGetInfraProviders invokes InfraBillingController_getInfraProviders operation.
//
// Get all infra providers.
//
// GET /api/infra-billing/providers
func (c *Client) InfraBillingControllerGetInfraProviders(ctx context.Context, options ...RequestOption) (InfraBillingControllerGetInfraProvidersRes, error) {
	res, err := c.sendInfraBillingControllerGetInfraProviders(ctx, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerGetInfraProviders(ctx context.Context, requestOptions ...RequestOption) (res InfraBillingControllerGetInfraProvidersRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerGetInfraProvidersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerGetInfraProvidersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerUpdateInfraBillingNode invokes InfraBillingController_updateInfraBillingNode operation.
//
// Update infra billing node.
//
// PATCH /api/infra-billing/nodes
func (c *Client) InfraBillingControllerUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequestDto, options ...RequestOption) (InfraBillingControllerUpdateInfraBillingNodeRes, error) {
	res, err := c.sendInfraBillingControllerUpdateInfraBillingNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerUpdateInfraBillingNode(ctx context.Context, request *UpdateInfraBillingNodeRequestDto, requestOptions ...RequestOption) (res InfraBillingControllerUpdateInfraBillingNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingControllerUpdateInfraBillingNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerUpdateInfraBillingNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerUpdateInfraBillingNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InfraBillingControllerUpdateInfraProvider invokes InfraBillingController_updateInfraProvider operation.
//
// Update infra provider.
//
// PATCH /api/infra-billing/providers
func (c *Client) InfraBillingControllerUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequestDto, options ...RequestOption) (InfraBillingControllerUpdateInfraProviderRes, error) {
	res, err := c.sendInfraBillingControllerUpdateInfraProvider(ctx, request, options...)
	return res, err
}

func (c *Client) sendInfraBillingControllerUpdateInfraProvider(ctx context.Context, request *UpdateInfraProviderRequestDto, requestOptions ...RequestOption) (res InfraBillingControllerUpdateInfraProviderRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/infra-billing/providers"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInfraBillingControllerUpdateInfraProviderRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InfraBillingControllerUpdateInfraProviderOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInfraBillingControllerUpdateInfraProviderResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerAddUsersToInternalSquad invokes InternalSquadController_addUsersToInternalSquad operation.
//
// Add all users to internal squad.
//
// POST /api/internal-squads/{uuid}/bulk-actions/add-users
func (c *Client) InternalSquadControllerAddUsersToInternalSquad(ctx context.Context, params InternalSquadControllerAddUsersToInternalSquadParams, options ...RequestOption) (InternalSquadControllerAddUsersToInternalSquadRes, error) {
	res, err := c.sendInternalSquadControllerAddUsersToInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerAddUsersToInternalSquad(ctx context.Context, params InternalSquadControllerAddUsersToInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadControllerAddUsersToInternalSquadRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/add-users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerAddUsersToInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerAddUsersToInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerCreateInternalSquad invokes InternalSquadController_createInternalSquad operation.
//
// Create internal squad.
//
// POST /api/internal-squads
func (c *Client) InternalSquadControllerCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequestDto, options ...RequestOption) (InternalSquadControllerCreateInternalSquadRes, error) {
	res, err := c.sendInternalSquadControllerCreateInternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerCreateInternalSquad(ctx context.Context, request *CreateInternalSquadRequestDto, requestOptions ...RequestOption) (res InternalSquadControllerCreateInternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInternalSquadControllerCreateInternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerCreateInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerCreateInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerDeleteInternalSquad invokes InternalSquadController_deleteInternalSquad operation.
//
// Delete internal squad.
//
// DELETE /api/internal-squads/{uuid}
func (c *Client) InternalSquadControllerDeleteInternalSquad(ctx context.Context, params InternalSquadControllerDeleteInternalSquadParams, options ...RequestOption) (InternalSquadControllerDeleteInternalSquadRes, error) {
	res, err := c.sendInternalSquadControllerDeleteInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerDeleteInternalSquad(ctx context.Context, params InternalSquadControllerDeleteInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadControllerDeleteInternalSquadRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerDeleteInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerDeleteInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerGetInternalSquadByUuid invokes InternalSquadController_getInternalSquadByUuid operation.
//
// Get internal squad by uuid.
//
// GET /api/internal-squads/{uuid}
func (c *Client) InternalSquadControllerGetInternalSquadByUuid(ctx context.Context, params InternalSquadControllerGetInternalSquadByUuidParams, options ...RequestOption) (InternalSquadControllerGetInternalSquadByUuidRes, error) {
	res, err := c.sendInternalSquadControllerGetInternalSquadByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerGetInternalSquadByUuid(ctx context.Context, params InternalSquadControllerGetInternalSquadByUuidParams, requestOptions ...RequestOption) (res InternalSquadControllerGetInternalSquadByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerGetInternalSquadByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerGetInternalSquadByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerGetInternalSquads invokes InternalSquadController_getInternalSquads operation.
//
// Get all internal squads.
//
// GET /api/internal-squads
func (c *Client) InternalSquadControllerGetInternalSquads(ctx context.Context, options ...RequestOption) (InternalSquadControllerGetInternalSquadsRes, error) {
	res, err := c.sendInternalSquadControllerGetInternalSquads(ctx, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerGetInternalSquads(ctx context.Context, requestOptions ...RequestOption) (res InternalSquadControllerGetInternalSquadsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerGetInternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerGetInternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerRemoveUsersFromInternalSquad invokes InternalSquadController_removeUsersFromInternalSquad operation.
//
// Delete users from internal squad.
//
// DELETE /api/internal-squads/{uuid}/bulk-actions/remove-users
func (c *Client) InternalSquadControllerRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadControllerRemoveUsersFromInternalSquadParams, options ...RequestOption) (InternalSquadControllerRemoveUsersFromInternalSquadRes, error) {
	res, err := c.sendInternalSquadControllerRemoveUsersFromInternalSquad(ctx, params, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerRemoveUsersFromInternalSquad(ctx context.Context, params InternalSquadControllerRemoveUsersFromInternalSquadParams, requestOptions ...RequestOption) (res InternalSquadControllerRemoveUsersFromInternalSquadRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/internal-squads/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/bulk-actions/remove-users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerRemoveUsersFromInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerRemoveUsersFromInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InternalSquadControllerUpdateInternalSquad invokes InternalSquadController_updateInternalSquad operation.
//
// Update internal squad.
//
// PATCH /api/internal-squads
func (c *Client) InternalSquadControllerUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequestDto, options ...RequestOption) (InternalSquadControllerUpdateInternalSquadRes, error) {
	res, err := c.sendInternalSquadControllerUpdateInternalSquad(ctx, request, options...)
	return res, err
}

func (c *Client) sendInternalSquadControllerUpdateInternalSquad(ctx context.Context, request *UpdateInternalSquadRequestDto, requestOptions ...RequestOption) (res InternalSquadControllerUpdateInternalSquadRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/internal-squads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInternalSquadControllerUpdateInternalSquadRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, InternalSquadControllerUpdateInternalSquadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeInternalSquadControllerUpdateInternalSquadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// KeygenControllerGenerateKey invokes KeygenController_generateKey operation.
//
// Get SSL_CERT for Remnawave Node.
//
// GET /api/keygen
func (c *Client) KeygenControllerGenerateKey(ctx context.Context, options ...RequestOption) (KeygenControllerGenerateKeyRes, error) {
	res, err := c.sendKeygenControllerGenerateKey(ctx, options...)
	return res, err
}

func (c *Client) sendKeygenControllerGenerateKey(ctx context.Context, requestOptions ...RequestOption) (res KeygenControllerGenerateKeyRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/keygen"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, KeygenControllerGenerateKeyOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeKeygenControllerGenerateKeyResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerCreateNode invokes NodesController_createNode operation.
//
// Create a new node.
//
// POST /api/nodes
func (c *Client) NodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, options ...RequestOption) (NodesControllerCreateNodeRes, error) {
	res, err := c.sendNodesControllerCreateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerCreateNode(ctx context.Context, request *CreateNodeRequestDto, requestOptions ...RequestOption) (res NodesControllerCreateNodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerCreateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerCreateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerCreateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerDeleteNode invokes NodesController_deleteNode operation.
//
// Delete a node.
//
// DELETE /api/nodes/{uuid}
func (c *Client) NodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, options ...RequestOption) (NodesControllerDeleteNodeRes, error) {
	res, err := c.sendNodesControllerDeleteNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerDeleteNode(ctx context.Context, params NodesControllerDeleteNodeParams, requestOptions ...RequestOption) (res NodesControllerDeleteNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerDeleteNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerDeleteNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerDisableNode invokes NodesController_disableNode operation.
//
// Disable a node.
//
// POST /api/nodes/{uuid}/actions/disable
func (c *Client) NodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, options ...RequestOption) (NodesControllerDisableNodeRes, error) {
	res, err := c.sendNodesControllerDisableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerDisableNode(ctx context.Context, params NodesControllerDisableNodeParams, requestOptions ...RequestOption) (res NodesControllerDisableNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerDisableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerDisableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerEnableNode invokes NodesController_enableNode operation.
//
// Enable a node.
//
// POST /api/nodes/{uuid}/actions/enable
func (c *Client) NodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, options ...RequestOption) (NodesControllerEnableNodeRes, error) {
	res, err := c.sendNodesControllerEnableNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerEnableNode(ctx context.Context, params NodesControllerEnableNodeParams, requestOptions ...RequestOption) (res NodesControllerEnableNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerEnableNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerEnableNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerGetAllNodes invokes NodesController_getAllNodes operation.
//
// Get all nodes.
//
// GET /api/nodes
func (c *Client) NodesControllerGetAllNodes(ctx context.Context, options ...RequestOption) (NodesControllerGetAllNodesRes, error) {
	res, err := c.sendNodesControllerGetAllNodes(ctx, options...)
	return res, err
}

func (c *Client) sendNodesControllerGetAllNodes(ctx context.Context, requestOptions ...RequestOption) (res NodesControllerGetAllNodesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerGetAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerGetAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerGetOneNode invokes NodesController_getOneNode operation.
//
// Get node by UUID.
//
// GET /api/nodes/{uuid}
func (c *Client) NodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, options ...RequestOption) (NodesControllerGetOneNodeRes, error) {
	res, err := c.sendNodesControllerGetOneNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerGetOneNode(ctx context.Context, params NodesControllerGetOneNodeParams, requestOptions ...RequestOption) (res NodesControllerGetOneNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerGetOneNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerGetOneNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerReorderNodes invokes NodesController_reorderNodes operation.
//
// Reorder nodes.
//
// POST /api/nodes/actions/reorder
func (c *Client) NodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, options ...RequestOption) (NodesControllerReorderNodesRes, error) {
	res, err := c.sendNodesControllerReorderNodes(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerReorderNodes(ctx context.Context, request *ReorderNodeRequestDto, requestOptions ...RequestOption) (res NodesControllerReorderNodesRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/reorder"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerReorderNodesRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerReorderNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerReorderNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerRestartAllNodes invokes NodesController_restartAllNodes operation.
//
// Restart all nodes.
//
// POST /api/nodes/actions/restart-all
func (c *Client) NodesControllerRestartAllNodes(ctx context.Context, options ...RequestOption) (NodesControllerRestartAllNodesRes, error) {
	res, err := c.sendNodesControllerRestartAllNodes(ctx, options...)
	return res, err
}

func (c *Client) sendNodesControllerRestartAllNodes(ctx context.Context, requestOptions ...RequestOption) (res NodesControllerRestartAllNodesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/actions/restart-all"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerRestartAllNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerRestartAllNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerRestartNode invokes NodesController_restartNode operation.
//
// Restart node.
//
// POST /api/nodes/{uuid}/actions/restart
func (c *Client) NodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, options ...RequestOption) (NodesControllerRestartNodeRes, error) {
	res, err := c.sendNodesControllerRestartNode(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesControllerRestartNode(ctx context.Context, params NodesControllerRestartNodeParams, requestOptions ...RequestOption) (res NodesControllerRestartNodeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/restart"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerRestartNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerRestartNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesControllerUpdateNode invokes NodesController_updateNode operation.
//
// Update node.
//
// PATCH /api/nodes
func (c *Client) NodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, options ...RequestOption) (NodesControllerUpdateNodeRes, error) {
	res, err := c.sendNodesControllerUpdateNode(ctx, request, options...)
	return res, err
}

func (c *Client) sendNodesControllerUpdateNode(ctx context.Context, request *UpdateNodeRequestDto, requestOptions ...RequestOption) (res NodesControllerUpdateNodeRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeNodesControllerUpdateNodeRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesControllerUpdateNodeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesControllerUpdateNodeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUsageHistoryControllerGetNodesUsageByRange invokes NodesUsageHistoryController_getNodesUsageByRange operation.
//
// Get nodes usage by range.
//
// GET /api/nodes/usage/range
func (c *Client) NodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, options ...RequestOption) (NodesUsageHistoryControllerGetNodesUsageByRangeRes, error) {
	res, err := c.sendNodesUsageHistoryControllerGetNodesUsageByRange(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesUsageHistoryControllerGetNodesUsageByRange(ctx context.Context, params NodesUsageHistoryControllerGetNodesUsageByRangeParams, requestOptions ...RequestOption) (res NodesUsageHistoryControllerGetNodesUsageByRangeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/usage/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUsageHistoryControllerGetNodesUsageByRangeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUsageHistoryControllerGetNodesUsageByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUserUsageHistoryControllerGetNodeUserUsage invokes NodesUserUsageHistoryController_getNodeUserUsage operation.
//
// Get node user usage by range and Node UUID.
//
// GET /api/nodes/usage/{uuid}/users/range
func (c *Client) NodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, options ...RequestOption) (NodesUserUsageHistoryControllerGetNodeUserUsageRes, error) {
	res, err := c.sendNodesUserUsageHistoryControllerGetNodeUserUsage(ctx, params, options...)
	return res, err
}

func (c *Client) sendNodesUserUsageHistoryControllerGetNodeUserUsage(ctx context.Context, params NodesUserUsageHistoryControllerGetNodeUserUsageParams, requestOptions ...RequestOption) (res NodesUserUsageHistoryControllerGetNodeUserUsageRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/nodes/usage/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/users/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUserUsageHistoryControllerGetNodeUserUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUserUsageHistoryControllerGetNodeUserUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// NodesUserUsageHistoryControllerGetNodesRealtimeUsage invokes NodesUserUsageHistoryController_getNodesRealtimeUsage operation.
//
// Get nodes realtime usage.
//
// GET /api/nodes/usage/realtime
func (c *Client) NodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, options ...RequestOption) (NodesUserUsageHistoryControllerGetNodesRealtimeUsageRes, error) {
	res, err := c.sendNodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx, options...)
	return res, err
}

func (c *Client) sendNodesUserUsageHistoryControllerGetNodesRealtimeUsage(ctx context.Context, requestOptions ...RequestOption) (res NodesUserUsageHistoryControllerGetNodesRealtimeUsageRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/nodes/usage/realtime"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, NodesUserUsageHistoryControllerGetNodesRealtimeUsageOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeNodesUserUsageHistoryControllerGetNodesRealtimeUsageResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetRawSubscriptionByShortUuid invokes SubscriptionController_getRawSubscriptionByShortUuid operation.
//
// Get Raw Subscription by Short UUID.
//
// GET /api/sub/{shortUuid}/raw
func (c *Client) SubscriptionControllerGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionControllerGetRawSubscriptionByShortUuidParams, options ...RequestOption) (SubscriptionControllerGetRawSubscriptionByShortUuidRes, error) {
	res, err := c.sendSubscriptionControllerGetRawSubscriptionByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionControllerGetRawSubscriptionByShortUuid(ctx context.Context, params SubscriptionControllerGetRawSubscriptionByShortUuidParams, requestOptions ...RequestOption) (res SubscriptionControllerGetRawSubscriptionByShortUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/raw"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionControllerGetRawSubscriptionByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetRawSubscriptionByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscription invokes SubscriptionController_getSubscription operation.
//
// GET /api/sub/{shortUuid}
func (c *Client) SubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscription(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscription(ctx context.Context, params SubscriptionControllerGetSubscriptionParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionByClientType invokes SubscriptionController_getSubscriptionByClientType operation.
//
// GET /api/sub/{shortUuid}/{clientType}
func (c *Client) SubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscriptionByClientType(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionByClientType(ctx context.Context, params SubscriptionControllerGetSubscriptionByClientTypeParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionByClientTypeOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [4]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "clientType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "clientType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.ClientType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionByClientTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionInfoByShortUuid invokes SubscriptionController_getSubscriptionInfoByShortUuid operation.
//
// Get Subscription Info by Short UUID.
//
// GET /api/sub/{shortUuid}/info
func (c *Client) SubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, options ...RequestOption) (SubscriptionControllerGetSubscriptionInfoByShortUuidRes, error) {
	res, err := c.sendSubscriptionControllerGetSubscriptionInfoByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionInfoByShortUuid(ctx context.Context, params SubscriptionControllerGetSubscriptionInfoByShortUuidParams, requestOptions ...RequestOption) (res SubscriptionControllerGetSubscriptionInfoByShortUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/sub/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/info"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionInfoByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionControllerGetSubscriptionWithType invokes SubscriptionController_getSubscriptionWithType operation.
//
// GET /api/sub/outline/{shortUuid}/{type}/{encodedTag}
func (c *Client) SubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, options ...RequestOption) error {
	_, err := c.sendSubscriptionControllerGetSubscriptionWithType(ctx, params, options...)
	return err
}

func (c *Client) sendSubscriptionControllerGetSubscriptionWithType(ctx context.Context, params SubscriptionControllerGetSubscriptionWithTypeParams, requestOptions ...RequestOption) (res *SubscriptionControllerGetSubscriptionWithTypeOK, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [6]string
	pathParts[0] = "/api/sub/outline/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/"
	{
		// Encode "type" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "type",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Type))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[3] = encoded
	}
	pathParts[4] = "/"
	{
		// Encode "encodedTag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "encodedTag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.EncodedTag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[5] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionControllerGetSubscriptionWithTypeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsControllerGetSettings invokes SubscriptionSettingsController_getSettings operation.
//
// Get subscription settings.
//
// GET /api/subscription-settings
func (c *Client) SubscriptionSettingsControllerGetSettings(ctx context.Context, options ...RequestOption) (SubscriptionSettingsControllerGetSettingsRes, error) {
	res, err := c.sendSubscriptionSettingsControllerGetSettings(ctx, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsControllerGetSettings(ctx context.Context, requestOptions ...RequestOption) (res SubscriptionSettingsControllerGetSettingsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionSettingsControllerGetSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionSettingsControllerGetSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionSettingsControllerUpdateSettings invokes SubscriptionSettingsController_updateSettings operation.
//
// Update subscription settings.
//
// PATCH /api/subscription-settings
func (c *Client) SubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, options ...RequestOption) (SubscriptionSettingsControllerUpdateSettingsRes, error) {
	res, err := c.sendSubscriptionSettingsControllerUpdateSettings(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionSettingsControllerUpdateSettings(ctx context.Context, request *UpdateSubscriptionSettingsRequestDto, requestOptions ...RequestOption) (res SubscriptionSettingsControllerUpdateSettingsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-settings"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionSettingsControllerUpdateSettingsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionSettingsControllerUpdateSettingsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionSettingsControllerUpdateSettingsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateControllerGetTemplate invokes SubscriptionTemplateController_getTemplate operation.
//
// Get subscription template.
//
// GET /api/subscription-templates/{templateType}
func (c *Client) SubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, options ...RequestOption) (SubscriptionTemplateControllerGetTemplateRes, error) {
	res, err := c.sendSubscriptionTemplateControllerGetTemplate(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateControllerGetTemplate(ctx context.Context, params SubscriptionTemplateControllerGetTemplateParams, requestOptions ...RequestOption) (res SubscriptionTemplateControllerGetTemplateRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscription-templates/"
	{
		// Encode "templateType" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "templateType",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.TemplateType)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionTemplateControllerGetTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionTemplateControllerGetTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionTemplateControllerUpdateTemplate invokes SubscriptionTemplateController_updateTemplate operation.
//
// Update subscription template.
//
// PUT /api/subscription-templates
func (c *Client) SubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, options ...RequestOption) (SubscriptionTemplateControllerUpdateTemplateRes, error) {
	res, err := c.sendSubscriptionTemplateControllerUpdateTemplate(ctx, request, options...)
	return res, err
}

func (c *Client) sendSubscriptionTemplateControllerUpdateTemplate(ctx context.Context, request *UpdateTemplateRequestDto, requestOptions ...RequestOption) (res SubscriptionTemplateControllerUpdateTemplateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscription-templates"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeSubscriptionTemplateControllerUpdateTemplateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionTemplateControllerUpdateTemplateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionTemplateControllerUpdateTemplateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsControllerGetAllSubscriptions invokes SubscriptionsController_getAllSubscriptions operation.
//
// Get all subscriptions.
//
// GET /api/subscriptions
func (c *Client) SubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, options ...RequestOption) (SubscriptionsControllerGetAllSubscriptionsRes, error) {
	res, err := c.sendSubscriptionsControllerGetAllSubscriptions(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsControllerGetAllSubscriptions(ctx context.Context, params SubscriptionsControllerGetAllSubscriptionsParams, requestOptions ...RequestOption) (res SubscriptionsControllerGetAllSubscriptionsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/subscriptions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionsControllerGetAllSubscriptionsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionsControllerGetAllSubscriptionsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SubscriptionsControllerGetSubscriptionByUsername invokes SubscriptionsController_getSubscriptionByUsername operation.
//
// Get subscription by username.
//
// GET /api/subscriptions/by-username/{username}
func (c *Client) SubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, options ...RequestOption) (SubscriptionsControllerGetSubscriptionByUsernameRes, error) {
	res, err := c.sendSubscriptionsControllerGetSubscriptionByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendSubscriptionsControllerGetSubscriptionByUsername(ctx context.Context, params SubscriptionsControllerGetSubscriptionByUsernameParams, requestOptions ...RequestOption) (res SubscriptionsControllerGetSubscriptionByUsernameRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/subscriptions/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SubscriptionsControllerGetSubscriptionByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSubscriptionsControllerGetSubscriptionByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetBandwidthStats invokes SystemController_getBandwidthStats operation.
//
// Get Bandwidth Stats.
//
// GET /api/system/stats/bandwidth
func (c *Client) SystemControllerGetBandwidthStats(ctx context.Context, options ...RequestOption) (SystemControllerGetBandwidthStatsRes, error) {
	res, err := c.sendSystemControllerGetBandwidthStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetBandwidthStats(ctx context.Context, requestOptions ...RequestOption) (res SystemControllerGetBandwidthStatsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/bandwidth"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetBandwidthStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetBandwidthStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetNodesMetrics invokes SystemController_getNodesMetrics operation.
//
// Get Nodes Metrics.
//
// GET /api/system/nodes/metrics
func (c *Client) SystemControllerGetNodesMetrics(ctx context.Context, options ...RequestOption) (SystemControllerGetNodesMetricsRes, error) {
	res, err := c.sendSystemControllerGetNodesMetrics(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetNodesMetrics(ctx context.Context, requestOptions ...RequestOption) (res SystemControllerGetNodesMetricsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/nodes/metrics"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetNodesMetricsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetNodesMetricsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetNodesStatistics invokes SystemController_getNodesStatistics operation.
//
// Get Nodes Statistics.
//
// GET /api/system/stats/nodes
func (c *Client) SystemControllerGetNodesStatistics(ctx context.Context, options ...RequestOption) (SystemControllerGetNodesStatisticsRes, error) {
	res, err := c.sendSystemControllerGetNodesStatistics(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetNodesStatistics(ctx context.Context, requestOptions ...RequestOption) (res SystemControllerGetNodesStatisticsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats/nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetNodesStatisticsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetNodesStatisticsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetRemnawaveHealth invokes SystemController_getRemnawaveHealth operation.
//
// Get Remnawave Health.
//
// GET /api/system/health
func (c *Client) SystemControllerGetRemnawaveHealth(ctx context.Context, options ...RequestOption) (SystemControllerGetRemnawaveHealthRes, error) {
	res, err := c.sendSystemControllerGetRemnawaveHealth(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetRemnawaveHealth(ctx context.Context, requestOptions ...RequestOption) (res SystemControllerGetRemnawaveHealthRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/health"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetRemnawaveHealthOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetRemnawaveHealthResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// SystemControllerGetStats invokes SystemController_getStats operation.
//
// Get Stats.
//
// GET /api/system/stats
func (c *Client) SystemControllerGetStats(ctx context.Context, options ...RequestOption) (SystemControllerGetStatsRes, error) {
	res, err := c.sendSystemControllerGetStats(ctx, options...)
	return res, err
}

func (c *Client) sendSystemControllerGetStats(ctx context.Context, requestOptions ...RequestOption) (res SystemControllerGetStatsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/system/stats"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, SystemControllerGetStatsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeSystemControllerGetStatsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkAllResetUserTraffic invokes UsersBulkActionsController_bulkAllResetUserTraffic operation.
//
// Bulk reset all users traffic.
//
// POST /api/users/bulk/all/reset-traffic
func (c *Client) UsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, options ...RequestOption) (UsersBulkActionsControllerBulkAllResetUserTrafficRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkAllResetUserTraffic(ctx, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkAllResetUserTraffic(ctx context.Context, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkAllResetUserTrafficRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkAllResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkAllResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkDeleteUsers invokes UsersBulkActionsController_bulkDeleteUsers operation.
//
// Bulk delete users by UUIDs.
//
// POST /api/users/bulk/delete
func (c *Client) UsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkDeleteUsersRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkDeleteUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkDeleteUsers(ctx context.Context, request *BulkDeleteUsersRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkDeleteUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkDeleteUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkDeleteUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkDeleteUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkDeleteUsersByStatus invokes UsersBulkActionsController_bulkDeleteUsersByStatus operation.
//
// Bulk delete users by status.
//
// POST /api/users/bulk/delete-by-status
func (c *Client) UsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkDeleteUsersByStatusRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkDeleteUsersByStatus(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkDeleteUsersByStatus(ctx context.Context, request *BulkDeleteUsersByStatusRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkDeleteUsersByStatusRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/delete-by-status"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkDeleteUsersByStatusRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkDeleteUsersByStatusOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkDeleteUsersByStatusResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkResetUserTraffic invokes UsersBulkActionsController_bulkResetUserTraffic operation.
//
// Bulk reset traffic users by UUIDs.
//
// POST /api/users/bulk/reset-traffic
func (c *Client) UsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkResetUserTrafficRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkResetUserTraffic(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkResetUserTraffic(ctx context.Context, request *BulkResetTrafficUsersRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkResetUserTrafficRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkResetUserTrafficRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkRevokeUsersSubscription invokes UsersBulkActionsController_bulkRevokeUsersSubscription operation.
//
// Revoke users subscription by User UUIDs.
//
// POST /api/users/bulk/revoke-subscription
func (c *Client) UsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkRevokeUsersSubscriptionRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkRevokeUsersSubscription(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkRevokeUsersSubscription(ctx context.Context, request *BulkRevokeUsersSubscriptionRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkRevokeUsersSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/revoke-subscription"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkRevokeUsersSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkRevokeUsersSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkRevokeUsersSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateAllUsers invokes UsersBulkActionsController_bulkUpdateAllUsers operation.
//
// Bulk update all users.
//
// POST /api/users/bulk/all/update
func (c *Client) UsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateAllUsersRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateAllUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateAllUsers(ctx context.Context, request *BulkAllUpdateUsersRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkUpdateAllUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/all/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateAllUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateUsers invokes UsersBulkActionsController_bulkUpdateUsers operation.
//
// Bulk update users by UUIDs.
//
// POST /api/users/bulk/update
func (c *Client) UsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateUsersRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateUsers(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateUsers(ctx context.Context, request *BulkUpdateUsersRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkUpdateUsersRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateUsersRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersBulkActionsControllerBulkUpdateUsersInternalSquads invokes UsersBulkActionsController_bulkUpdateUsersInternalSquads operation.
//
// Bulk update users internal squads by UUIDs.
//
// POST /api/users/bulk/update-squads
func (c *Client) UsersBulkActionsControllerBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequestDto, options ...RequestOption) (UsersBulkActionsControllerBulkUpdateUsersInternalSquadsRes, error) {
	res, err := c.sendUsersBulkActionsControllerBulkUpdateUsersInternalSquads(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersBulkActionsControllerBulkUpdateUsersInternalSquads(ctx context.Context, request *BulkUpdateUsersSquadsRequestDto, requestOptions ...RequestOption) (res UsersBulkActionsControllerBulkUpdateUsersInternalSquadsRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/bulk/update-squads"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersBulkActionsControllerBulkUpdateUsersInternalSquadsRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersBulkActionsControllerBulkUpdateUsersInternalSquadsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersBulkActionsControllerBulkUpdateUsersInternalSquadsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerCreateUser invokes UsersController_createUser operation.
//
// Create a new user.
//
// POST /api/users
func (c *Client) UsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, options ...RequestOption) (UsersControllerCreateUserRes, error) {
	res, err := c.sendUsersControllerCreateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersControllerCreateUser(ctx context.Context, request *CreateUserRequestDto, requestOptions ...RequestOption) (res UsersControllerCreateUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersControllerCreateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerCreateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerCreateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerDeleteUser invokes UsersController_deleteUser operation.
//
// Delete user.
//
// DELETE /api/users/{uuid}
func (c *Client) UsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, options ...RequestOption) (UsersControllerDeleteUserRes, error) {
	res, err := c.sendUsersControllerDeleteUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerDeleteUser(ctx context.Context, params UsersControllerDeleteUserParams, requestOptions ...RequestOption) (res UsersControllerDeleteUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerDeleteUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerDeleteUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerDisableUser invokes UsersController_disableUser operation.
//
// Disable user.
//
// POST /api/users/{uuid}/actions/disable
func (c *Client) UsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, options ...RequestOption) (UsersControllerDisableUserRes, error) {
	res, err := c.sendUsersControllerDisableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerDisableUser(ctx context.Context, params UsersControllerDisableUserParams, requestOptions ...RequestOption) (res UsersControllerDisableUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/disable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerDisableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerDisableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerEnableUser invokes UsersController_enableUser operation.
//
// Enable user.
//
// POST /api/users/{uuid}/actions/enable
func (c *Client) UsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, options ...RequestOption) (UsersControllerEnableUserRes, error) {
	res, err := c.sendUsersControllerEnableUser(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerEnableUser(ctx context.Context, params UsersControllerEnableUserParams, requestOptions ...RequestOption) (res UsersControllerEnableUserRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/enable"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerEnableUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerEnableUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetAllTags invokes UsersController_getAllTags operation.
//
// Get all existing user tags.
//
// GET /api/users/tags
func (c *Client) UsersControllerGetAllTags(ctx context.Context, options ...RequestOption) (UsersControllerGetAllTagsRes, error) {
	res, err := c.sendUsersControllerGetAllTags(ctx, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetAllTags(ctx context.Context, requestOptions ...RequestOption) (res UsersControllerGetAllTagsRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users/tags"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetAllTagsOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetAllTagsResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetAllUsers invokes UsersController_getAllUsers operation.
//
// Get all users.
//
// GET /api/users
func (c *Client) UsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, options ...RequestOption) (UsersControllerGetAllUsersRes, error) {
	res, err := c.sendUsersControllerGetAllUsers(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetAllUsers(ctx context.Context, params UsersControllerGetAllUsersParams, requestOptions ...RequestOption) (res UsersControllerGetAllUsersRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "size",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Size.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Start.Get(); ok {
				return e.EncodeValue(conv.Float64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetAllUsersOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetAllUsersResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserAccessibleNodes invokes UsersController_getUserAccessibleNodes operation.
//
// Get user accessible nodes.
//
// GET /api/users/{uuid}/accessible-nodes
func (c *Client) UsersControllerGetUserAccessibleNodes(ctx context.Context, params UsersControllerGetUserAccessibleNodesParams, options ...RequestOption) (UsersControllerGetUserAccessibleNodesRes, error) {
	res, err := c.sendUsersControllerGetUserAccessibleNodes(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserAccessibleNodes(ctx context.Context, params UsersControllerGetUserAccessibleNodesParams, requestOptions ...RequestOption) (res UsersControllerGetUserAccessibleNodesRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/accessible-nodes"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserAccessibleNodesOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserAccessibleNodesResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByShortUuid invokes UsersController_getUserByShortUuid operation.
//
// Get user by Short UUID.
//
// GET /api/users/by-short-uuid/{shortUuid}
func (c *Client) UsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, options ...RequestOption) (UsersControllerGetUserByShortUuidRes, error) {
	res, err := c.sendUsersControllerGetUserByShortUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByShortUuid(ctx context.Context, params UsersControllerGetUserByShortUuidParams, requestOptions ...RequestOption) (res UsersControllerGetUserByShortUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-short-uuid/"
	{
		// Encode "shortUuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "shortUuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.ShortUuid))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByShortUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByShortUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByTelegramId invokes UsersController_getUserByTelegramId operation.
//
// Get users by telegram ID.
//
// GET /api/users/by-telegram-id/{telegramId}
func (c *Client) UsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, options ...RequestOption) (UsersControllerGetUserByTelegramIdRes, error) {
	res, err := c.sendUsersControllerGetUserByTelegramId(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByTelegramId(ctx context.Context, params UsersControllerGetUserByTelegramIdParams, requestOptions ...RequestOption) (res UsersControllerGetUserByTelegramIdRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-telegram-id/"
	{
		// Encode "telegramId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "telegramId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.TelegramId))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByTelegramIdOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByTelegramIdResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByUsername invokes UsersController_getUserByUsername operation.
//
// Get user by username.
//
// GET /api/users/by-username/{username}
func (c *Client) UsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, options ...RequestOption) (UsersControllerGetUserByUsernameRes, error) {
	res, err := c.sendUsersControllerGetUserByUsername(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByUsername(ctx context.Context, params UsersControllerGetUserByUsernameParams, requestOptions ...RequestOption) (res UsersControllerGetUserByUsernameRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-username/"
	{
		// Encode "username" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "username",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Username))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByUsernameOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByUsernameResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUserByUuid invokes UsersController_getUserByUuid operation.
//
// Get user by UUID.
//
// GET /api/users/{uuid}
func (c *Client) UsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, options ...RequestOption) (UsersControllerGetUserByUuidRes, error) {
	res, err := c.sendUsersControllerGetUserByUuid(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUserByUuid(ctx context.Context, params UsersControllerGetUserByUuidParams, requestOptions ...RequestOption) (res UsersControllerGetUserByUuidRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUserByUuidOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUserByUuidResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUsersByEmail invokes UsersController_getUsersByEmail operation.
//
// Get users by email.
//
// GET /api/users/by-email/{email}
func (c *Client) UsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, options ...RequestOption) (UsersControllerGetUsersByEmailRes, error) {
	res, err := c.sendUsersControllerGetUsersByEmail(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUsersByEmail(ctx context.Context, params UsersControllerGetUsersByEmailParams, requestOptions ...RequestOption) (res UsersControllerGetUsersByEmailRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-email/"
	{
		// Encode "email" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "email",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Email))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUsersByEmailOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUsersByEmailResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerGetUsersByTag invokes UsersController_getUsersByTag operation.
//
// Get users by tag.
//
// GET /api/users/by-tag/{tag}
func (c *Client) UsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, options ...RequestOption) (UsersControllerGetUsersByTagRes, error) {
	res, err := c.sendUsersControllerGetUsersByTag(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerGetUsersByTag(ctx context.Context, params UsersControllerGetUsersByTagParams, requestOptions ...RequestOption) (res UsersControllerGetUsersByTagRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [2]string
	pathParts[0] = "/api/users/by-tag/"
	{
		// Encode "tag" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tag",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.Tag))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerGetUsersByTagOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerGetUsersByTagResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerResetUserTraffic invokes UsersController_resetUserTraffic operation.
//
// Reset user traffic.
//
// POST /api/users/{uuid}/actions/reset-traffic
func (c *Client) UsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, options ...RequestOption) (UsersControllerResetUserTrafficRes, error) {
	res, err := c.sendUsersControllerResetUserTraffic(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerResetUserTraffic(ctx context.Context, params UsersControllerResetUserTrafficParams, requestOptions ...RequestOption) (res UsersControllerResetUserTrafficRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/reset-traffic"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerResetUserTrafficOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerResetUserTrafficResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerRevokeUserSubscription invokes UsersController_revokeUserSubscription operation.
//
// Revoke user subscription.
//
// POST /api/users/{uuid}/actions/revoke
func (c *Client) UsersControllerRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBodyDto, params UsersControllerRevokeUserSubscriptionParams, options ...RequestOption) (UsersControllerRevokeUserSubscriptionRes, error) {
	res, err := c.sendUsersControllerRevokeUserSubscription(ctx, request, params, options...)
	return res, err
}

func (c *Client) sendUsersControllerRevokeUserSubscription(ctx context.Context, request *RevokeUserSubscriptionBodyDto, params UsersControllerRevokeUserSubscriptionParams, requestOptions ...RequestOption) (res UsersControllerRevokeUserSubscriptionRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/actions/revoke"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersControllerRevokeUserSubscriptionRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerRevokeUserSubscriptionOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerRevokeUserSubscriptionResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersControllerUpdateUser invokes UsersController_updateUser operation.
//
// Update a user.
//
// PATCH /api/users
func (c *Client) UsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, options ...RequestOption) (UsersControllerUpdateUserRes, error) {
	res, err := c.sendUsersControllerUpdateUser(ctx, request, options...)
	return res, err
}

func (c *Client) sendUsersControllerUpdateUser(ctx context.Context, request *UpdateUserRequestDto, requestOptions ...RequestOption) (res UsersControllerUpdateUserRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [1]string
	pathParts[0] = "/api/users"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeUsersControllerUpdateUserRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersControllerUpdateUserOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersControllerUpdateUserResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UsersStatsControllerGetUserUsageByRange invokes UsersStatsController_getUserUsageByRange operation.
//
// Get user usage by range.
//
// GET /api/users/stats/usage/{uuid}/range
func (c *Client) UsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, options ...RequestOption) (UsersStatsControllerGetUserUsageByRangeRes, error) {
	res, err := c.sendUsersStatsControllerGetUserUsageByRange(ctx, params, options...)
	return res, err
}

func (c *Client) sendUsersStatsControllerGetUserUsageByRange(ctx context.Context, params UsersStatsControllerGetUserUsageByRangeParams, requestOptions ...RequestOption) (res UsersStatsControllerGetUserUsageByRangeRes, err error) {

	var reqCfg requestConfig
	reqCfg.setDefaults(c.baseClient)
	for _, o := range requestOptions {
		o(&reqCfg)
	}

	u := c.serverURL
	if override := reqCfg.ServerURL; override != nil {
		u = override
	}
	u = uri.Clone(u)
	var pathParts [3]string
	pathParts[0] = "/api/users/stats/usage/"
	{
		// Encode "uuid" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "uuid",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(params.UUID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/range"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "start" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "start",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.Start))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "end" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "end",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.DateTimeToString(params.End))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityAuthorization(ctx, UsersStatsControllerGetUserUsageByRangeOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"Authorization\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	if err := reqCfg.onRequest(r); err != nil {
		return res, errors.Wrap(err, "edit request")
	}

	resp, err := reqCfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	if err := reqCfg.onResponse(resp); err != nil {
		return res, errors.Wrap(err, "edit response")
	}

	result, err := decodeUsersStatsControllerGetUserUsageByRangeResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
